{"version":3,"file":"js/9149.d235b652.js","mappings":"wOACOA,MAAM,a,UAAYC,EAAAA,EAAAA,GAAwB,UAAhBC,GAAG,KAAG,W,GAAdC,G,0CAAvBC,EAAAA,EAAAA,IAAqD,MAArDC,EAAqD,E,gBAIvD,GACEC,UACEC,KAAKC,MACP,EACAC,QAAS,CACPD,OACE,MAAME,EAAQ,IAAIC,EAAAA,IAEZC,EAASC,SAASC,cAAc,MAChCC,EAAW,IAAIJ,EAAAA,IAAoB,CAAEC,WAC3CG,EAASC,QAAQJ,EAAOK,WAAYL,EAAOM,aAC3CH,EAASI,cAAcC,OAAOC,kBAE9B,MAAMC,EAAS,IAAIX,EAAAA,IACjB,GACAC,EAAOW,YAAcX,EAAOY,aAC5B,EACA,KAEFF,EAAOG,SAASC,EAAI,EAEpB,MAAMC,EAAqB,6KAOrBC,EAAuB,g2IA8HvBC,EAAW,IAAIlB,EAAAA,IAAoB,EAAG,GACtCmB,EAAW,IAAInB,EAAAA,IAAqB,CACxCoB,SAAU,CACRC,YAAa,CAAEC,MAAO,IAAItB,EAAAA,IAAcC,EAAOW,YAAaX,EAAOY,eACnEU,MAAO,CAAED,MAAO,IAElBE,aAAcR,EACdS,eAAgBR,IAElB,IAAIS,EAAQ,IAAI1B,EAAAA,IAAWkB,EAAUC,GAIrC,SAASQ,IACP,GAAIC,EAA4BxB,GAAW,CACzC,MAAMH,EAASG,EAASyB,WACxBlB,EAAOmB,OAAS7B,EAAOW,YAAcX,EAAOY,aAC5CF,EAAOoB,wBACT,CACA,IAAIC,EAAOC,sBAAsBN,GACjCD,EAAMQ,MAAMC,IAAI,KAAOlC,EAAOW,YAAcX,EAAOY,aAAc,KAAM,GACvEa,EAAMP,SAASC,SAASG,MAAQ,CAAED,MAAOU,EAAO,KAChDN,EAAMP,SAASC,SAASC,YAAc,CAAEC,MAAO,IAAItB,EAAAA,IAAcC,EAAOW,YAAaX,EAAOY,eAC5FT,EAASgC,OAAOrC,EAAOY,EACzB,CACA,SAASiB,EAA4BxB,GACnC,MAAMH,EAASG,EAASyB,WAClBQ,EAAQpC,EAAOW,YACf0B,EAASrC,EAAOY,aAChB0B,EAAatC,EAAOoC,QAAUA,GAASpC,EAAOqC,SAAWA,EAI/D,OAHIC,GACFnC,EAASC,QAAQgC,EAAOC,GAAQ,GAE3BC,CACT,CAxBAxC,EAAMyC,IAAId,GAEVC,GAuBF,I,WC3LJ,MAAMc,GAA2B,OAAgB,EAAQ,CAAC,CAAC,SAASL,GAAQ,CAAC,YAAY,qBAEzF,O","sources":["webpack://webgis/./src/components/three/fireworks_effect.vue","webpack://webgis/./src/components/three/fireworks_effect.vue?cf9b"],"sourcesContent":["<template>\n  <div class=\"container\"><canvas id=\"c\"></canvas></div>\n</template>\n<script>\nimport * as THREE from 'three'\nexport default {\n  mounted() {\n    this.init()\n  },\n  methods: {\n    init() {\n      const scene = new THREE.Scene()\n\n      const canvas = document.querySelector('#c')\n      const renderer = new THREE.WebGLRenderer({ canvas })\n      renderer.setSize(canvas.innerWidth, canvas.innerHeight)\n      renderer.setPixelRatio(window.devicePixelRatio)\n\n      const camera = new THREE.PerspectiveCamera(\n        60,\n        canvas.clientWidth / canvas.clientHeight,\n        1,\n        1000\n      )\n      camera.position.z = 4;\n\n      const vertexShaderSource = `\n        out vec2 st;\n        void main() {\n          st =uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n      const fragmentShaderSource = `\n        #define SPARKS 30\n        #define FIREWORKS 8.\n        #define BASE_PAUSE FIREWORKS / 30.\n        #define PI 3.14\n        #define PI2 6.28\n        uniform vec2 iResolution;\n        uniform float iTime;\n\n        float n21(vec2 n) {\n            return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n        }\n\n        vec2 randomSpark(float noise) {\n            vec2 v0 = vec2((noise - .5) * 13., (fract(noise * 123.) - .5) * 15.);\n            return v0;\n        }\n\n        vec2 circularSpark(float i, float noiseId, float noiseSpark) {\n            noiseId = fract(noiseId * 7897654.45);\n            float a = (PI2 / float(SPARKS)) * i;\n            float speed = 10.*clamp(noiseId, .7, 1.);\n            float x = sin(a + iTime*((noiseId-.5)*3.));\n            float y = cos(a + iTime*(fract(noiseId*4567.332) - .5)*2.);\n            vec2 v0 = vec2(x, y) * speed;\n            return v0;\n        }\n\n\n        vec2 rocket(vec2 start, float t) {\n            float y = t;\n            float x = sin(y*10.+cos(t*3.))*.1;\n            vec2 p = start + vec2(x, y * 8.);\n            return p;\n        }\n\n        vec3 firework(vec2 uv, float index, float pauseTime) {\n            vec3 col = vec3(0.);\n\n\n            float timeScale = 1.;\n            vec2 gravity = vec2(0., -9.8);\n\n            float explodeTime = .9;\n            float rocketTime = 1.1;\n            float episodeTime = rocketTime + explodeTime + pauseTime;\n\n            float ratio = iResolution.x / iResolution.y;\n\n            float timeScaled = (iTime - pauseTime) / timeScale;\n\n            float id = floor(timeScaled / episodeTime);\n            float et = mod(timeScaled, episodeTime);\n\n            float noiseId = n21(vec2(id+1., index+1.));\n\n            float scale = clamp(fract(noiseId*567.53)*30., 10., 30.);\n            uv *= scale;\n\n            rocketTime -= (fract(noiseId*1234.543) * .5);\n\n            vec2 pRocket = rocket(vec2(0. + ((noiseId - .5)*scale*ratio), 0. - scale/2.), clamp(et, 0., rocketTime));\n\n            if (et < rocketTime) {\n                float rd = length(uv - pRocket);\n                col += pow(.05/rd , 1.9) * vec3(0.9, .3, .0);\n            }\n\n\n            if (et > rocketTime && et < (rocketTime + explodeTime)) {\n                float burst = sign(fract(noiseId*44432.22) - .6);\n                for(int i = 0 ; i < SPARKS ; i++) {\n                        vec2 center = pRocket;\n                        float fi = float(i);\n                        float noiseSpark = fract(n21(vec2(id*10.+index*20., float(i+1))) * 332.44);\n                        float t = et - rocketTime;\n                        vec2 v0;\n\n                        if (fract(noiseId*3532.33) > .5) {\n                            v0 = randomSpark(noiseSpark);\n                            t -= noiseSpark * (fract(noiseId*543.) * .2);\n                        } else {\n                            v0 = circularSpark(fi, noiseId, noiseSpark);\n\n                            if ( (fract(noiseId*973.22) - .5) > 0.) {\n                                float re = mod(fi, 4. + 10. * noiseId);\n                                t -= floor(re/2.) * burst * .1;\n                            } else {\n                                t -= mod(fi, 2.) == 0. ? 0. : burst * .5*clamp(noiseId, .3, 1.);\n                            }\n                        }\n\n                        vec2 s = v0*t + (gravity * t * t) / 2.;\n\n                        vec2 p = center + s;\n\n                        float d = length(uv - p);\n\n                        if (t > 0.) {\n                            float fade = clamp((1. - t/explodeTime), 0., 1.);\n                            vec3 sparkColor = vec3(noiseId*.9, .5*fract(noiseId *456.33), .5*fract(noiseId *1456.33));\n                            vec3 c = (.05 / d) * sparkColor;\n                            col += c * fade;\n                        }\n                    }\n            }\n\n            return col;\n        }\n\n        void main() {\n          vec4 fragCoords = gl_FragCoord;\n\n          vec2 uv = fragCoords.xy / iResolution.xy;\n          uv -= .5;\n          uv.x *= iResolution.x / iResolution.y;\n\n          vec3 col = vec3(0.);\n\n          for (float i = 0. ; i < FIREWORKS ; i += 1.) {\n              col += firework(uv, i + 1., (i * BASE_PAUSE));\n          }\n\n          gl_FragColor = vec4(col, 1.);\n        }\n        `\n      const geometry = new THREE.PlaneGeometry(1, 1);\n      const material = new THREE.ShaderMaterial({\n        uniforms: {\n          iResolution: { value: new THREE.Vector2(canvas.clientWidth, canvas.clientHeight) },\n          iTime: { value: 0 }\n        },\n        vertexShader: vertexShaderSource,\n        fragmentShader: fragmentShaderSource\n      })\n      let plane = new THREE.Mesh(geometry, material);\n      scene.add(plane);\n      \n      animate()\n      function animate() {\n        if (resizeRendererToDisplaySize(renderer)) {\n          const canvas = renderer.domElement\n          camera.aspect = canvas.clientWidth / canvas.clientHeight\n          camera.updateProjectionMatrix()\n        }\n        let time = requestAnimationFrame(animate)\n        plane.scale.set(4.61 * canvas.clientWidth / canvas.clientHeight, 4.61, 1)\n        plane.material.uniforms.iTime = { value: time / 100 }\n        plane.material.uniforms.iResolution = { value: new THREE.Vector2(canvas.clientWidth, canvas.clientHeight) }\n        renderer.render(scene, camera)\n      }\n      function resizeRendererToDisplaySize(renderer) {\n        const canvas = renderer.domElement\n        const width = canvas.clientWidth\n        const height = canvas.clientHeight\n        const needResize = canvas.width !== width || canvas.height !== height\n        if (needResize) {\n          renderer.setSize(width, height, false)\n        }\n        return needResize\n      }\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.container {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n}\n\n#c {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n  margin: 0%;\n}\n</style>\n","import { render } from \"./fireworks_effect.vue?vue&type=template&id=1b7a02f0&scoped=true\"\nimport script from \"./fireworks_effect.vue?vue&type=script&lang=js\"\nexport * from \"./fireworks_effect.vue?vue&type=script&lang=js\"\n\nimport \"./fireworks_effect.vue?vue&type=style&index=0&id=1b7a02f0&lang=scss&scoped=true\"\n\nimport exportComponent from \"/Users/zhengjie/Documents/webgis/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-1b7a02f0\"]])\n\nexport default __exports__"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","mounted","this","init","methods","scene","THREE","canvas","document","querySelector","renderer","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","camera","clientWidth","clientHeight","position","z","vertexShaderSource","fragmentShaderSource","geometry","material","uniforms","iResolution","value","iTime","vertexShader","fragmentShader","plane","animate","resizeRendererToDisplaySize","domElement","aspect","updateProjectionMatrix","time","requestAnimationFrame","scale","set","render","width","height","needResize","add","__exports__"],"sourceRoot":""}