{"version":3,"file":"js/289.fc4440fc.js","mappings":"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","sources":["webpack://webgis/./node_modules/@cesium/engine/Source/Core/getFilenameFromUri.js","webpack://webgis/./node_modules/@cesium/engine/Source/DataSources/GeoJsonDataSource.js"],"sourcesContent":["import Uri from \"urijs\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Given a URI, returns the last segment of the URI, removing any path or query information.\n * @function getFilenameFromUri\n *\n * @param {String} uri The Uri.\n * @returns {String} The last segment of the Uri.\n *\n * @example\n * //fileName will be\"simple.czml\";\n * const fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');\n */\nfunction getFilenameFromUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uri)) {\n    throw new DeveloperError(\"uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const uriObject = new Uri(uri);\n  uriObject.normalize();\n  let path = uriObject.path();\n  const index = path.lastIndexOf(\"/\");\n  if (index !== -1) {\n    path = path.substr(index + 1);\n  }\n  return path;\n}\nexport default getFilenameFromUri;\n","import ArcType from \"../Core/ArcType.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport * as topojson from \"topojson-client\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\n\nfunction defaultCrsFunction(coordinates) {\n  return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);\n}\n\nconst crsNames = {\n  \"urn:ogc:def:crs:OGC:1.3:CRS84\": defaultCrsFunction,\n  \"EPSG:4326\": defaultCrsFunction,\n  \"urn:ogc:def:crs:EPSG::4326\": defaultCrsFunction,\n};\n\nconst crsLinkHrefs = {};\nconst crsLinkTypes = {};\nlet defaultMarkerSize = 48;\nlet defaultMarkerSymbol;\nlet defaultMarkerColor = Color.ROYALBLUE;\nlet defaultStroke = Color.YELLOW;\nlet defaultStrokeWidth = 2;\nlet defaultFill = Color.fromBytes(255, 255, 0, 100);\nlet defaultClampToGround = false;\n\nconst sizes = {\n  small: 24,\n  medium: 48,\n  large: 64,\n};\n\nconst simpleStyleIdentifiers = [\n  \"title\",\n  \"description\", //\n  \"marker-size\",\n  \"marker-symbol\",\n  \"marker-color\",\n  \"stroke\", //\n  \"stroke-opacity\",\n  \"stroke-width\",\n  \"fill\",\n  \"fill-opacity\",\n];\n\nfunction defaultDescribe(properties, nameProperty) {\n  let html = \"\";\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = properties[key];\n      if (defined(value)) {\n        if (typeof value === \"object\") {\n          html += `<tr><th>${key}</th><td>${defaultDescribe(value)}</td></tr>`;\n        } else {\n          html += `<tr><th>${key}</th><td>${value}</td></tr>`;\n        }\n      }\n    }\n  }\n\n  if (html.length > 0) {\n    html = `<table class=\"cesium-infoBox-defaultTable\"><tbody>${html}</tbody></table>`;\n  }\n\n  return html;\n}\n\nfunction createDescriptionCallback(describe, properties, nameProperty) {\n  let description;\n  return function (time, result) {\n    if (!defined(description)) {\n      description = describe(properties, nameProperty);\n    }\n    return description;\n  };\n}\n\nfunction defaultDescribeProperty(properties, nameProperty) {\n  return new CallbackProperty(\n    createDescriptionCallback(defaultDescribe, properties, nameProperty),\n    true\n  );\n}\n\n//GeoJSON specifies only the Feature object has a usable id property\n//But since \"multi\" geometries create multiple entity,\n//we can't use it for them either.\nfunction createObject(geoJson, entityCollection, describe) {\n  let id = geoJson.id;\n  if (!defined(id) || geoJson.type !== \"Feature\") {\n    id = createGuid();\n  } else {\n    let i = 2;\n    let finalId = id;\n    while (defined(entityCollection.getById(finalId))) {\n      finalId = `${id}_${i}`;\n      i++;\n    }\n    id = finalId;\n  }\n\n  const entity = entityCollection.getOrCreateEntity(id);\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    entity.properties = properties;\n\n    let nameProperty;\n\n    //Check for the simplestyle specified name first.\n    const name = properties.title;\n    if (defined(name)) {\n      entity.name = name;\n      nameProperty = \"title\";\n    } else {\n      //Else, find the name by selecting an appropriate property.\n      //The name will be obtained based on this order:\n      //1) The first case-insensitive property with the name 'title',\n      //2) The first case-insensitive property with the name 'name',\n      //3) The first property containing the word 'title'.\n      //4) The first property containing the word 'name',\n      let namePropertyPrecedence = Number.MAX_VALUE;\n      for (const key in properties) {\n        if (properties.hasOwnProperty(key) && properties[key]) {\n          const lowerKey = key.toLowerCase();\n\n          if (namePropertyPrecedence > 1 && lowerKey === \"title\") {\n            namePropertyPrecedence = 1;\n            nameProperty = key;\n            break;\n          } else if (namePropertyPrecedence > 2 && lowerKey === \"name\") {\n            namePropertyPrecedence = 2;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 3 && /title/i.test(key)) {\n            namePropertyPrecedence = 3;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 4 && /name/i.test(key)) {\n            namePropertyPrecedence = 4;\n            nameProperty = key;\n          }\n        }\n      }\n      if (defined(nameProperty)) {\n        entity.name = properties[nameProperty];\n      }\n    }\n\n    const description = properties.description;\n    if (description !== null) {\n      entity.description = !defined(description)\n        ? describe(properties, nameProperty)\n        : new ConstantProperty(description);\n    }\n  }\n  return entity;\n}\n\nfunction coordinatesArrayToCartesianArray(coordinates, crsFunction) {\n  const positions = new Array(coordinates.length);\n  for (let i = 0; i < coordinates.length; i++) {\n    positions[i] = crsFunction(coordinates[i]);\n  }\n  return positions;\n}\n\nconst geoJsonObjectTypes = {\n  Feature: processFeature,\n  FeatureCollection: processFeatureCollection,\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology,\n};\n\nconst geometryTypes = {\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology,\n};\n\n// GeoJSON processing functions\nfunction processFeature(dataSource, feature, notUsed, crsFunction, options) {\n  if (feature.geometry === null) {\n    //Null geometry is allowed, so just create an empty entity instance for it.\n    createObject(feature, dataSource._entityCollection, options.describe);\n    return;\n  }\n\n  if (!defined(feature.geometry)) {\n    throw new RuntimeError(\"feature.geometry is required.\");\n  }\n\n  const geometryType = feature.geometry.type;\n  const geometryHandler = geometryTypes[geometryType];\n  if (!defined(geometryHandler)) {\n    throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n  }\n  geometryHandler(dataSource, feature, feature.geometry, crsFunction, options);\n}\n\nfunction processFeatureCollection(\n  dataSource,\n  featureCollection,\n  notUsed,\n  crsFunction,\n  options\n) {\n  const features = featureCollection.features;\n  for (let i = 0, len = features.length; i < len; i++) {\n    processFeature(dataSource, features[i], undefined, crsFunction, options);\n  }\n}\n\nfunction processGeometryCollection(\n  dataSource,\n  geoJson,\n  geometryCollection,\n  crsFunction,\n  options\n) {\n  const geometries = geometryCollection.geometries;\n  for (let i = 0, len = geometries.length; i < len; i++) {\n    const geometry = geometries[i];\n    const geometryType = geometry.type;\n    const geometryHandler = geometryTypes[geometryType];\n    if (!defined(geometryHandler)) {\n      throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n    }\n    geometryHandler(dataSource, geoJson, geometry, crsFunction, options);\n  }\n}\n\nfunction createPoint(dataSource, geoJson, crsFunction, coordinates, options) {\n  let symbol = options.markerSymbol;\n  let color = options.markerColor;\n  let size = options.markerSize;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const cssColor = properties[\"marker-color\"];\n    if (defined(cssColor)) {\n      color = Color.fromCssColorString(cssColor);\n    }\n\n    size = defaultValue(sizes[properties[\"marker-size\"]], size);\n    const markerSymbol = properties[\"marker-symbol\"];\n    if (defined(markerSymbol)) {\n      symbol = markerSymbol;\n    }\n  }\n\n  let canvasOrPromise;\n  if (defined(symbol)) {\n    if (symbol.length === 1) {\n      canvasOrPromise = dataSource._pinBuilder.fromText(\n        symbol.toUpperCase(),\n        color,\n        size\n      );\n    } else {\n      canvasOrPromise = dataSource._pinBuilder.fromMakiIconId(\n        symbol,\n        color,\n        size\n      );\n    }\n  } else {\n    canvasOrPromise = dataSource._pinBuilder.fromColor(color, size);\n  }\n\n  const billboard = new BillboardGraphics();\n  billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);\n\n  // Clamp to ground if there isn't a height specified\n  if (coordinates.length === 2 && options.clampToGround) {\n    billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe\n  );\n  entity.billboard = billboard;\n  entity.position = new ConstantPositionProperty(crsFunction(coordinates));\n\n  const promise = Promise.resolve(canvasOrPromise)\n    .then(function (image) {\n      billboard.image = new ConstantProperty(image);\n    })\n    .catch(function () {\n      billboard.image = new ConstantProperty(\n        dataSource._pinBuilder.fromColor(color, size)\n      );\n    });\n\n  dataSource._promises.push(promise);\n}\n\nfunction processPoint(dataSource, geoJson, geometry, crsFunction, options) {\n  createPoint(dataSource, geoJson, crsFunction, geometry.coordinates, options);\n}\n\nfunction processMultiPoint(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  const coordinates = geometry.coordinates;\n  for (let i = 0; i < coordinates.length; i++) {\n    createPoint(dataSource, geoJson, crsFunction, coordinates[i], options);\n  }\n}\n\nfunction createLineString(\n  dataSource,\n  geoJson,\n  crsFunction,\n  coordinates,\n  options\n) {\n  let material = options.strokeMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    const opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = material.color.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n    if (defined(color)) {\n      material = new ColorMaterialProperty(color);\n    }\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe\n  );\n  const polylineGraphics = new PolylineGraphics();\n  entity.polyline = polylineGraphics;\n\n  polylineGraphics.clampToGround = options.clampToGround;\n  polylineGraphics.material = material;\n  polylineGraphics.width = widthProperty;\n  polylineGraphics.positions = new ConstantProperty(\n    coordinatesArrayToCartesianArray(coordinates, crsFunction)\n  );\n  polylineGraphics.arcType = ArcType.RHUMB;\n}\n\nfunction processLineString(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  createLineString(\n    dataSource,\n    geoJson,\n    crsFunction,\n    geometry.coordinates,\n    options\n  );\n}\n\nfunction processMultiLineString(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  const lineStrings = geometry.coordinates;\n  for (let i = 0; i < lineStrings.length; i++) {\n    createLineString(dataSource, geoJson, crsFunction, lineStrings[i], options);\n  }\n}\n\nfunction createPolygon(dataSource, geoJson, crsFunction, coordinates, options) {\n  if (coordinates.length === 0 || coordinates[0].length === 0) {\n    return;\n  }\n\n  let outlineColorProperty = options.strokeMaterialProperty.color;\n  let material = options.fillMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    let opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = outlineColorProperty.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n\n    if (defined(color)) {\n      outlineColorProperty = new ConstantProperty(color);\n    }\n\n    let fillColor;\n    const fill = properties.fill;\n    const materialColor = material.color.getValue();\n    if (defined(fill)) {\n      fillColor = Color.fromCssColorString(fill);\n      fillColor.alpha = materialColor.alpha;\n    }\n    opacity = properties[\"fill-opacity\"];\n    if (defined(opacity) && opacity !== materialColor.alpha) {\n      if (!defined(fillColor)) {\n        fillColor = materialColor.clone();\n      }\n      fillColor.alpha = opacity;\n    }\n    if (defined(fillColor)) {\n      material = new ColorMaterialProperty(fillColor);\n    }\n  }\n\n  const polygon = new PolygonGraphics();\n  polygon.outline = new ConstantProperty(true);\n  polygon.outlineColor = outlineColorProperty;\n  polygon.outlineWidth = widthProperty;\n  polygon.material = material;\n  polygon.arcType = ArcType.RHUMB;\n\n  const holes = [];\n  for (let i = 1, len = coordinates.length; i < len; i++) {\n    holes.push(\n      new PolygonHierarchy(\n        coordinatesArrayToCartesianArray(coordinates[i], crsFunction)\n      )\n    );\n  }\n\n  const positions = coordinates[0];\n  polygon.hierarchy = new ConstantProperty(\n    new PolygonHierarchy(\n      coordinatesArrayToCartesianArray(positions, crsFunction),\n      holes\n    )\n  );\n  if (positions[0].length > 2) {\n    polygon.perPositionHeight = new ConstantProperty(true);\n  } else if (!options.clampToGround) {\n    polygon.height = 0;\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe\n  );\n  entity.polygon = polygon;\n}\n\nfunction processPolygon(dataSource, geoJson, geometry, crsFunction, options) {\n  createPolygon(\n    dataSource,\n    geoJson,\n    crsFunction,\n    geometry.coordinates,\n    options\n  );\n}\n\nfunction processMultiPolygon(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  const polygons = geometry.coordinates;\n  for (let i = 0; i < polygons.length; i++) {\n    createPolygon(dataSource, geoJson, crsFunction, polygons[i], options);\n  }\n}\n\nfunction processTopology(dataSource, geoJson, geometry, crsFunction, options) {\n  for (const property in geometry.objects) {\n    if (geometry.objects.hasOwnProperty(property)) {\n      const feature = topojson.feature(geometry, geometry.objects[property]);\n      const typeHandler = geoJsonObjectTypes[feature.type];\n      typeHandler(dataSource, feature, feature, crsFunction, options);\n    }\n  }\n}\n\n/**\n * @typedef {Object} GeoJsonDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {String} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {GeoJsonDataSource.describe} [describe=GeoJsonDataSource.defaultDescribeProperty] A function which returns a Property object (or just a string).\n * @property {Number} [markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.\n * @property {String} [markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.\n * @property {Color} [markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.\n * @property {Color} [stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.\n * @property {Number} [strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.\n * @property {Color} [fill=GeoJsonDataSource.fill] The default color for polygon interiors.\n * @property {Boolean} [clampToGround=GeoJsonDataSource.clampToGround] true if we want the geometry features (polygons or linestrings) clamped to the ground.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes both\n * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.\n * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they\n * are present.\n *\n * @alias GeoJsonDataSource\n * @constructor\n *\n * @param {String} [name] The name of this data source.  If undefined, a name will be taken from\n *                        the name of the GeoJSON file.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20and%20TopoJSON.html|Cesium Sandcastle GeoJSON and TopoJSON Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20simplestyle.html|Cesium Sandcastle GeoJSON simplestyle Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {\n *   stroke: Cesium.Color.HOTPINK,\n *   fill: Cesium.Color.PINK,\n *   strokeWidth: 3,\n *   markerSymbol: '?'\n * }));\n */\nfunction GeoJsonDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._entityCollection = new EntityCollection(this);\n  this._promises = [];\n  this._pinBuilder = new PinBuilder();\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.\n *\n * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise.<GeoJsonDataSource>} A promise that will resolve when the data is loaded.\n */\nGeoJsonDataSource.load = function (data, options) {\n  return new GeoJsonDataSource().load(data, options);\n};\n\nObject.defineProperties(GeoJsonDataSource, {\n  /**\n   * Gets or sets the default size of the map pin created for each point, in pixels.\n   * @memberof GeoJsonDataSource\n   * @type {Number}\n   * @default 48\n   */\n  markerSize: {\n    get: function () {\n      return defaultMarkerSize;\n    },\n    set: function (value) {\n      defaultMarkerSize = value;\n    },\n  },\n  /**\n   * Gets or sets the default symbol of the map pin created for each point.\n   * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,\n   * or blank if no symbol is to be used.\n   * @memberof GeoJsonDataSource\n   * @type {String}\n   */\n  markerSymbol: {\n    get: function () {\n      return defaultMarkerSymbol;\n    },\n    set: function (value) {\n      defaultMarkerSymbol = value;\n    },\n  },\n  /**\n   * Gets or sets the default color of the map pin created for each point.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.ROYALBLUE\n   */\n  markerColor: {\n    get: function () {\n      return defaultMarkerColor;\n    },\n    set: function (value) {\n      defaultMarkerColor = value;\n    },\n  },\n  /**\n   * Gets or sets the default color of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.BLACK\n   */\n  stroke: {\n    get: function () {\n      return defaultStroke;\n    },\n    set: function (value) {\n      defaultStroke = value;\n    },\n  },\n  /**\n   * Gets or sets the default width of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {Number}\n   * @default 2.0\n   */\n  strokeWidth: {\n    get: function () {\n      return defaultStrokeWidth;\n    },\n    set: function (value) {\n      defaultStrokeWidth = value;\n    },\n  },\n  /**\n   * Gets or sets default color for polygon interiors.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.YELLOW\n   */\n  fill: {\n    get: function () {\n      return defaultFill;\n    },\n    set: function (value) {\n      defaultFill = value;\n    },\n  },\n  /**\n   * Gets or sets default of whether to clamp to the ground.\n   * @memberof GeoJsonDataSource\n   * @type {Boolean}\n   * @default false\n   */\n  clampToGround: {\n    get: function () {\n      return defaultClampToGround;\n    },\n    set: function (value) {\n      defaultClampToGround = value;\n    },\n  },\n\n  /**\n   * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate\n   * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which\n   * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,\n   * for example 'EPSG:4326'.\n   * @memberof GeoJsonDataSource\n   * @type {Object}\n   */\n  crsNames: {\n    get: function () {\n      return crsNames;\n    },\n  },\n\n  /**\n   * Gets an object that maps the href property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming\n   * the link has a type specified.\n   * @memberof GeoJsonDataSource\n   * @type {Object}\n   */\n  crsLinkHrefs: {\n    get: function () {\n      return crsLinkHrefs;\n    },\n  },\n\n  /**\n   * Gets an object that maps the type property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in <code>crsLinkHrefs</code> take precedence over this object.\n   * @memberof GeoJsonDataSource\n   * @type {Object}\n   */\n  crsLinkTypes: {\n    get: function () {\n      return crsLinkTypes;\n    },\n  },\n});\n\nObject.defineProperties(GeoJsonDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {String}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * This DataSource only defines static data, therefore this property is always undefined.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    value: undefined,\n    writable: false,\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.\n *\n * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise.<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.load = function (data, options) {\n  return preload(this, data, options, true);\n};\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, without replacing any existing data.\n *\n * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise.<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.process = function (data, options) {\n  return preload(this, data, options, false);\n};\n\nfunction preload(that, data, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  DataSource.setLoading(that, true);\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  that._credit = credit;\n\n  let promise = data;\n  let sourceUri = options.sourceUri;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchJson();\n    sourceUri = defaultValue(sourceUri, data.getUrlComponent());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = that._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n\n  options = {\n    describe: defaultValue(options.describe, defaultDescribeProperty),\n    markerSize: defaultValue(options.markerSize, defaultMarkerSize),\n    markerSymbol: defaultValue(options.markerSymbol, defaultMarkerSymbol),\n    markerColor: defaultValue(options.markerColor, defaultMarkerColor),\n    strokeWidthProperty: new ConstantProperty(\n      defaultValue(options.strokeWidth, defaultStrokeWidth)\n    ),\n    strokeMaterialProperty: new ColorMaterialProperty(\n      defaultValue(options.stroke, defaultStroke)\n    ),\n    fillMaterialProperty: new ColorMaterialProperty(\n      defaultValue(options.fill, defaultFill)\n    ),\n    clampToGround: defaultValue(options.clampToGround, defaultClampToGround),\n  };\n\n  return Promise.resolve(promise)\n    .then(function (geoJson) {\n      return load(that, geoJson, options, sourceUri, clear);\n    })\n    .catch(function (error) {\n      DataSource.setLoading(that, false);\n      that._error.raiseEvent(that, error);\n      throw error;\n    });\n}\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nGeoJsonDataSource.prototype.update = function (time) {\n  return true;\n};\n\nfunction load(that, geoJson, options, sourceUri, clear) {\n  let name;\n  if (defined(sourceUri)) {\n    name = getFilenameFromUri(sourceUri);\n  }\n\n  if (defined(name) && that._name !== name) {\n    that._name = name;\n    that._changed.raiseEvent(that);\n  }\n\n  const typeHandler = geoJsonObjectTypes[geoJson.type];\n  if (!defined(typeHandler)) {\n    throw new RuntimeError(`Unsupported GeoJSON object type: ${geoJson.type}`);\n  }\n\n  //Check for a Coordinate Reference System.\n  const crs = geoJson.crs;\n  let crsFunction = crs !== null ? defaultCrsFunction : null;\n\n  if (defined(crs)) {\n    if (!defined(crs.properties)) {\n      throw new RuntimeError(\"crs.properties is undefined.\");\n    }\n\n    const properties = crs.properties;\n    if (crs.type === \"name\") {\n      crsFunction = crsNames[properties.name];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs name: ${properties.name}`);\n      }\n    } else if (crs.type === \"link\") {\n      let handler = crsLinkHrefs[properties.href];\n      if (!defined(handler)) {\n        handler = crsLinkTypes[properties.type];\n      }\n\n      if (!defined(handler)) {\n        throw new RuntimeError(\n          `Unable to resolve crs link: ${JSON.stringify(properties)}`\n        );\n      }\n\n      crsFunction = handler(properties);\n    } else if (crs.type === \"EPSG\") {\n      crsFunction = crsNames[`EPSG:${properties.code}`];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs EPSG code: ${properties.code}`);\n      }\n    } else {\n      throw new RuntimeError(`Unknown crs type: ${crs.type}`);\n    }\n  }\n\n  return Promise.resolve(crsFunction).then(function (crsFunction) {\n    if (clear) {\n      that._entityCollection.removeAll();\n    }\n\n    // null is a valid value for the crs, but means the entire load process becomes a no-op\n    // because we can't assume anything about the coordinates.\n    if (crsFunction !== null) {\n      typeHandler(that, geoJson, geoJson, crsFunction, options);\n    }\n\n    return Promise.all(that._promises).then(function () {\n      that._promises.length = 0;\n      DataSource.setLoading(that, false);\n      return that;\n    });\n  });\n}\n\n/**\n * This callback is displayed as part of the GeoJsonDataSource class.\n * @callback GeoJsonDataSource.describe\n * @param {Object} properties The properties of the feature.\n * @param {String} nameProperty The property key that Cesium estimates to have the name of the feature.\n */\nexport default GeoJsonDataSource;\n"],"names":["getFilenameFromUri","uri","defined","DeveloperError","uriObject","Uri","normalize","path","index","lastIndexOf","substr","defaultCrsFunction","coordinates","Cartesian3","crsNames","crsLinkHrefs","crsLinkTypes","defaultMarkerSymbol","defaultMarkerSize","defaultMarkerColor","Color","defaultStroke","defaultStrokeWidth","defaultFill","defaultClampToGround","sizes","small","medium","large","simpleStyleIdentifiers","defaultDescribe","properties","nameProperty","html","key","hasOwnProperty","indexOf","value","length","createDescriptionCallback","describe","description","time","result","defaultDescribeProperty","CallbackProperty","createObject","geoJson","entityCollection","id","type","i","finalId","getById","createGuid","entity","getOrCreateEntity","name","title","namePropertyPrecedence","Number","MAX_VALUE","lowerKey","toLowerCase","test","ConstantProperty","coordinatesArrayToCartesianArray","crsFunction","positions","Array","geoJsonObjectTypes","Feature","processFeature","FeatureCollection","processFeatureCollection","GeometryCollection","processGeometryCollection","LineString","processLineString","MultiLineString","processMultiLineString","MultiPoint","processMultiPoint","MultiPolygon","processMultiPolygon","Point","processPoint","Polygon","processPolygon","Topology","processTopology","geometryTypes","dataSource","feature","notUsed","options","geometry","_entityCollection","RuntimeError","geometryType","geometryHandler","featureCollection","features","len","undefined","geometryCollection","geometries","createPoint","symbol","markerSymbol","color","markerColor","size","markerSize","cssColor","defaultValue","canvasOrPromise","_pinBuilder","fromText","toUpperCase","fromMakiIconId","fromColor","billboard","BillboardGraphics","verticalOrigin","VerticalOrigin","clampToGround","heightReference","HeightReference","position","ConstantPositionProperty","promise","Promise","resolve","then","image","catch","_promises","push","createLineString","material","strokeMaterialProperty","widthProperty","strokeWidthProperty","width","stroke","opacity","getValue","clone","alpha","ColorMaterialProperty","polylineGraphics","PolylineGraphics","polyline","arcType","ArcType","lineStrings","createPolygon","outlineColorProperty","fillMaterialProperty","fillColor","fill","materialColor","polygon","PolygonGraphics","outline","outlineColor","outlineWidth","holes","PolygonHierarchy","hierarchy","perPositionHeight","height","polygons","property","objects","topojson","typeHandler","GeoJsonDataSource","this","_name","_changed","Event","_error","_isLoading","_loading","EntityCollection","PinBuilder","_entityCluster","EntityCluster","_credit","_resourceCredits","preload","that","data","clear","DataSource","credit","Credit","sourceUri","Resource","fetchJson","getUrlComponent","resourceCredits","credits","strokeWidth","load","error","raiseEvent","crs","handler","href","JSON","stringify","code","removeAll","all","Object","defineProperties","get","set","prototype","clock","writable","entities","isLoading","changedEvent","errorEvent","loadingEvent","show","clustering","process","update"],"sourceRoot":""}