{"version":3,"file":"js/110.b4eb7f81.js","mappings":"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","sources":["webpack://webgis/./src/components/three/high_speed_light_trails.vue","webpack://webgis/./src/components/three/high_speed_light_trails.vue?e9ca"],"sourcesContent":["<template>\r\n    <div class=\"container\"><canvas id=\"c\"></canvas></div>\r\n</template>\r\n<script>\r\nimport * as THREE from 'three'\r\nclass Road {\r\n    constructor(scene, options) {\r\n        this.scene = scene;\r\n        this.options = options;\r\n        this.init()\r\n    }\r\n    init() {\r\n        const options = this.options;\r\n        const geometry = new THREE.PlaneBufferGeometry(options.width, options.length, 20, 200\r\n        );\r\n        const material = new THREE.ShaderMaterial({\r\n            uniforms: Object.assign(\r\n                {\r\n                    uColor: new THREE.Uniform(new THREE.Color(0x101012)),\r\n                    uTime: new THREE.Uniform(0),\r\n                    uTravelLength: new THREE.Uniform(options.length)\r\n                },\r\n                options.distortion.uniforms\r\n            ),\r\n            vertexShader: `\r\n                uniform float uTravelLength;\r\n                #include <getDistortion_vertex>\r\n                void main(){\r\n                    vec3 transformed = position.xyz;\r\n                        \r\n                    float progress = (transformed.y + uTravelLength / 2.) / uTravelLength;\r\n                    vec3 distortion  = getDistortion(progress);\r\n                    transformed.x += distortion.x;\r\n                    transformed.z += distortion.y;\r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.);\r\n                }\r\n                `,\r\n            fragmentShader: `\r\n                uniform vec3 uColor;\r\n                void main(){\r\n                    gl_FragColor = vec4(uColor,1.);\r\n                }\r\n                `,\r\n            side: THREE.DoubleSide\r\n        })\r\n        material.onBeforeCompile = shader => {\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n                \"#include <getDistortion_vertex>\",\r\n                options.distortion.getDistortion\r\n            );\r\n        };\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n\r\n        mesh.rotation.x = -Math.PI / 2;\r\n        mesh.position.z = -options.length / 2;\r\n\r\n        this.scene.add(mesh);\r\n        console.log(mesh);\r\n    }\r\n}\r\nclass CarLights {\r\n    constructor(scene, options, color, speed) {\r\n        this.scene = scene;\r\n        this.options = options;\r\n        this.color = color;\r\n        this.speed = speed;\r\n        this.init()\r\n    }\r\n    init() {\r\n        const options = this.options;\r\n\r\n        const curve = new THREE.LineCurve3(\r\n            new THREE.Vector3(0, 0, 0),\r\n            new THREE.Vector3(0, 0, -1)\r\n        )\r\n        const baseGeometry = new THREE.TubeBufferGeometry(curve, 25, 1, 8, false);\r\n\r\n        const instanced = new THREE.InstancedBufferGeometry().copy(baseGeometry);\r\n        instanced.instanceCount = options.nPairs * 2;\r\n        let aOffset = [];\r\n        let aMetrics = [];\r\n        let sectionWidth = options.roadWidth / options.roadSections;\r\n        for (let i = 0; i < options.nPairs; i++) {\r\n            let radius = Math.random() * 0.1 + 0.1;\r\n            let length =\r\n                Math.random() * options.length * 0.08 + options.length * 0.02;\r\n            // 1a. Get it's lane index\r\n            // Instead of random, keep lights per lane consistent\r\n            let section = i % 3;\r\n\r\n            // 1b. Get its lane's centered position\r\n            let sectionX = section * sectionWidth - options.roadWidth / 2 + sectionWidth / 2;\r\n            let carWidth = 0.5 * sectionWidth;\r\n            let offsetX = 0.5 * Math.random();\r\n\r\n            let offsetY = radius * 1.3;\r\n\r\n            let offsetZ = Math.random() * options.length;\r\n\r\n            aOffset.push(sectionX - carWidth / 2 + offsetX);\r\n            aOffset.push(offsetY);\r\n            aOffset.push(-offsetZ);\r\n\r\n            aOffset.push(sectionX + carWidth / 2 + offsetX);\r\n            aOffset.push(offsetY);\r\n            aOffset.push(-offsetZ);\r\n\r\n            aMetrics.push(radius);\r\n            aMetrics.push(length);\r\n\r\n            aMetrics.push(radius);\r\n            aMetrics.push(length);\r\n        }\r\n        // Add the offset to the instanced geometry.\r\n        instanced.setAttribute(\r\n            \"aOffset\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false)\r\n        );\r\n        instanced.setAttribute(\r\n            \"aMetrics\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\r\n        );\r\n        const material = new THREE.ShaderMaterial({\r\n            fragmentShader: `\r\n                uniform vec3 uColor;\r\n                void main() {\r\n                    vec3 color = vec3(uColor);\r\n                    gl_FragColor = vec4(uColor,1.);\r\n                }\r\n                `,\r\n            vertexShader: `\r\n                attribute vec3 aOffset;\r\n                attribute vec2 aMetrics;\r\n                uniform float uTime;\r\n                uniform float uSpeed;\r\n                uniform float uTravelLength;\r\n                #include <getDistortion_vertex>\r\n                void main() {\r\n                    vec3 transformed = position.xyz;\r\n\r\n                    float radius = aMetrics.r;\r\n                    float len = aMetrics.g;\r\n                    transformed.xy *= radius; \r\n                    transformed.z *= len;\r\n\r\n                    float zOffset = uTime * uSpeed + aOffset.z;\r\n                    zOffset = len - mod(zOffset, uTravelLength);\r\n\r\n                    // transformed.z +=uTime * uSpeed;\r\n\r\n\r\n                    // Keep them separated to make the next step easier!\r\n                    transformed.z = transformed.z +zOffset ;\r\n                    transformed.xy += aOffset.xy;\r\n\r\n\r\n                    float progress = abs(transformed.z / uTravelLength);\r\n                    transformed.xyz += getDistortion(progress);\r\n\r\n\r\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\r\n                    gl_Position = projectionMatrix * mvPosition;\r\n                }`,\r\n            uniforms: Object.assign(\r\n                {\r\n                    uColor: new THREE.Uniform(new THREE.Color(this.color)),\r\n                    uTravelLength: new THREE.Uniform(options.length),\r\n                    uTime: new THREE.Uniform(0),\r\n                    uSpeed: new THREE.Uniform(this.speed)\r\n                },\r\n                options.distortion.uniforms\r\n            )\r\n        });\r\n        material.onBeforeCompile = shader => {\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n                \"#include <getDistortion_vertex>\",\r\n                options.distortion.getDistortion\r\n            );\r\n        };\r\n        let mesh = new THREE.Mesh(instanced, material);\r\n        mesh.frustumCulled = false;\r\n        this.mesh = mesh;\r\n        this.scene.add(mesh);\r\n    }\r\n    update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;\r\n    }\r\n}\r\nclass App {\r\n    constructor(canvas) {\r\n        this.canvas = canvas\r\n        this.clock = new THREE.Clock();\r\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });\r\n        this.renderer.setSize(this.canvas.innerWidth, this.canvas.innerHeight)\r\n        this.renderer.setPixelRatio(window.devicePixelRatio)\r\n\r\n        this.scene = new THREE.Scene()\r\n        this.camera = new THREE.PerspectiveCamera(45, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 10000)\r\n        this.camera.position.z = -5;\r\n        this.camera.position.y = 7;\r\n        this.camera.position.x = 0;\r\n\r\n        const distortion_uniforms = {\r\n            uDistortionX: new THREE.Uniform(new THREE.Vector2(40, 3)),\r\n            uDistortionY: new THREE.Uniform(new THREE.Vector2(-40, 2.5))\r\n        };\r\n\r\n        const distortion_vertex = `\r\n            #define PI 3.14159265358979\r\n            uniform vec2 uDistortionX;\r\n            uniform vec2 uDistortionY;\r\n\r\n            float nsin(float val){\r\n            return sin(val) * 0.5+0.5;\r\n            }\r\n            vec3 getDistortion(float progress){\r\n                progress = clamp(progress, 0.,1.);\r\n                float xAmp = uDistortionX.r;\r\n                float xFreq = uDistortionX.g;\r\n                float yAmp = uDistortionY.r;\r\n                float yFreq = uDistortionY.g;\r\n                return vec3( \r\n                    xAmp * nsin(progress* PI * xFreq   - PI / 2. ) ,\r\n                    yAmp * nsin(progress * PI *yFreq - PI / 2.  ) ,\r\n                    0.\r\n                );\r\n            }\r\n            `;\r\n\r\n        const myCustomDistortion = {\r\n            uniforms: distortion_uniforms,\r\n            getDistortion: distortion_vertex\r\n        };\r\n\r\n        const options = {\r\n            length: 400,\r\n            width: 20,\r\n            roadWidth: 9,\r\n            islandWidth: 2,\r\n            nPairs: 50,\r\n            roadSections: 3,\r\n            distortion: myCustomDistortion\r\n        };\r\n\r\n\r\n        this.road = new Road(this.scene, options);\r\n        this.leftLights = new CarLights(this.scene, options, 0xff102a, 60);\r\n        this.leftLights.mesh.position.setX(\r\n            -options.roadWidth / 2 - options.islandWidth / 2\r\n        );\r\n        this.rightLights = new CarLights(this.scene, options, 0xfafafa, -60);\r\n        this.rightLights.mesh.position.setX(\r\n            options.roadWidth / 2 + options.islandWidth / 2\r\n        );\r\n    }\r\n\r\n    update(delta) {\r\n        let time = this.clock.elapsedTime;\r\n        this.leftLights.update(time);\r\n        this.rightLights.update(time);\r\n    }\r\n    resizeRendererToDisplaySize(renderer) {\r\n        const canvas = renderer.domElement\r\n        const width = canvas.clientWidth\r\n        const height = canvas.clientHeight\r\n        const needResize = canvas.width !== width || canvas.height !== height\r\n        if (needResize) {\r\n            renderer.setSize(width, height, false)\r\n        }\r\n        return needResize\r\n    }\r\n    render() {\r\n        if (this.resizeRendererToDisplaySize(this.renderer)) {\r\n            const canvas = this.renderer.domElement\r\n            this.camera.aspect = canvas.clientWidth / canvas.clientHeight\r\n            this.camera.updateProjectionMatrix()\r\n        }\r\n        const delta = this.clock.getDelta();\r\n        this.update(delta);\r\n        this.renderer.render(this.scene, this.camera);\r\n        requestAnimationFrame(this.render.bind(this));\r\n    }\r\n}\r\n\r\nexport default {\r\n    mounted() {\r\n        this.init()\r\n    },\r\n    methods: {\r\n        init() {\r\n            const canvas = document.querySelector('#c')\r\n            const app = new App(canvas)\r\n            app.render()\r\n        },\r\n    },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.container {\r\n    position: absolute;\r\n    height: 100%;\r\n    width: 100%;\r\n}\r\n\r\n#c {\r\n    position: absolute;\r\n    height: 100%;\r\n    width: 100%;\r\n    margin: 0%;\r\n}\r\n</style>\r\n","import { render } from \"./high_speed_light_trails.vue?vue&type=template&id=31eae830&scoped=true\"\nimport script from \"./high_speed_light_trails.vue?vue&type=script&lang=js\"\nexport * from \"./high_speed_light_trails.vue?vue&type=script&lang=js\"\n\nimport \"./high_speed_light_trails.vue?vue&type=style&index=0&id=31eae830&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-31eae830\"]])\n\nexport default __exports__"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","Road","constructor","scene","options","this","init","geometry","THREE","width","length","material","uniforms","Object","assign","uColor","uTime","uTravelLength","distortion","vertexShader","fragmentShader","side","onBeforeCompile","shader","replace","getDistortion","mesh","rotation","x","Math","PI","position","z","add","console","log","CarLights","color","speed","curve","baseGeometry","instanced","copy","instanceCount","nPairs","aOffset","aMetrics","sectionWidth","roadWidth","roadSections","i","radius","random","section","sectionX","carWidth","offsetX","offsetY","offsetZ","push","setAttribute","Float32Array","uSpeed","frustumCulled","update","time","value","App","canvas","clock","renderer","antialias","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","camera","clientWidth","clientHeight","y","distortion_uniforms","uDistortionX","uDistortionY","distortion_vertex","myCustomDistortion","islandWidth","road","leftLights","setX","rightLights","delta","elapsedTime","resizeRendererToDisplaySize","domElement","height","needResize","render","aspect","updateProjectionMatrix","getDelta","requestAnimationFrame","bind","mounted","methods","document","querySelector","app","__exports__"],"sourceRoot":""}