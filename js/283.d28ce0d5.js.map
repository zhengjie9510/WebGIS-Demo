{"version":3,"file":"js/283.d28ce0d5.js","mappings":"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","sources":["webpack://webgis/./src/components/cesium/dynamic_building.vue","webpack://webgis/./src/components/cesium/plugins/PolygonGeometry.js","webpack://webgis/./src/components/cesium/dynamic_building.vue?090c"],"sourcesContent":["<template>\r\n  <div id=\"cesiumContainer\"></div>\r\n</template>\r\n\r\n<script>\r\nimport 'cesium/Build/Cesium/Widgets/widgets.css'\r\nimport {\r\n  Viewer,\r\n  FeatureDetection,\r\n  MaterialAppearance,\r\n  GeometryInstance,\r\n  Primitive,\r\n  Material,\r\n  Color,\r\n  GeoJsonDataSource,\r\n  Cartesian3,\r\n  Matrix4\r\n} from 'cesium'\r\nimport { default as PolygonGeometry } from './plugins/PolygonGeometry'\r\nconst building = require('../../../public/SampleData/building.json')\r\n\r\nexport default {\r\n  mounted() {\r\n    this.init()\r\n  },\r\n  methods: {\r\n    init() {\r\n      var viewer = new Viewer('cesiumContainer')\r\n      if (FeatureDetection.supportsImageRenderingPixelated()) {\r\n        //判断是否支持图像渲染像素化处理\r\n        viewer.resolutionScale = window.devicePixelRatio\r\n      }\r\n      viewer.scene.postProcessStages.fxaa.enabled = true\r\n      const scene = viewer.scene\r\n\r\n      const fragmentShaderSource = `\r\n        uniform float offset2;\r\n        uniform float offset1;\r\n        uniform vec4 color;\r\n        const float pi = 3.1415926;\r\n        czm_material czm_getMaterial(czm_materialInput materialInput)\r\n        {\r\n          czm_material material = czm_getDefaultMaterial(materialInput);\r\n          vec2 st = materialInput.st;\r\n\r\n          material.diffuse = czm_gammaCorrect(color.rgb); \r\n          // material.diffuse = vec3(st.t,st.t,st.t);\r\n          float a = abs(cos(st.t * pi * 3.0));\r\n          if(a<=0.2){\r\n            material.diffuse = vec3(189.0/255.0,196.0/255.0,210.0/255.0);\r\n          }\r\n          if(st.t> offset1-offset2 && st.t< offset1+offset2)\r\n          {\r\n            material.emission=vec3(0.7);\r\n          }\r\n          material.alpha = 1.0; \r\n          return material;\r\n        }\r\n        `\r\n\r\n      GeoJsonDataSource.load(building).then((dataSource) => {\r\n        const entities = dataSource.entities.values\r\n        const geometryInstances = []\r\n        for (const entity of entities) {\r\n          const polygon = new PolygonGeometry({\r\n            polygonHierarchy: entity.polygon.hierarchy.getValue(),\r\n            extrudedHeight: Math.random() * 40 + 10,\r\n          })\r\n          const geometry = PolygonGeometry.createGeometry(polygon)\r\n          const geometryInstance = new GeometryInstance({\r\n            geometry: geometry,\r\n          })\r\n          geometryInstances.push(geometryInstance)\r\n        }\r\n        const primitive = scene.primitives.add(\r\n          new Primitive({\r\n            asynchronous: false,\r\n            geometryInstances: geometryInstances,\r\n            appearance: new MaterialAppearance({\r\n              material: new Material({\r\n                translucent: false,\r\n                fabric: {\r\n                  uniforms: {\r\n                    color: new Color(87 / 255, 122 / 255, 150 / 255),\r\n                    offset1: 0.02,\r\n                    offset2: 0.02,\r\n                  },\r\n                  source: fragmentShaderSource\r\n                },\r\n              }),\r\n            }),\r\n          })\r\n        )\r\n\r\n        // 动态修改材质中的offset变量，从而实现动态效果。\r\n        viewer.scene.preUpdate.addEventListener(function () {\r\n          var offset = primitive.appearance.material.uniforms.offset1\r\n          offset += 0.01\r\n          if (offset > 0.98) {\r\n            offset = 0.02\r\n          }\r\n          primitive.appearance.material.uniforms.offset1 = offset\r\n        })\r\n        const center = Cartesian3.fromDegrees(104.06, 30.66);\r\n        viewer.camera.lookAt(center, new Cartesian3(0.0, -4790.0, 3930.0));\r\n        viewer.camera.lookAtTransform(Matrix4.IDENTITY);\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n#cesiumContainer {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n</style>\r\n","import {\r\n  ArcType, BoundingRectangle, BoundingSphere, Cartesian2, Cartesian3, Cartographic,\r\n  Check, ComponentDatatype, defaultValue, defined, DeveloperError, Ellipsoid,\r\n  EllipsoidGeodesic, EllipsoidTangentPlane, Geometry, GeometryAttribute, GeometryInstance,\r\n  GeometryOffsetAttribute, GeometryPipeline, IndexDatatype, Math as CesiumMath, Matrix3, PolygonGeometryLibrary,\r\n  PolygonPipeline, Quaternion, Rectangle, VertexFormat, WindingOrder,\r\n} from 'cesium'\r\n\r\n\r\nconst scratchCarto1 = new Cartographic();\r\nconst scratchCarto2 = new Cartographic();\r\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\r\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\r\n  const height = carto1.height;\r\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\r\n  p1Carto.height = height;\r\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\r\n\r\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\r\n  p2Carto.height = height - 100;\r\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\r\n}\r\n\r\nconst scratchBoundingRectangle = new BoundingRectangle();\r\nconst scratchPosition = new Cartesian3();\r\nconst scratchNormal = new Cartesian3();\r\nconst scratchTangent = new Cartesian3();\r\nconst scratchBitangent = new Cartesian3();\r\nconst p1Scratch = new Cartesian3();\r\nconst p2Scratch = new Cartesian3();\r\nlet scratchPerPosNormal = new Cartesian3();\r\nlet scratchPerPosTangent = new Cartesian3();\r\nlet scratchPerPosBitangent = new Cartesian3();\r\n\r\nconst appendTextureCoordinatesOrigin = new Cartesian2();\r\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\r\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\r\nconst appendTextureCoordinatesQuaternion = new Quaternion();\r\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\r\nconst tangentMatrixScratch = new Matrix3();\r\n\r\nfunction computeAttributes(options) {\r\n  const vertexFormat = options.vertexFormat;\r\n  const geometry = options.geometry;\r\n  const shadowVolume = options.shadowVolume;\r\n  const flatPositions = geometry.attributes.position.values;\r\n  const flatTexcoords = defined(geometry.attributes.st)\r\n    ? geometry.attributes.st.values\r\n    : undefined;\r\n\r\n  let length = flatPositions.length;\r\n  const wall = options.wall;\r\n  const top = options.top || wall;\r\n  const bottom = options.bottom || wall;\r\n  if (\r\n    vertexFormat.st ||\r\n    vertexFormat.normal ||\r\n    vertexFormat.tangent ||\r\n    vertexFormat.bitangent ||\r\n    shadowVolume\r\n  ) {\r\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\r\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\r\n    const boundingRectangle = options.boundingRectangle;\r\n    const tangentPlane = options.tangentPlane;\r\n    const ellipsoid = options.ellipsoid;\r\n    const stRotation = options.stRotation;\r\n    const perPositionHeight = options.perPositionHeight;\r\n\r\n    const origin = appendTextureCoordinatesOrigin;\r\n    origin.x = boundingRectangle.x;\r\n    origin.y = boundingRectangle.y;\r\n\r\n    const textureCoordinates = vertexFormat.st\r\n      ? new Float32Array(2 * (length / 3))\r\n      : undefined;\r\n    let normals;\r\n    if (vertexFormat.normal) {\r\n      if (perPositionHeight && top && !wall) {\r\n        normals = geometry.attributes.normal.values;\r\n      } else {\r\n        normals = new Float32Array(length);\r\n      }\r\n    }\r\n    const tangents = vertexFormat.tangent\r\n      ? new Float32Array(length)\r\n      : undefined;\r\n    const bitangents = vertexFormat.bitangent\r\n      ? new Float32Array(length)\r\n      : undefined;\r\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\r\n\r\n    let textureCoordIndex = 0;\r\n    let attrIndex = 0;\r\n\r\n    let normal = scratchNormal;\r\n    let tangent = scratchTangent;\r\n    let bitangent = scratchBitangent;\r\n    let recomputeNormal = true;\r\n\r\n    let textureMatrix = appendTextureCoordinatesMatrix3;\r\n    let tangentRotationMatrix = tangentMatrixScratch;\r\n    if (stRotation !== 0.0) {\r\n      let rotation = Quaternion.fromAxisAngle(\r\n        tangentPlane._plane.normal,\r\n        stRotation,\r\n        appendTextureCoordinatesQuaternion\r\n      );\r\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\r\n\r\n      rotation = Quaternion.fromAxisAngle(\r\n        tangentPlane._plane.normal,\r\n        -stRotation,\r\n        appendTextureCoordinatesQuaternion\r\n      );\r\n      tangentRotationMatrix = Matrix3.fromQuaternion(\r\n        rotation,\r\n        tangentRotationMatrix\r\n      );\r\n    } else {\r\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\r\n      tangentRotationMatrix = Matrix3.clone(\r\n        Matrix3.IDENTITY,\r\n        tangentRotationMatrix\r\n      );\r\n    }\r\n\r\n    let bottomOffset = 0;\r\n    let bottomOffset2 = 0;\r\n\r\n    if (top && bottom) {\r\n      bottomOffset = length / 2;\r\n      bottomOffset2 = length / 3;\r\n\r\n      length /= 2;\r\n    }\r\n\r\n    for (let i = 0; i < length; i += 3) {\r\n      const position = Cartesian3.fromArray(\r\n        flatPositions,\r\n        i,\r\n        appendTextureCoordinatesCartesian3\r\n      );\r\n\r\n      if (vertexFormat.st) {\r\n        if (!defined(flatTexcoords)) {\r\n          let p = Matrix3.multiplyByVector(\r\n            textureMatrix,\r\n            position,\r\n            scratchPosition\r\n          );\r\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\r\n          const st = tangentPlane.projectPointOntoPlane(\r\n            p,\r\n            appendTextureCoordinatesCartesian2\r\n          );\r\n          Cartesian2.subtract(st, origin, st);\r\n          // 修改纹理坐标值 开始\r\n          // const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\r\n          // const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\r\n          if (bottom) {\r\n            textureCoordinates[textureCoordIndex + bottomOffset2] = 0;\r\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = 0;\r\n          }\r\n          if (top) {\r\n            textureCoordinates[textureCoordIndex] = 0;\r\n            textureCoordinates[textureCoordIndex + 1] = 1;\r\n          }\r\n          // 修改纹理坐标值 结束\r\n\r\n          textureCoordIndex += 2;\r\n        }\r\n      }\r\n\r\n      if (\r\n        vertexFormat.normal ||\r\n        vertexFormat.tangent ||\r\n        vertexFormat.bitangent ||\r\n        shadowVolume\r\n      ) {\r\n        const attrIndex1 = attrIndex + 1;\r\n        const attrIndex2 = attrIndex + 2;\r\n\r\n        if (wall) {\r\n          if (i + 3 < length) {\r\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\r\n\r\n            if (recomputeNormal) {\r\n              const p2 = Cartesian3.fromArray(\r\n                flatPositions,\r\n                i + length,\r\n                p2Scratch\r\n              );\r\n              if (perPositionHeight) {\r\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\r\n              }\r\n              Cartesian3.subtract(p1, position, p1);\r\n              Cartesian3.subtract(p2, position, p2);\r\n              normal = Cartesian3.normalize(\r\n                Cartesian3.cross(p2, p1, normal),\r\n                normal\r\n              );\r\n              recomputeNormal = false;\r\n            }\r\n\r\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\r\n              // if we've reached a corner\r\n              recomputeNormal = true;\r\n            }\r\n          }\r\n\r\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\r\n            if (vertexFormat.tangent) {\r\n              tangent = Cartesian3.normalize(\r\n                Cartesian3.cross(bitangent, normal, tangent),\r\n                tangent\r\n              );\r\n            }\r\n          }\r\n        } else {\r\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            if (perPositionHeight) {\r\n              scratchPerPosNormal = Cartesian3.fromArray(\r\n                normals,\r\n                attrIndex,\r\n                scratchPerPosNormal\r\n              );\r\n              scratchPerPosTangent = Cartesian3.cross(\r\n                Cartesian3.UNIT_Z,\r\n                scratchPerPosNormal,\r\n                scratchPerPosTangent\r\n              );\r\n              scratchPerPosTangent = Cartesian3.normalize(\r\n                Matrix3.multiplyByVector(\r\n                  tangentRotationMatrix,\r\n                  scratchPerPosTangent,\r\n                  scratchPerPosTangent\r\n                ),\r\n                scratchPerPosTangent\r\n              );\r\n              if (vertexFormat.bitangent) {\r\n                scratchPerPosBitangent = Cartesian3.normalize(\r\n                  Cartesian3.cross(\r\n                    scratchPerPosNormal,\r\n                    scratchPerPosTangent,\r\n                    scratchPerPosBitangent\r\n                  ),\r\n                  scratchPerPosBitangent\r\n                );\r\n              }\r\n            }\r\n\r\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\r\n            tangent = Cartesian3.normalize(\r\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\r\n              tangent\r\n            );\r\n            if (vertexFormat.bitangent) {\r\n              bitangent = Cartesian3.normalize(\r\n                Cartesian3.cross(normal, tangent, bitangent),\r\n                bitangent\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n          if (options.wall) {\r\n            normals[attrIndex + bottomOffset] = normal.x;\r\n            normals[attrIndex1 + bottomOffset] = normal.y;\r\n            normals[attrIndex2 + bottomOffset] = normal.z;\r\n          } else if (bottom) {\r\n            normals[attrIndex + bottomOffset] = -normal.x;\r\n            normals[attrIndex1 + bottomOffset] = -normal.y;\r\n            normals[attrIndex2 + bottomOffset] = -normal.z;\r\n          }\r\n\r\n          if ((top && !perPositionHeight) || wall) {\r\n            normals[attrIndex] = normal.x;\r\n            normals[attrIndex1] = normal.y;\r\n            normals[attrIndex2] = normal.z;\r\n          }\r\n        }\r\n\r\n        if (shadowVolume) {\r\n          if (wall) {\r\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n          }\r\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\r\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\r\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n          if (options.wall) {\r\n            tangents[attrIndex + bottomOffset] = tangent.x;\r\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\r\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\r\n          } else if (bottom) {\r\n            tangents[attrIndex + bottomOffset] = -tangent.x;\r\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\r\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\r\n          }\r\n\r\n          if (top) {\r\n            if (perPositionHeight) {\r\n              tangents[attrIndex] = scratchPerPosTangent.x;\r\n              tangents[attrIndex1] = scratchPerPosTangent.y;\r\n              tangents[attrIndex2] = scratchPerPosTangent.z;\r\n            } else {\r\n              tangents[attrIndex] = tangent.x;\r\n              tangents[attrIndex1] = tangent.y;\r\n              tangents[attrIndex2] = tangent.z;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n          if (bottom) {\r\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\r\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\r\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\r\n          }\r\n          if (top) {\r\n            if (perPositionHeight) {\r\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\r\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\r\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\r\n            } else {\r\n              bitangents[attrIndex] = bitangent.x;\r\n              bitangents[attrIndex1] = bitangent.y;\r\n              bitangents[attrIndex2] = bitangent.z;\r\n            }\r\n          }\r\n        }\r\n        attrIndex += 3;\r\n      }\r\n    }\r\n\r\n    if (vertexFormat.st && !defined(flatTexcoords)) {\r\n      geometry.attributes.st = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 2,\r\n        values: textureCoordinates,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.normal) {\r\n      geometry.attributes.normal = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: normals,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.tangent) {\r\n      geometry.attributes.tangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: tangents,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.bitangent) {\r\n      geometry.attributes.bitangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: bitangents,\r\n      });\r\n    }\r\n\r\n    if (shadowVolume) {\r\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: extrudeNormals,\r\n      });\r\n    }\r\n  }\r\n\r\n  if (options.extrude && defined(options.offsetAttribute)) {\r\n    const size = flatPositions.length / 3;\r\n    let offsetAttribute = new Uint8Array(size);\r\n\r\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n      if ((top && bottom) || wall) {\r\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\r\n      } else if (top) {\r\n        offsetAttribute = offsetAttribute.fill(1);\r\n      }\r\n    } else {\r\n      const offsetValue =\r\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n      offsetAttribute = offsetAttribute.fill(offsetValue);\r\n    }\r\n\r\n    geometry.attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: offsetAttribute,\r\n    });\r\n  }\r\n\r\n  return geometry;\r\n}\r\n\r\nconst startCartographicScratch = new Cartographic();\r\nconst endCartographicScratch = new Cartographic();\r\nconst idlCross = {\r\n  westOverIDL: 0.0,\r\n  eastOverIDL: 0.0,\r\n};\r\nlet ellipsoidGeodesic = new EllipsoidGeodesic();\r\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\r\n  result = defaultValue(result, new Rectangle());\r\n  if (!defined(positions) || positions.length < 3) {\r\n    result.west = 0.0;\r\n    result.north = 0.0;\r\n    result.south = 0.0;\r\n    result.east = 0.0;\r\n    return result;\r\n  }\r\n\r\n  if (arcType === ArcType.RHUMB) {\r\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\r\n  }\r\n\r\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\r\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\r\n  }\r\n\r\n  result.west = Number.POSITIVE_INFINITY;\r\n  result.east = Number.NEGATIVE_INFINITY;\r\n  result.south = Number.POSITIVE_INFINITY;\r\n  result.north = Number.NEGATIVE_INFINITY;\r\n\r\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\r\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\r\n\r\n  const inverseChordLength =\r\n    1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n  const positionsLength = positions.length;\r\n  let endCartographic = ellipsoid.cartesianToCartographic(\r\n    positions[0],\r\n    endCartographicScratch\r\n  );\r\n  let startCartographic = startCartographicScratch;\r\n  let swap;\r\n\r\n  for (let i = 1; i < positionsLength; i++) {\r\n    swap = startCartographic;\r\n    startCartographic = endCartographic;\r\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\r\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n    interpolateAndGrowRectangle(\r\n      ellipsoidGeodesic,\r\n      inverseChordLength,\r\n      result,\r\n      idlCross\r\n    );\r\n  }\r\n\r\n  swap = startCartographic;\r\n  startCartographic = endCartographic;\r\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\r\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n  interpolateAndGrowRectangle(\r\n    ellipsoidGeodesic,\r\n    inverseChordLength,\r\n    result,\r\n    idlCross\r\n  );\r\n\r\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\r\n    result.west = idlCross.westOverIDL;\r\n    result.east = idlCross.eastOverIDL;\r\n\r\n    if (result.east > CesiumMath.PI) {\r\n      result.east = result.east - CesiumMath.TWO_PI;\r\n    }\r\n    if (result.west > CesiumMath.PI) {\r\n      result.west = result.west - CesiumMath.TWO_PI;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst interpolatedCartographicScratch = new Cartographic();\r\nfunction interpolateAndGrowRectangle(\r\n  ellipsoidGeodesic,\r\n  inverseChordLength,\r\n  result,\r\n  idlCross\r\n) {\r\n  const segmentLength = ellipsoidGeodesic.surfaceDistance;\r\n\r\n  const numPoints = Math.ceil(segmentLength * inverseChordLength);\r\n  const subsegmentDistance =\r\n    numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\r\n  let interpolationDistance = 0.0;\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    const interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\r\n      interpolationDistance,\r\n      interpolatedCartographicScratch\r\n    );\r\n    interpolationDistance += subsegmentDistance;\r\n    const longitude = interpolatedCartographic.longitude;\r\n    const latitude = interpolatedCartographic.latitude;\r\n\r\n    result.west = Math.min(result.west, longitude);\r\n    result.east = Math.max(result.east, longitude);\r\n    result.south = Math.min(result.south, latitude);\r\n    result.north = Math.max(result.north, latitude);\r\n\r\n    const lonAdjusted =\r\n      longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\r\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\r\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\r\n  }\r\n}\r\n\r\nconst createGeometryFromPositionsExtrudedPositions = [];\r\n\r\nfunction createGeometryFromPositionsExtruded(\r\n  ellipsoid,\r\n  polygon,\r\n  textureCoordinates,\r\n  granularity,\r\n  hierarchy,\r\n  perPositionHeight,\r\n  closeTop,\r\n  closeBottom,\r\n  vertexFormat,\r\n  arcType\r\n) {\r\n  const geos = {\r\n    walls: [],\r\n  };\r\n  let i;\r\n\r\n  if (closeTop || closeBottom) {\r\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\r\n      ellipsoid,\r\n      polygon,\r\n      textureCoordinates,\r\n      granularity,\r\n      perPositionHeight,\r\n      vertexFormat,\r\n      arcType\r\n    );\r\n\r\n    const edgePoints = topGeo.attributes.position.values;\r\n    const indices = topGeo.indices;\r\n    let numPositions;\r\n    let newIndices;\r\n\r\n    if (closeTop && closeBottom) {\r\n      const topBottomPositions = edgePoints.concat(edgePoints);\r\n\r\n      numPositions = topBottomPositions.length / 3;\r\n\r\n      newIndices = IndexDatatype.createTypedArray(\r\n        numPositions,\r\n        indices.length * 2\r\n      );\r\n      newIndices.set(indices);\r\n      const ilength = indices.length;\r\n\r\n      const length = numPositions / 2;\r\n\r\n      for (i = 0; i < ilength; i += 3) {\r\n        const i0 = newIndices[i] + length;\r\n        const i1 = newIndices[i + 1] + length;\r\n        const i2 = newIndices[i + 2] + length;\r\n\r\n        newIndices[i + ilength] = i2;\r\n        newIndices[i + 1 + ilength] = i1;\r\n        newIndices[i + 2 + ilength] = i0;\r\n      }\r\n\r\n      topGeo.attributes.position.values = topBottomPositions;\r\n      if (perPositionHeight && vertexFormat.normal) {\r\n        const normals = topGeo.attributes.normal.values;\r\n        topGeo.attributes.normal.values = new Float32Array(\r\n          topBottomPositions.length\r\n        );\r\n        topGeo.attributes.normal.values.set(normals);\r\n      }\r\n\r\n      if (vertexFormat.st && defined(textureCoordinates)) {\r\n        const texcoords = topGeo.attributes.st.values;\r\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\r\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\r\n      }\r\n\r\n      topGeo.indices = newIndices;\r\n    } else if (closeBottom) {\r\n      numPositions = edgePoints.length / 3;\r\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\r\n\r\n      for (i = 0; i < indices.length; i += 3) {\r\n        newIndices[i] = indices[i + 2];\r\n        newIndices[i + 1] = indices[i + 1];\r\n        newIndices[i + 2] = indices[i];\r\n      }\r\n\r\n      topGeo.indices = newIndices;\r\n    }\r\n\r\n    geos.topAndBottom = new GeometryInstance({\r\n      geometry: topGeo,\r\n    });\r\n  }\r\n\r\n  let outerRing = hierarchy.outerRing;\r\n  let tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\r\n  let positions2D = tangentPlane.projectPointsOntoPlane(\r\n    outerRing,\r\n    createGeometryFromPositionsExtrudedPositions\r\n  );\r\n\r\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n  if (windingOrder === WindingOrder.CLOCKWISE) {\r\n    outerRing = outerRing.slice().reverse();\r\n  }\r\n\r\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(\r\n    outerRing,\r\n    textureCoordinates,\r\n    ellipsoid,\r\n    granularity,\r\n    perPositionHeight,\r\n    arcType\r\n  );\r\n  geos.walls.push(\r\n    new GeometryInstance({\r\n      geometry: wallGeo,\r\n    })\r\n  );\r\n\r\n  const holes = hierarchy.holes;\r\n  for (i = 0; i < holes.length; i++) {\r\n    let hole = holes[i];\r\n\r\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\r\n    positions2D = tangentPlane.projectPointsOntoPlane(\r\n      hole,\r\n      createGeometryFromPositionsExtrudedPositions\r\n    );\r\n\r\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\r\n      hole = hole.slice().reverse();\r\n    }\r\n\r\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\r\n      hole,\r\n      textureCoordinates,\r\n      ellipsoid,\r\n      granularity,\r\n      perPositionHeight,\r\n      arcType\r\n    );\r\n    geos.walls.push(\r\n      new GeometryInstance({\r\n        geometry: wallGeo,\r\n      })\r\n    );\r\n  }\r\n\r\n  return geos;\r\n}\r\n\r\n/**\r\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @alias PolygonGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\r\n *\r\n * @see PolygonGeometry#createGeometry\r\n * @see PolygonGeometry#fromPositions\r\n *\r\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\r\n *\r\n * @example\r\n * // 1. create a polygon from points\r\n * const polygon = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n *\r\n * // 2. create a nested polygon with holes\r\n * const polygonWithHole = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -109.0, 30.0,\r\n *       -95.0, 30.0,\r\n *       -95.0, 40.0,\r\n *       -109.0, 40.0\r\n *     ]),\r\n *     [new Cesium.PolygonHierarchy(\r\n *       Cesium.Cartesian3.fromDegreesArray([\r\n *         -107.0, 31.0,\r\n *         -107.0, 39.0,\r\n *         -97.0, 39.0,\r\n *         -97.0, 31.0\r\n *       ]),\r\n *       [new Cesium.PolygonHierarchy(\r\n *         Cesium.Cartesian3.fromDegreesArray([\r\n *           -105.0, 33.0,\r\n *           -99.0, 33.0,\r\n *           -99.0, 37.0,\r\n *           -105.0, 37.0\r\n *         ]),\r\n *         [new Cesium.PolygonHierarchy(\r\n *           Cesium.Cartesian3.fromDegreesArray([\r\n *             -103.0, 34.0,\r\n *             -101.0, 34.0,\r\n *             -101.0, 36.0,\r\n *             -103.0, 36.0\r\n *           ])\r\n *         )]\r\n *       )]\r\n *     )]\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\r\n *\r\n * // 3. create extruded polygon\r\n * const extrudedPolygon = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   ),\r\n *   extrudedHeight: 300000\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\r\n */\r\nfunction PolygonGeometry(options) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n  if (\r\n    defined(options.perPositionHeight) &&\r\n    options.perPositionHeight &&\r\n    defined(options.height)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Cannot use both options.perPositionHeight and options.height\"\r\n    );\r\n  }\r\n  if (\r\n    defined(options.arcType) &&\r\n    options.arcType !== ArcType.GEODESIC &&\r\n    options.arcType !== ArcType.RHUMB\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const stRotation = defaultValue(options.stRotation, 0.0);\r\n  const textureCoordinates = options.textureCoordinates;\r\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\r\n  const perPositionHeightExtrude =\r\n    perPositionHeight && defined(options.extrudedHeight);\r\n  let height = defaultValue(options.height, 0.0);\r\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  if (!perPositionHeightExtrude) {\r\n    const h = Math.max(height, extrudedHeight);\r\n    extrudedHeight = Math.min(height, extrudedHeight);\r\n    height = h;\r\n  }\r\n\r\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n  this._granularity = granularity;\r\n  this._stRotation = stRotation;\r\n  this._height = height;\r\n  this._extrudedHeight = extrudedHeight;\r\n  this._closeTop = defaultValue(options.closeTop, true);\r\n  this._closeBottom = defaultValue(options.closeBottom, true);\r\n  this._polygonHierarchy = polygonHierarchy;\r\n  this._perPositionHeight = perPositionHeight;\r\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n  this._workerName = \"createPolygonGeometry\";\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n  this._rectangle = undefined;\r\n  this._textureCoordinateRotationPoints = undefined;\r\n  this._textureCoordinates = textureCoordinates;\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n      polygonHierarchy,\r\n      Cartesian3\r\n    ) +\r\n    Ellipsoid.packedLength +\r\n    VertexFormat.packedLength +\r\n    (textureCoordinates\r\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n        textureCoordinates,\r\n        Cartesian2\r\n      )\r\n      : 1) +\r\n    12;\r\n}\r\n\r\n/**\r\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\r\n * @param {Number} [options.height=0.0] The height of the polygon.\r\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\r\n * @returns {PolygonGeometry}\r\n *\r\n * @example\r\n * // create a polygon from points\r\n * const polygon = Cesium.PolygonGeometry.fromPositions({\r\n *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n *     -72.0, 40.0,\r\n *     -70.0, 35.0,\r\n *     -75.0, 30.0,\r\n *     -70.0, 30.0,\r\n *     -68.0, 40.0\r\n *   ])\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n *\r\n * @see PolygonGeometry#createGeometry\r\n */\r\nPolygonGeometry.fromPositions = function (options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"options.positions\", options.positions);\r\n  //>>includeEnd('debug');\r\n\r\n  const newOptions = {\r\n    polygonHierarchy: {\r\n      positions: options.positions,\r\n    },\r\n    height: options.height,\r\n    extrudedHeight: options.extrudedHeight,\r\n    vertexFormat: options.vertexFormat,\r\n    stRotation: options.stRotation,\r\n    ellipsoid: options.ellipsoid,\r\n    granularity: options.granularity,\r\n    perPositionHeight: options.perPositionHeight,\r\n    closeTop: options.closeTop,\r\n    closeBottom: options.closeBottom,\r\n    offsetAttribute: options.offsetAttribute,\r\n    arcType: options.arcType,\r\n    textureCoordinates: options.textureCoordinates,\r\n  };\r\n  return new PolygonGeometry(newOptions);\r\n};\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nPolygonGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n    value._polygonHierarchy,\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._height;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._stRotation;\r\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\r\n  array[startingIndex++] = value._arcType;\r\n  if (defined(value._textureCoordinates)) {\r\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n      value._textureCoordinates,\r\n      array,\r\n      startingIndex,\r\n      Cartesian2\r\n    );\r\n  } else {\r\n    array[startingIndex++] = -1.0;\r\n  }\r\n  array[startingIndex++] = value.packedLength;\r\n  return array;\r\n};\r\n\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst scratchVertexFormat = new VertexFormat();\r\n\r\n//Only used to avoid inability to default construct.\r\nconst dummyOptions = {\r\n  polygonHierarchy: {},\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonGeometry} [result] The object into which to store the result.\r\n */\r\nPolygonGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n  startingIndex = polygonHierarchy.startingIndex;\r\n  delete polygonHierarchy.startingIndex;\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  const height = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const granularity = array[startingIndex++];\r\n  const stRotation = array[startingIndex++];\r\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\r\n  const perPositionHeight = array[startingIndex++] === 1.0;\r\n  const closeTop = array[startingIndex++] === 1.0;\r\n  const closeBottom = array[startingIndex++] === 1.0;\r\n  const shadowVolume = array[startingIndex++] === 1.0;\r\n  const offsetAttribute = array[startingIndex++];\r\n  const arcType = array[startingIndex++];\r\n  const textureCoordinates =\r\n    array[startingIndex] === -1.0\r\n      ? undefined\r\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n        array,\r\n        startingIndex,\r\n        Cartesian2\r\n      );\r\n  if (defined(textureCoordinates)) {\r\n    startingIndex = textureCoordinates.startingIndex;\r\n    delete textureCoordinates.startingIndex;\r\n  } else {\r\n    startingIndex++;\r\n  }\r\n  const packedLength = array[startingIndex++];\r\n\r\n  if (!defined(result)) {\r\n    result = new PolygonGeometry(dummyOptions);\r\n  }\r\n\r\n  result._polygonHierarchy = polygonHierarchy;\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._height = height;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._granularity = granularity;\r\n  result._stRotation = stRotation;\r\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  result._perPositionHeight = perPositionHeight;\r\n  result._closeTop = closeTop;\r\n  result._closeBottom = closeBottom;\r\n  result._shadowVolume = shadowVolume;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n  result._arcType = arcType;\r\n  result._textureCoordinates = textureCoordinates;\r\n  result.packedLength = packedLength;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns the bounding rectangle given the provided options\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Rectangle} [result] An object in which to store the result.\r\n *\r\n * @returns {Rectangle} The result rectangle\r\n */\r\nPolygonGeometry.computeRectangle = function (options, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n  //>>includeEnd('debug');\r\n\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n  return computeRectangle(\r\n    polygonHierarchy.positions,\r\n    ellipsoid,\r\n    arcType,\r\n    granularity,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nPolygonGeometry.createGeometry = function (polygonGeometry) {\r\n  const vertexFormat = polygonGeometry._vertexFormat;\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const granularity = polygonGeometry._granularity;\r\n  const stRotation = polygonGeometry._stRotation;\r\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\r\n  const perPositionHeight = polygonGeometry._perPositionHeight;\r\n  const closeTop = polygonGeometry._closeTop;\r\n  const closeBottom = polygonGeometry._closeBottom;\r\n  const arcType = polygonGeometry._arcType;\r\n  const textureCoordinates = polygonGeometry._textureCoordinates;\r\n\r\n  const hasTextureCoordinates = defined(textureCoordinates);\r\n\r\n  let outerPositions = polygonHierarchy.positions;\r\n  if (outerPositions.length < 3) {\r\n    return;\r\n  }\r\n\r\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(\r\n    outerPositions,\r\n    ellipsoid\r\n  );\r\n\r\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\r\n    polygonHierarchy,\r\n    hasTextureCoordinates,\r\n    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\r\n    !perPositionHeight,\r\n    ellipsoid\r\n  );\r\n\r\n  const hierarchy = results.hierarchy;\r\n  const polygons = results.polygons;\r\n\r\n  const dummyFunction = function (identity) {\r\n    return identity;\r\n  };\r\n\r\n  const textureCoordinatePolygons = hasTextureCoordinates\r\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\r\n      textureCoordinates,\r\n      true,\r\n      dummyFunction,\r\n      false\r\n    ).polygons\r\n    : undefined;\r\n\r\n  if (hierarchy.length === 0) {\r\n    return;\r\n  }\r\n\r\n  outerPositions = hierarchy[0].outerRing;\r\n  const boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\r\n    tangentPlane.plane.normal,\r\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\r\n    outerPositions,\r\n    stRotation,\r\n    scratchBoundingRectangle\r\n  );\r\n\r\n  const geometries = [];\r\n\r\n  const height = polygonGeometry._height;\r\n  const extrudedHeight = polygonGeometry._extrudedHeight;\r\n  const extrude =\r\n    polygonGeometry._perPositionHeightExtrude ||\r\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n  const options = {\r\n    perPositionHeight: perPositionHeight,\r\n    vertexFormat: vertexFormat,\r\n    geometry: undefined,\r\n    tangentPlane: tangentPlane,\r\n    boundingRectangle: boundingRectangle,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: stRotation,\r\n    textureCoordinates: undefined,\r\n    bottom: false,\r\n    top: true,\r\n    wall: false,\r\n    extrude: false,\r\n    arcType: arcType,\r\n  };\r\n\r\n  let i;\r\n\r\n  if (extrude) {\r\n    options.extrude = true;\r\n    options.top = closeTop;\r\n    options.bottom = closeBottom;\r\n    options.shadowVolume = polygonGeometry._shadowVolume;\r\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\r\n    for (i = 0; i < polygons.length; i++) {\r\n      const splitGeometry = createGeometryFromPositionsExtruded(\r\n        ellipsoid,\r\n        polygons[i],\r\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\r\n        granularity,\r\n        hierarchy[i],\r\n        perPositionHeight,\r\n        closeTop,\r\n        closeBottom,\r\n        vertexFormat,\r\n        arcType\r\n      );\r\n\r\n      let topAndBottom;\r\n      if (closeTop && closeBottom) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n          topAndBottom.geometry,\r\n          height,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          perPositionHeight\r\n        );\r\n      } else if (closeTop) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n          topAndBottom.geometry.attributes.position.values,\r\n          height,\r\n          ellipsoid,\r\n          !perPositionHeight\r\n        );\r\n        options.geometry = topAndBottom.geometry;\r\n      } else if (closeBottom) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n          topAndBottom.geometry.attributes.position.values,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          true\r\n        );\r\n        options.geometry = topAndBottom.geometry;\r\n      }\r\n      if (closeTop || closeBottom) {\r\n        options.wall = false;\r\n        topAndBottom.geometry = computeAttributes(options);\r\n        geometries.push(topAndBottom);\r\n      }\r\n\r\n      const walls = splitGeometry.walls;\r\n      options.wall = true;\r\n      for (let k = 0; k < walls.length; k++) {\r\n        const wall = walls[k];\r\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n          wall.geometry,\r\n          height,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          perPositionHeight\r\n        );\r\n        wall.geometry = computeAttributes(options);\r\n        geometries.push(wall);\r\n      }\r\n    }\r\n  } else {\r\n    for (i = 0; i < polygons.length; i++) {\r\n      const geometryInstance = new GeometryInstance({\r\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\r\n          ellipsoid,\r\n          polygons[i],\r\n          hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\r\n          granularity,\r\n          perPositionHeight,\r\n          vertexFormat,\r\n          arcType\r\n        ),\r\n      });\r\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n        geometryInstance.geometry.attributes.position.values,\r\n        height,\r\n        ellipsoid,\r\n        !perPositionHeight\r\n      );\r\n      options.geometry = geometryInstance.geometry;\r\n\r\n      geometryInstance.geometry = computeAttributes(options);\r\n\r\n      if (defined(polygonGeometry._offsetAttribute)) {\r\n        const length =\r\n          geometryInstance.geometry.attributes.position.values.length;\r\n        const offsetValue =\r\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n            ? 0\r\n            : 1;\r\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\r\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\r\n          {\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: applyOffset,\r\n          }\r\n        );\r\n      }\r\n\r\n      geometries.push(geometryInstance);\r\n    }\r\n  }\r\n\r\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\r\n  geometry.attributes.position.values = new Float64Array(\r\n    geometry.attributes.position.values\r\n  );\r\n  geometry.indices = IndexDatatype.createTypedArray(\r\n    geometry.attributes.position.values.length / 3,\r\n    geometry.indices\r\n  );\r\n\r\n  const attributes = geometry.attributes;\r\n  const boundingSphere = BoundingSphere.fromVertices(\r\n    attributes.position.values\r\n  );\r\n\r\n  if (!vertexFormat.position) {\r\n    delete attributes.position;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: geometry.primitiveType,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: polygonGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPolygonGeometry.createShadowVolume = function (\r\n  polygonGeometry,\r\n  minHeightFunc,\r\n  maxHeightFunc\r\n) {\r\n  const granularity = polygonGeometry._granularity;\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n\r\n  const minHeight = minHeightFunc(granularity, ellipsoid);\r\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n  return new PolygonGeometry({\r\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: polygonGeometry._stRotation,\r\n    granularity: granularity,\r\n    perPositionHeight: false,\r\n    extrudedHeight: minHeight,\r\n    height: maxHeight,\r\n    vertexFormat: VertexFormat.POSITION_ONLY,\r\n    shadowVolume: true,\r\n    arcType: polygonGeometry._arcType,\r\n  });\r\n};\r\n\r\nfunction textureCoordinateRotationPoints(polygonGeometry) {\r\n  const stRotation = -polygonGeometry._stRotation;\r\n  if (stRotation === 0.0) {\r\n    return [0, 0, 0, 1, 1, 0];\r\n  }\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const positions = polygonGeometry._polygonHierarchy.positions;\r\n  const boundingRectangle = polygonGeometry.rectangle;\r\n  return Geometry._textureCoordinateRotationPoints(\r\n    positions,\r\n    stRotation,\r\n    ellipsoid,\r\n    boundingRectangle\r\n  );\r\n}\r\n\r\nObject.defineProperties(PolygonGeometry.prototype, {\r\n  /**\r\n   * @private\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      if (!defined(this._rectangle)) {\r\n        const positions = this._polygonHierarchy.positions;\r\n        this._rectangle = computeRectangle(\r\n          positions,\r\n          this._ellipsoid,\r\n          this._arcType,\r\n          this._granularity\r\n        );\r\n      }\r\n\r\n      return this._rectangle;\r\n    },\r\n  },\r\n  /**\r\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\r\n   * @private\r\n   */\r\n  textureCoordinateRotationPoints: {\r\n    get: function () {\r\n      if (!defined(this._textureCoordinateRotationPoints)) {\r\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\r\n          this\r\n        );\r\n      }\r\n      return this._textureCoordinateRotationPoints;\r\n    },\r\n  },\r\n});\r\nexport default PolygonGeometry;\r\n","import { render } from \"./dynamic_building.vue?vue&type=template&id=07106fe7&scoped=true\"\nimport script from \"./dynamic_building.vue?vue&type=script&lang=js\"\nexport * from \"./dynamic_building.vue?vue&type=script&lang=js\"\n\nimport \"./dynamic_building.vue?vue&type=style&index=0&id=07106fe7&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-07106fe7\"]])\n\nexport default __exports__"],"names":["id","_createElementBlock","_hoisted_1","scratchCarto1","Cartographic","scratchCarto2","adjustPosHeightsForNormal","position","p1","p2","ellipsoid","carto1","cartesianToCartographic","height","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","BoundingRectangle","scratchPosition","Cartesian3","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","Cartesian2","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","Quaternion","appendTextureCoordinatesMatrix3","Matrix3","tangentMatrixScratch","computeAttributes","options","vertexFormat","geometry","shadowVolume","flatPositions","attributes","values","flatTexcoords","defined","st","undefined","length","wall","top","bottom","normal","tangent","bitangent","boundingRectangle","tangentPlane","stRotation","perPositionHeight","origin","x","y","textureCoordinates","Float32Array","normals","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","_plane","bottomOffset","bottomOffset2","i","p","scaleToGeodeticSurface","projectPointOntoPlane","attrIndex1","attrIndex2","CesiumMath","geodeticSurfaceNormal","z","GeometryAttribute","componentDatatype","ComponentDatatype","componentsPerAttribute","extrudeDirection","extrude","offsetAttribute","size","Uint8Array","GeometryOffsetAttribute","fill","offsetValue","applyOffset","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","EllipsoidGeodesic","computeRectangle","positions","arcType","granularity","result","defaultValue","Rectangle","west","north","south","east","ArcType","equals","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","inverseChordLength","maximumRadius","positionsLength","swap","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","interpolatedCartographicScratch","segmentLength","surfaceDistance","numPoints","Math","ceil","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","longitude","latitude","min","max","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","polygon","hierarchy","closeTop","closeBottom","geos","walls","topGeo","PolygonGeometryLibrary","edgePoints","indices","numPositions","newIndices","topBottomPositions","concat","IndexDatatype","set","ilength","i0","i1","i2","texcoords","topAndBottom","GeometryInstance","outerRing","EllipsoidTangentPlane","positions2D","projectPointsOntoPlane","windingOrder","PolygonPipeline","WindingOrder","slice","reverse","wallGeo","push","holes","hole","PolygonGeometry","Check","polygonHierarchy","DeveloperError","VertexFormat","Ellipsoid","perPositionHeightExtrude","extrudedHeight","h","this","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","_textureCoordinates","packedLength","fromPositions","newOptions","pack","value","array","startingIndex","scratchEllipsoid","scratchVertexFormat","dummyOptions","textureCoordinateRotationPoints","polygonGeometry","rectangle","Geometry","unpack","createGeometry","hasTextureCoordinates","outerPositions","results","bind","polygons","dummyFunction","identity","textureCoordinatePolygons","plane","geometries","splitGeometry","k","geometryInstance","GeometryPipeline","Float64Array","boundingSphere","BoundingSphere","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","Object","defineProperties","prototype","get","building","require","mounted","init","methods","viewer","Viewer","FeatureDetection","resolutionScale","window","devicePixelRatio","scene","postProcessStages","fxaa","enabled","fragmentShaderSource","GeoJsonDataSource","then","dataSource","entities","geometryInstances","entity","getValue","random","primitive","primitives","add","Primitive","asynchronous","appearance","MaterialAppearance","material","Material","translucent","fabric","uniforms","color","Color","offset1","offset2","source","preUpdate","addEventListener","offset","center","camera","lookAt","lookAtTransform","Matrix4","__exports__","render"],"sourceRoot":""}