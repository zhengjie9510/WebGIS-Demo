"use strict";(self["webpackChunkwebgis"]=self["webpackChunkwebgis"]||[]).push([[110],{110:function(e,t,n){n.r(t),n.d(t,{default:function(){return p}});var i=n(73396);const s=e=>((0,i.dD)("data-v-31eae830"),e=e(),(0,i.Cn)(),e),r={class:"container"},o=s((()=>(0,i._)("canvas",{id:"c"},null,-1))),a=[o];function h(e,t,n,s,o,h){return(0,i.wg)(),(0,i.iD)("div",r,a)}n(57658),n(63408),n(14590);var d=n(11114);class c{constructor(e,t){this.scene=e,this.options=t,this.init()}init(){const e=this.options,t=new d.BKK(e.width,e.length,20,200),n=new d.jyz({uniforms:Object.assign({uColor:new d.xWb(new d.Ilk(1052690)),uTime:new d.xWb(0),uTravelLength:new d.xWb(e.length)},e.distortion.uniforms),vertexShader:"\n                uniform float uTravelLength;\n                #include <getDistortion_vertex>\n                void main(){\n                    vec3 transformed = position.xyz;\n                        \n                    float progress = (transformed.y + uTravelLength / 2.) / uTravelLength;\n                    vec3 distortion  = getDistortion(progress);\n                    transformed.x += distortion.x;\n                    transformed.z += distortion.y;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.);\n                }\n                ",fragmentShader:"\n                uniform vec3 uColor;\n                void main(){\n                    gl_FragColor = vec4(uColor,1.);\n                }\n                ",side:d.ehD});n.onBeforeCompile=t=>{t.vertexShader=t.vertexShader.replace("#include <getDistortion_vertex>",e.distortion.getDistortion)};const i=new d.Kj0(t,n);i.rotation.x=-Math.PI/2,i.position.z=-e.length/2,this.scene.add(i),console.log(i)}}class l{constructor(e,t,n,i){this.scene=e,this.options=t,this.color=n,this.speed=i,this.init()}init(){const e=this.options,t=new d.U7(new d.Pa4(0,0,0),new d.Pa4(0,0,-1)),n=new d.Lcc(t,25,1,8,!1),i=(new d.L5s).copy(n);i.instanceCount=2*e.nPairs;let s=[],r=[],o=e.roadWidth/e.roadSections;for(let d=0;d<e.nPairs;d++){let t=.1*Math.random()+.1,n=Math.random()*e.length*.08+.02*e.length,i=d%3,a=i*o-e.roadWidth/2+o/2,h=.5*o,c=.5*Math.random(),l=1.3*t,u=Math.random()*e.length;s.push(a-h/2+c),s.push(l),s.push(-u),s.push(a+h/2+c),s.push(l),s.push(-u),r.push(t),r.push(n),r.push(t),r.push(n)}i.setAttribute("aOffset",new d.lb7(new Float32Array(s),3,!1)),i.setAttribute("aMetrics",new d.lb7(new Float32Array(r),2,!1));const a=new d.jyz({fragmentShader:"\n                uniform vec3 uColor;\n                void main() {\n                    vec3 color = vec3(uColor);\n                    gl_FragColor = vec4(uColor,1.);\n                }\n                ",vertexShader:"\n                attribute vec3 aOffset;\n                attribute vec2 aMetrics;\n                uniform float uTime;\n                uniform float uSpeed;\n                uniform float uTravelLength;\n                #include <getDistortion_vertex>\n                void main() {\n                    vec3 transformed = position.xyz;\n\n                    float radius = aMetrics.r;\n                    float len = aMetrics.g;\n                    transformed.xy *= radius; \n                    transformed.z *= len;\n\n                    float zOffset = uTime * uSpeed + aOffset.z;\n                    zOffset = len - mod(zOffset, uTravelLength);\n\n                    // transformed.z +=uTime * uSpeed;\n\n\n                    // Keep them separated to make the next step easier!\n                    transformed.z = transformed.z +zOffset ;\n                    transformed.xy += aOffset.xy;\n\n\n                    float progress = abs(transformed.z / uTravelLength);\n                    transformed.xyz += getDistortion(progress);\n\n\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n                    gl_Position = projectionMatrix * mvPosition;\n                }",uniforms:Object.assign({uColor:new d.xWb(new d.Ilk(this.color)),uTravelLength:new d.xWb(e.length),uTime:new d.xWb(0),uSpeed:new d.xWb(this.speed)},e.distortion.uniforms)});a.onBeforeCompile=t=>{t.vertexShader=t.vertexShader.replace("#include <getDistortion_vertex>",e.distortion.getDistortion)};let h=new d.Kj0(i,a);h.frustumCulled=!1,this.mesh=h,this.scene.add(h)}update(e){this.mesh.material.uniforms.uTime.value=e}}class u{constructor(e){this.canvas=e,this.clock=new d.SUY,this.renderer=new d.CP7({canvas:this.canvas,antialias:!0}),this.renderer.setSize(this.canvas.innerWidth,this.canvas.innerHeight),this.renderer.setPixelRatio(window.devicePixelRatio),this.scene=new d.xsS,this.camera=new d.cPb(45,this.canvas.clientWidth/this.canvas.clientHeight,.1,1e4),this.camera.position.z=-5,this.camera.position.y=7,this.camera.position.x=0;const t={uDistortionX:new d.xWb(new d.FM8(40,3)),uDistortionY:new d.xWb(new d.FM8(-40,2.5))},n="\n            #define PI 3.14159265358979\n            uniform vec2 uDistortionX;\n            uniform vec2 uDistortionY;\n\n            float nsin(float val){\n            return sin(val) * 0.5+0.5;\n            }\n            vec3 getDistortion(float progress){\n                progress = clamp(progress, 0.,1.);\n                float xAmp = uDistortionX.r;\n                float xFreq = uDistortionX.g;\n                float yAmp = uDistortionY.r;\n                float yFreq = uDistortionY.g;\n                return vec3( \n                    xAmp * nsin(progress* PI * xFreq   - PI / 2. ) ,\n                    yAmp * nsin(progress * PI *yFreq - PI / 2.  ) ,\n                    0.\n                );\n            }\n            ",i={uniforms:t,getDistortion:n},s={length:400,width:20,roadWidth:9,islandWidth:2,nPairs:50,roadSections:3,distortion:i};this.road=new c(this.scene,s),this.leftLights=new l(this.scene,s,16715818,60),this.leftLights.mesh.position.setX(-s.roadWidth/2-s.islandWidth/2),this.rightLights=new l(this.scene,s,16448250,-60),this.rightLights.mesh.position.setX(s.roadWidth/2+s.islandWidth/2)}update(e){let t=this.clock.elapsedTime;this.leftLights.update(t),this.rightLights.update(t)}resizeRendererToDisplaySize(e){const t=e.domElement,n=t.clientWidth,i=t.clientHeight,s=t.width!==n||t.height!==i;return s&&e.setSize(n,i,!1),s}render(){if(this.resizeRendererToDisplaySize(this.renderer)){const e=this.renderer.domElement;this.camera.aspect=e.clientWidth/e.clientHeight,this.camera.updateProjectionMatrix()}const e=this.clock.getDelta();this.update(e),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render.bind(this))}}var m={mounted(){this.init()},methods:{init(){const e=document.querySelector("#c"),t=new u(e);t.render()}}},f=n(40089);const g=(0,f.Z)(m,[["render",h],["__scopeId","data-v-31eae830"]]);var p=g}}]);
//# sourceMappingURL=110.b4eb7f81.js.map