{"version":3,"file":"js/488.d688e88e.js","mappings":"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","sources":["webpack://webgis/./src/components/cesium/3dTiles_shader.vue","webpack://webgis/./node_modules/cesium/Source/Scene/Model/UniformType.js","webpack://webgis/./node_modules/cesium/Source/Core/getImageFromTypedArray.js","webpack://webgis/./node_modules/cesium/Source/Scene/Model/TextureManager.js","webpack://webgis/./node_modules/cesium/Source/Scene/Model/CustomShader.js","webpack://webgis/./src/components/cesium/3dTiles_shader.vue?ec14"],"sourcesContent":["<template>\r\n  <div id=\"cesiumContainer\"></div>\r\n</template>\r\n\r\n<script>\r\nimport 'cesium/Build/Cesium/Widgets/widgets.css'\r\nimport * as Cesium from 'cesium'\r\n\r\nexport default {\r\n  data() {\r\n    return { path: process.env.BASE_URL }\r\n  },\r\n  mounted() {\r\n    this.init()\r\n  },\r\n  methods: {\r\n    init() {\r\n      var viewer = new Cesium.Viewer('cesiumContainer', {\r\n        imageryProvider: new Cesium.UrlTemplateImageryProvider({\r\n          url: \"https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\r\n          subdomains: [\"a\", \"b\", \"c\", \"d\"],\r\n        }),\r\n        terrainProvider: Cesium.createWorldTerrain()\r\n      })\r\n      if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {\r\n        //判断是否支持图像渲染像素化处理\r\n        viewer.resolutionScale = window.devicePixelRatio\r\n      }\r\n      viewer.scene.postProcessStages.fxaa.enabled = true\r\n      viewer.scene.debugShowFramesPerSecond = true;\r\n\r\n      const initialPosition = Cesium.Cartesian3.fromDegrees(\r\n        -74.01881302800248,\r\n        40.69114333714821,\r\n        753\r\n      );\r\n      const initialOrientation = new Cesium.HeadingPitchRoll.fromDegrees(\r\n        21.27879878293835,\r\n        -21.34390550872461,\r\n        0.0716951918898415\r\n      );\r\n      viewer.scene.camera.setView({\r\n        destination: initialPosition,\r\n        orientation: initialOrientation,\r\n        endTransform: Cesium.Matrix4.IDENTITY,\r\n      });\r\n\r\n      const customShader = new Cesium.CustomShader({\r\n        uniforms: {\r\n          maxHeight: {\r\n            type: Cesium.UniformType.FLOAT,\r\n            value: 0.0,\r\n          },\r\n          minHeight: {\r\n            type: Cesium.UniformType.FLOAT,\r\n            value: 0.0,\r\n          },\r\n        },\r\n        fragmentShaderText: `\r\n          void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\r\n            float curz = fsInput.attributes.positionMC.z;\r\n            float d = (curz - minHeight) / (maxHeight - minHeight);\r\n            float r = 0.01;\r\n            r = fract(r * czm_frameNumber);\r\n            float c = smoothstep(r, r+0.03, d) - smoothstep(r + 0.035,r + 0.04, d);\r\n            vec3 linearColor = mix(vec3(1.0,1.0,1.0) ,vec3(255.0,48.0,48.0)/255.0,r);\r\n            vec3 renderColor = mix(vec3(0.0,0.96,1.0) ,linearColor,c);\r\n            material.diffuse = renderColor;\r\n          }`\r\n      });\r\n\r\n      const tileset = new Cesium.Cesium3DTileset({\r\n        url: Cesium.IonResource.fromAssetId(96188),\r\n        customShader: customShader\r\n      });\r\n      tileset.readyPromise.then((tileset) => {\r\n        const [maxheight, minheight] = [\r\n          tileset.properties['cesium#estimatedHeight'].maximum,\r\n          tileset.properties['cesium#estimatedHeight'].minimum,\r\n        ];\r\n        tileset.customShader.setUniform(\"maxHeight\", maxheight);\r\n        tileset.customShader.setUniform(\"minHeight\", minheight);\r\n\r\n        viewer.scene.primitives.add(tileset);\r\n      });\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n#cesiumContainer {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n</style>\r\n","/**\n * An enum of the basic GLSL uniform types. These can be used with\n * {@link CustomShader} to declare user-defined uniforms.\n *\n * @enum {String}\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nconst UniformType = {\n  /**\n   * A single floating point value.\n   *\n   * @type {String}\n   * @constant\n   */\n  FLOAT: \"float\",\n  /**\n   * A vector of 2 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC2: \"vec2\",\n  /**\n   * A vector of 3 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC3: \"vec3\",\n  /**\n   * A vector of 4 floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  VEC4: \"vec4\",\n  /**\n   * A single integer value\n   *\n   * @type {String}\n   * @constant\n   */\n  INT: \"int\",\n  /**\n   * A vector of 2 integer values.\n   *\n   * @type {String}\n   * @constant\n   */\n  INT_VEC2: \"ivec2\",\n  /**\n   * A vector of 3 integer values.\n   *\n   * @type {String}\n   * @constant\n   */\n  INT_VEC3: \"ivec3\",\n  /**\n   * A vector of 4 integer values.\n   *\n   * @type {String}\n   * @constant\n   */\n  INT_VEC4: \"ivec4\",\n  /**\n   * A single boolean value.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL: \"bool\",\n  /**\n   * A vector of 2 boolean values.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL_VEC2: \"bvec2\",\n  /**\n   * A vector of 3 boolean values.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL_VEC3: \"bvec3\",\n  /**\n   * A vector of 4 boolean values.\n   *\n   * @type {String}\n   * @constant\n   */\n  BOOL_VEC4: \"bvec4\",\n  /**\n   * A 2x2 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT2: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT3: \"mat2\",\n  /**\n   * A 3x3 matrix of floating point values.\n   *\n   * @type {String}\n   * @constant\n   */\n  MAT4: \"mat4\",\n  /**\n   * A 2D sampled texture.\n   * @type {String}\n   * @constant\n   */\n  SAMPLER_2D: \"sampler2D\",\n  SAMPLER_CUBE: \"samplerCube\",\n};\n\nexport default Object.freeze(UniformType);\n","/**\n * Constructs an image from a TypedArray of pixel values\n *\n * @param {Uint8Array} typedArray The array of pixel values\n * @param {Number} width The width of the image to create\n * @param {Number} height The height of the image to create\n * @returns {HTMLCanvasElement} A new canvas containing the constructed image\n *\n * @private\n */\nfunction getImageFromTypedArray(typedArray, width, height) {\n  // Input typedArray is Uint8Array, ImageData needs Uint8ClampedArray\n  // To avoid copying, make a new DataView of the same buffer\n  const dataArray = new Uint8ClampedArray(typedArray.buffer);\n  const imageData = new ImageData(dataArray, width, height);\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = width;\n  canvas.height = height;\n  canvas.getContext(\"2d\").putImageData(imageData, 0, 0);\n\n  return canvas;\n}\nexport default getImageFromTypedArray;\n","import defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport getImageFromTypedArray from \"../../Core/getImageFromTypedArray.js\";\nimport CesiumMath from \"../../Core/Math.js\";\nimport resizeImageToNextPowerOfTwo from \"../../Core/resizeImageToNextPowerOfTwo.js\";\nimport PixelDatatype from \"../../Renderer/PixelDatatype.js\";\nimport Texture from \"../../Renderer/Texture.js\";\nimport TextureMinificationFilter from \"../../Renderer/TextureMinificationFilter.js\";\nimport TextureWrap from \"../../Renderer/TextureWrap.js\";\n\n/**\n * An object to manage loading textures\n *\n * @alias TextureManager\n * @constructor\n *\n * @private\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\nfunction TextureManager() {\n  this._defaultTexture = undefined;\n  this._textures = {};\n  this._loadedImages = [];\n\n  // Keep track of the last time update() was called to avoid\n  // calling update() twice.\n  this._lastUpdatedFrame = -1;\n}\n\n/**\n * Get one of the loaded textures\n * @param {String} textureId The unique ID of the texture loaded by {@link TextureManager#loadTexture2D}\n * @return {Texture} The texture or <code>undefined</code> if no texture exists\n */\nTextureManager.prototype.getTexture = function (textureId) {\n  return this._textures[textureId];\n};\n\nfunction fetchTexture2D(textureManager, textureId, textureUniform) {\n  textureUniform.resource\n    .fetchImage()\n    .then(function (image) {\n      textureManager._loadedImages.push({\n        id: textureId,\n        image: image,\n        textureUniform: textureUniform,\n      });\n    })\n    .catch(function () {\n      const texture = textureManager._textures[textureId];\n      if (defined(texture) && texture !== textureManager._defaultTexture) {\n        texture.destroy();\n      }\n\n      textureManager._textures[textureId] = textureManager._defaultTexture;\n    });\n}\n\n/**\n * Load a texture 2D asynchronously. Note that {@link TextureManager#update}\n * must be called in the render loop to finish processing the textures.\n *\n * @param {String} textureId A unique ID to identify this texture.\n * @param {TextureUniform} textureUniform A description of the texture\n *\n * @private\n */\nTextureManager.prototype.loadTexture2D = function (textureId, textureUniform) {\n  if (defined(textureUniform.typedArray)) {\n    this._loadedImages.push({\n      id: textureId,\n      textureUniform: textureUniform,\n    });\n  } else {\n    fetchTexture2D(this, textureId, textureUniform);\n  }\n};\n\nfunction createTexture(textureManager, loadedImage, context) {\n  const { id, textureUniform, image } = loadedImage;\n\n  // If the context is WebGL1, and the sampler needs mipmaps or repeating\n  // boundary conditions, the image may need to be resized first\n  const texture = context.webgl2\n    ? getTextureAndMips(textureUniform, image, context)\n    : getWebGL1Texture(textureUniform, image, context);\n\n  // Destroy the old texture once the new one is loaded for more seamless\n  // transitions between values\n  const oldTexture = textureManager._textures[id];\n  if (defined(oldTexture) && oldTexture !== context.defaultTexture) {\n    oldTexture.destroy();\n  }\n  textureManager._textures[id] = texture;\n}\n\nfunction getTextureAndMips(textureUniform, image, context) {\n  const { typedArray, sampler } = textureUniform;\n\n  const texture = defined(typedArray)\n    ? getTextureFromTypedArray(textureUniform, context)\n    : new Texture({ context, source: image, sampler });\n\n  if (samplerRequiresMipmap(sampler)) {\n    texture.generateMipmap();\n  }\n\n  return texture;\n}\n\nfunction getWebGL1Texture(textureUniform, image, context) {\n  const { typedArray, sampler } = textureUniform;\n\n  // WebGL1 requires power-of-two texture dimensions for mipmapping and REPEAT wrap modes\n  const needMipmap = samplerRequiresMipmap(sampler);\n\n  const samplerRepeats =\n    sampler.wrapS === TextureWrap.REPEAT ||\n    sampler.wrapS === TextureWrap.MIRRORED_REPEAT ||\n    sampler.wrapT === TextureWrap.REPEAT ||\n    sampler.wrapT === TextureWrap.MIRRORED_REPEAT;\n\n  const { width, height } = defined(typedArray) ? textureUniform : image;\n  const isPowerOfTwo = [width, height].every(CesiumMath.isPowerOfTwo);\n  const requiresResize = (needMipmap || samplerRepeats) && !isPowerOfTwo;\n\n  if (!requiresResize) {\n    return getTextureAndMips(textureUniform, image, context);\n  } else if (!defined(typedArray)) {\n    const resizedImage = resizeImageToNextPowerOfTwo(image);\n    return getTextureAndMips(textureUniform, resizedImage, context);\n  } else if (textureUniform.pixelDatatype === PixelDatatype.UNSIGNED_BYTE) {\n    const imageFromArray = getImageFromTypedArray(typedArray, width, height);\n    const resizedImage = resizeImageToNextPowerOfTwo(imageFromArray);\n    return getTextureAndMips({ sampler }, resizedImage, context);\n  }\n\n  // typedArray is non-power-of-two but can't be resized. Warn and return raw texture (no mipmaps)\n  if (needMipmap) {\n    console.warn(\n      \"Texture requires resizing for mipmaps but pixelDataType cannot be resized. The texture may be rendered incorrectly.\"\n    );\n  } else if (samplerRepeats) {\n    console.warn(\n      \"Texture requires resizing for wrapping but pixelDataType cannot be resized. The texture may be rendered incorrectly.\"\n    );\n  }\n  return getTextureFromTypedArray(textureUniform, context);\n}\n\nfunction samplerRequiresMipmap(sampler) {\n  return [\n    TextureMinificationFilter.NEAREST_MIPMAP_NEAREST,\n    TextureMinificationFilter.NEAREST_MIPMAP_LINEAR,\n    TextureMinificationFilter.LINEAR_MIPMAP_NEAREST,\n    TextureMinificationFilter.LINEAR_MIPMAP_LINEAR,\n  ].includes(sampler.minificationFilter);\n}\n\nfunction getTextureFromTypedArray(textureUniform, context) {\n  const {\n    pixelFormat,\n    pixelDatatype,\n    width,\n    height,\n    typedArray: arrayBufferView,\n    sampler,\n  } = textureUniform;\n\n  return new Texture({\n    context,\n    pixelFormat,\n    pixelDatatype,\n    source: { arrayBufferView, width, height },\n    sampler,\n    flipY: false,\n  });\n}\n\nTextureManager.prototype.update = function (frameState) {\n  // update only needs to be called once a frame.\n  if (frameState.frameNumber === this._lastUpdatedFrame) {\n    return;\n  }\n  this._lastUpdatedFrame = frameState.frameNumber;\n\n  const context = frameState.context;\n  this._defaultTexture = context.defaultTexture;\n\n  // If any images were loaded since the last frame, create Textures\n  // for them and store in the uniform dictionary\n  const loadedImages = this._loadedImages;\n  for (let i = 0; i < loadedImages.length; i++) {\n    const loadedImage = loadedImages[i];\n    createTexture(this, loadedImage, context);\n  }\n  loadedImages.length = 0;\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see TextureManager#destroy\n * @private\n */\nTextureManager.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * textureManager = textureManager && textureManager.destroy();\n *\n * @see TextureManager#isDestroyed\n * @private\n */\nTextureManager.prototype.destroy = function () {\n  const textures = this._textures;\n  for (const texture in textures) {\n    if (textures.hasOwnProperty(texture)) {\n      const instance = textures[texture];\n      if (instance !== this._defaultTexture) {\n        instance.destroy();\n      }\n    }\n  }\n  return destroyObject(this);\n};\n\nexport default TextureManager;\n","import Check from \"../../Core/Check.js\";\nimport defaultValue from \"../../Core/defaultValue.js\";\nimport defined from \"../../Core/defined.js\";\nimport destroyObject from \"../../Core/destroyObject.js\";\nimport DeveloperError from \"../../Core/DeveloperError.js\";\nimport CustomShaderMode from \"./CustomShaderMode.js\";\nimport UniformType from \"./UniformType.js\";\nimport TextureManager from \"./TextureManager.js\";\nimport CustomShaderTranslucencyMode from \"./CustomShaderTranslucencyMode.js\";\n\n/**\n * An object describing a uniform, its type, and an initial value\n *\n * @typedef {Object} UniformSpecifier\n * @property {UniformType} type The Glsl type of the uniform.\n * @property {Boolean|Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|TextureUniform} value The initial value of the uniform\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n */\n\n/**\n * A set of variables parsed from the user-defined shader code. These can be\n * used for optimizations when generating the overall shader. Though they are\n * represented as JS objects, the intended use is like a set, so only the\n * existence of keys matter. The values will always be <code>true</code> if\n * defined. This data structure is used because:\n * <ul>\n *   <li>We cannot yet use ES6 Set objects</li>\n *   <li>Using a dictionary automatically de-duplicates variable names</li>\n *   <li>Queries such as <code>variableSet.hasOwnProperty(\"position\")</code> are straightforward</li>\n * </ul>\n * @typedef {Object<String, Boolean>} VariableSet\n * @private\n */\n\n/**\n * Variable sets parsed from the user-defined vertex shader text.\n * @typedef {Object} VertexVariableSets\n * @property {VariableSet} attributeSet A set of all unique attributes used in the vertex shader via the <code>vsInput.attributes</code> struct.\n * @property {VariableSet} featureIdSet A set of all unique feature ID sets used in the vertex shader via the <code>vsInput.featureIds</code> struct.\n * @property {VariableSet} metadataSet A set of all unique metadata properties used in the vertex shader via the <code>vsInput.metadata</code> struct.\n * @private\n */\n\n/**\n * Variable sets parsed from the user-defined fragment shader text.\n * @typedef {Object} FragmentVariableSets\n * @property {VariableSet} attributeSet A set of all unique attributes used in the fragment shader via the <code>fsInput.attributes</code> struct\n * @property {VariableSet} featureIdSet A set of all unique feature ID sets used in the fragment shader via the <code>fsInput.featureIds</code> struct.\n * @property {VariableSet} metadataSet A set of all unique metadata properties used in the fragment shader via the <code>fsInput.metadata</code> struct.\n * @property {VariableSet} materialSet A set of all material variables such as diffuse, specular or alpha that are used in the fragment shader via the <code>material</code> struct.\n * @private\n */\n\n/**\n * A user defined GLSL shader used with {@link Model} as well\n * as {@link Cesium3DTileset}.\n * <p>\n * If texture uniforms are used, additional resource management must be done:\n * </p>\n * <ul>\n *   <li>\n *      The <code>update</code> function must be called each frame. When a\n *      custom shader is passed to a {@link Model} or a\n *      {@link Cesium3DTileset}, this step is handled automaticaly\n *   </li>\n *   <li>\n *      {@link CustomShader#destroy} must be called when the custom shader is\n *      no longer needed to clean up GPU resources properly. The application\n *      is responsible for calling this method.\n *   </li>\n * </ul>\n * <p>\n * See the {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide} for more detailed documentation.\n * </p>\n *\n * @param {Object} options An object with the following options\n * @param {CustomShaderMode} [options.mode=CustomShaderMode.MODIFY_MATERIAL] The custom shader mode, which determines how the custom shader code is inserted into the fragment shader.\n * @param {LightingModel} [options.lightingModel] The lighting model (e.g. PBR or unlit). If present, this overrides the default lighting for the model.\n * @param {CustomShaderTranslucencyMode} [options.translucencyMode=CustomShaderTranslucencyMode.INHERIT] The translucency mode, which determines how the custom shader will be applied. If the value is CustomShaderTransulcencyMode.OPAQUE or CustomShaderTransulcencyMode.TRANSLUCENT, the custom shader will override settings from the model's material. If the value is CustomShaderTransulcencyMode.INHERIT, the custom shader will render as either opaque or translucent depending on the primitive's material settings.\n * @param {Object.<String, UniformSpecifier>} [options.uniforms] A dictionary for user-defined uniforms. The key is the uniform name that will appear in the GLSL code. The value is an object that describes the uniform type and initial value\n * @param {Object.<String, VaryingType>} [options.varyings] A dictionary for declaring additional GLSL varyings used in the shader. The key is the varying name that will appear in the GLSL code. The value is the data type of the varying. For each varying, the declaration will be added to the top of the shader automatically. The caller is responsible for assigning a value in the vertex shader and using the value in the fragment shader.\n * @param {String} [options.vertexShaderText] The custom vertex shader as a string of GLSL code. It must include a GLSL function called vertexMain. See the example for the expected signature. If not specified, the custom vertex shader step will be skipped in the computed vertex shader.\n * @param {String} [options.fragmentShaderText] The custom fragment shader as a string of GLSL code. It must include a GLSL function called fragmentMain. See the example for the expected signature. If not specified, the custom fragment shader step will be skipped in the computed fragment shader.\n *\n * @alias CustomShader\n * @constructor\n *\n * @experimental This feature is using part of the 3D Tiles spec that is not final and is subject to change without Cesium's standard deprecation policy.\n *\n * @example\n * const customShader = new CustomShader({\n *   uniforms: {\n *     u_colorIndex: {\n *       type: Cesium.UniformType.FLOAT,\n *       value: 1.0\n *     },\n *     u_normalMap: {\n *       type: Cesium.UniformType.SAMPLER_2D,\n *       value: new Cesium.TextureUniform({\n *         url: \"http://example.com/normal.png\"\n *       })\n *     }\n *   },\n *   varyings: {\n *     v_selectedColor: Cesium.VaryingType.VEC3\n *   },\n *   vertexShaderText: `\n *   void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {\n *     v_selectedColor = mix(vsInput.attributes.color_0, vsInput.attributes.color_1, u_colorIndex);\n *     vsOutput.positionMC += 0.1 * vsInput.attributes.normal;\n *   }\n *   `,\n *   fragmentShaderText: `\n *   void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {\n *     material.normal = texture2D(u_normalMap, fsInput.attributes.texCoord_0);\n *     material.diffuse = v_selectedColor;\n *   }\n *   `\n * });\n */\nfunction CustomShader(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  /**\n   * A value determining how the custom shader interacts with the overall\n   * fragment shader. This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {CustomShaderMode}\n   * @readonly\n   */\n  this.mode = defaultValue(options.mode, CustomShaderMode.MODIFY_MATERIAL);\n  /**\n   * The lighting model to use when using the custom shader.\n   * This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {LightingModel}\n   * @readonly\n   */\n  this.lightingModel = options.lightingModel;\n  /**\n   * Additional uniforms as declared by the user.\n   *\n   * @type {Object.<String, UniformSpecifier>}\n   * @readonly\n   */\n  this.uniforms = defaultValue(options.uniforms, defaultValue.EMPTY_OBJECT);\n  /**\n   * Additional varyings as declared by the user.\n   * This is used by {@link CustomShaderPipelineStage}\n   *\n   * @type {Object.<String, VaryingType>}\n   * @readonly\n   */\n  this.varyings = defaultValue(options.varyings, defaultValue.EMPTY_OBJECT);\n  /**\n   * The user-defined GLSL code for the vertex shader\n   *\n   * @type {String}\n   * @readonly\n   */\n  this.vertexShaderText = options.vertexShaderText;\n  /**\n   * The user-defined GLSL code for the fragment shader\n   *\n   * @type {String}\n   * @readonly\n   */\n  this.fragmentShaderText = options.fragmentShaderText;\n\n  /**\n   * The translucency mode, which determines how the custom shader will be applied. If the value is\n   * CustomShaderTransulcencyMode.OPAQUE or CustomShaderTransulcencyMode.TRANSLUCENT, the custom shader\n   * will override settings from the model's material. If the value isCustomShaderTransulcencyMode.INHERIT,\n   * the custom shader will render as either opaque or translucent depending on the primitive's material settings.\n   *\n   * @type {CustomShaderTranslucencyMode}\n   * @default CustomShaderTranslucencyMode.INHERIT\n   * @readonly\n   */\n  this.translucencyMode = defaultValue(\n    options.translucencyMode,\n    CustomShaderTranslucencyMode.INHERIT\n  );\n\n  /**\n   * texture uniforms require some asynchronous processing. This is delegated\n   * to a texture manager.\n   *\n   * @type {TextureManager}\n   * @readonly\n   * @private\n   */\n  this._textureManager = new TextureManager();\n  /**\n   * The default texture (from the {@link Context}) to use while textures\n   * are loading\n   *\n   * @type {Texture}\n   * @readonly\n   * @private\n   */\n  this._defaultTexture = undefined;\n  /**\n   * The map of uniform names to a function that returns a value. This map\n   * is combined with the overall uniform map used by the {@link DrawCommand}\n   *\n   * @type {Object.<String, Function>}\n   * @readonly\n   * @private\n   */\n  this.uniformMap = buildUniformMap(this);\n\n  /**\n   * A collection of variables used in <code>vertexShaderText</code>. This\n   * is used only for optimizations in {@link CustomShaderPipelineStage}.\n   * @type {VertexVariableSets}\n   * @private\n   */\n  this.usedVariablesVertex = {\n    attributeSet: {},\n    featureIdSet: {},\n    metadataSet: {},\n  };\n  /**\n   * A collection of variables used in <code>fragmentShaderText</code>. This\n   * is used only for optimizations in {@link CustomShaderPipelineStage}.\n   * @type {FragmentVariableSets}\n   * @private\n   */\n  this.usedVariablesFragment = {\n    attributeSet: {},\n    featureIdSet: {},\n    metadataSet: {},\n    materialSet: {},\n  };\n\n  findUsedVariables(this);\n  validateBuiltinVariables(this);\n}\n\nfunction buildUniformMap(customShader) {\n  const uniforms = customShader.uniforms;\n  const uniformMap = {};\n  for (const uniformName in uniforms) {\n    if (uniforms.hasOwnProperty(uniformName)) {\n      const uniform = uniforms[uniformName];\n      const type = uniform.type;\n      //>>includeStart('debug', pragmas.debug);\n      if (type === UniformType.SAMPLER_CUBE) {\n        throw new DeveloperError(\n          \"CustomShader does not support samplerCube uniforms\"\n        );\n      }\n      //>>includeEnd('debug');\n\n      if (type === UniformType.SAMPLER_2D) {\n        customShader._textureManager.loadTexture2D(uniformName, uniform.value);\n        uniformMap[uniformName] = createUniformTexture2DFunction(\n          customShader,\n          uniformName\n        );\n      } else {\n        uniformMap[uniformName] = createUniformFunction(\n          customShader,\n          uniformName\n        );\n      }\n    }\n  }\n  return uniformMap;\n}\n\nfunction createUniformTexture2DFunction(customShader, uniformName) {\n  return function () {\n    return defaultValue(\n      customShader._textureManager.getTexture(uniformName),\n      customShader._defaultTexture\n    );\n  };\n}\n\nfunction createUniformFunction(customShader, uniformName) {\n  return function () {\n    return customShader.uniforms[uniformName].value;\n  };\n}\n\nfunction getVariables(shaderText, regex, outputSet) {\n  let match;\n  while ((match = regex.exec(shaderText)) !== null) {\n    const variableName = match[1];\n\n    // Using a dictionary like a set. The value doesn't\n    // matter, as this will only be used for queries such as\n    // if (set.hasOwnProperty(variableName)) { ... }\n    outputSet[variableName] = true;\n  }\n}\n\nfunction findUsedVariables(customShader) {\n  const attributeRegex = /[vf]sInput\\.attributes\\.(\\w+)/g;\n  const featureIdRegex = /[vf]sInput\\.featureIds\\.(\\w+)/g;\n  const metadataRegex = /[vf]sInput\\.metadata.(\\w+)/g;\n  let attributeSet;\n\n  const vertexShaderText = customShader.vertexShaderText;\n  if (defined(vertexShaderText)) {\n    attributeSet = customShader.usedVariablesVertex.attributeSet;\n    getVariables(vertexShaderText, attributeRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesVertex.featureIdSet;\n    getVariables(vertexShaderText, featureIdRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesVertex.metadataSet;\n    getVariables(vertexShaderText, metadataRegex, attributeSet);\n  }\n\n  const fragmentShaderText = customShader.fragmentShaderText;\n  if (defined(fragmentShaderText)) {\n    attributeSet = customShader.usedVariablesFragment.attributeSet;\n    getVariables(fragmentShaderText, attributeRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesFragment.featureIdSet;\n    getVariables(fragmentShaderText, featureIdRegex, attributeSet);\n\n    attributeSet = customShader.usedVariablesFragment.metadataSet;\n    getVariables(fragmentShaderText, metadataRegex, attributeSet);\n\n    const materialRegex = /material\\.(\\w+)/g;\n    const materialSet = customShader.usedVariablesFragment.materialSet;\n    getVariables(fragmentShaderText, materialRegex, materialSet);\n  }\n}\n\nfunction expandCoordinateAbbreviations(variableName) {\n  const modelCoordinatesRegex = /^.*MC$/;\n  const worldCoordinatesRegex = /^.*WC$/;\n  const eyeCoordinatesRegex = /^.*EC$/;\n\n  if (modelCoordinatesRegex.test(variableName)) {\n    return `${variableName} (model coordinates)`;\n  }\n\n  if (worldCoordinatesRegex.test(variableName)) {\n    return `${variableName} (Cartesian world coordinates)`;\n  }\n\n  if (eyeCoordinatesRegex.test(variableName)) {\n    return `${variableName} (eye coordinates)`;\n  }\n\n  return variableName;\n}\n\nfunction validateVariableUsage(\n  variableSet,\n  incorrectVariable,\n  correctVariable,\n  vertexOrFragment\n) {\n  if (variableSet.hasOwnProperty(incorrectVariable)) {\n    const message = `${expandCoordinateAbbreviations(\n      incorrectVariable\n    )} is not available in the ${vertexOrFragment} shader. Did you mean ${expandCoordinateAbbreviations(\n      correctVariable\n    )} instead?`;\n    throw new DeveloperError(message);\n  }\n}\n\nfunction validateBuiltinVariables(customShader) {\n  const attributesVS = customShader.usedVariablesVertex.attributeSet;\n\n  // names without MC/WC/EC are ambiguous\n  validateVariableUsage(attributesVS, \"position\", \"positionMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"normal\", \"normalMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"tangent\", \"tangentMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"bitangent\", \"bitangentMC\", \"vertex\");\n\n  // world and eye coordinate positions are only available in the fragment shader.\n  validateVariableUsage(attributesVS, \"positionWC\", \"positionMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"positionEC\", \"positionMC\", \"vertex\");\n\n  // normal, tangent and bitangent are in model coordinates in the vertex shader\n  validateVariableUsage(attributesVS, \"normalEC\", \"normalMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"tangentEC\", \"tangentMC\", \"vertex\");\n  validateVariableUsage(attributesVS, \"bitangentEC\", \"bitangentMC\", \"vertex\");\n\n  const attributesFS = customShader.usedVariablesFragment.attributeSet;\n\n  // names without MC/WC/EC are ambiguous\n  validateVariableUsage(attributesFS, \"position\", \"positionEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"normal\", \"normalEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"tangent\", \"tangentEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"bitangent\", \"bitangentEC\", \"fragment\");\n\n  // normal, tangent, and bitangent are in eye coordinates in the fragment\n  // shader.\n  validateVariableUsage(attributesFS, \"normalMC\", \"normalEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"tangentMC\", \"tangentEC\", \"fragment\");\n  validateVariableUsage(attributesFS, \"bitangentMC\", \"bitangentEC\", \"fragment\");\n}\n\n/**\n * Update the value of a uniform declared in the shader\n * @param {String} uniformName The GLSL name of the uniform. This must match one of the uniforms declared in the constructor\n * @param {Boolean|Number|Cartesian2|Cartesian3|Cartesian4|Matrix2|Matrix3|Matrix4|String|Resource} value The new value of the uniform.\n */\nCustomShader.prototype.setUniform = function (uniformName, value) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"uniformName\", uniformName);\n  Check.defined(\"value\", value);\n  if (!defined(this.uniforms[uniformName])) {\n    throw new DeveloperError(\n      `Uniform ${uniformName} must be declared in the CustomShader constructor.`\n    );\n  }\n  //>>includeEnd('debug');\n  const uniform = this.uniforms[uniformName];\n  if (uniform.type === UniformType.SAMPLER_2D) {\n    // Textures are loaded asynchronously\n    this._textureManager.loadTexture2D(uniformName, value);\n  } else if (defined(value.clone)) {\n    // clone Cartesian and Matrix types.\n    uniform.value = value.clone(uniform.value);\n  } else {\n    uniform.value = value;\n  }\n};\n\nCustomShader.prototype.update = function (frameState) {\n  this._defaultTexture = frameState.context.defaultTexture;\n  this._textureManager.update(frameState);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <br /><br />\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n *\n * @returns {Boolean} True if this object was destroyed; otherwise, false.\n *\n * @see CustomShader#destroy\n * @private\n */\nCustomShader.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <br /><br />\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @example\n * customShader = customShader && customShader.destroy();\n *\n * @see CustomShader#isDestroyed\n * @private\n */\nCustomShader.prototype.destroy = function () {\n  this._textureManager = this._textureManager && this._textureManager.destroy();\n  destroyObject(this);\n};\n\nexport default CustomShader;\n","import { render } from \"./3dTiles_shader.vue?vue&type=template&id=974c3aec&scoped=true\"\nimport script from \"./3dTiles_shader.vue?vue&type=script&lang=js\"\nexport * from \"./3dTiles_shader.vue?vue&type=script&lang=js\"\n\nimport \"./3dTiles_shader.vue?vue&type=style&index=0&id=974c3aec&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-974c3aec\"]])\n\nexport default __exports__"],"names":["id","_createElementBlock","_hoisted_1","UniformType","FLOAT","VEC2","VEC3","VEC4","INT","INT_VEC2","INT_VEC3","INT_VEC4","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","MAT2","MAT3","MAT4","SAMPLER_2D","SAMPLER_CUBE","Object","freeze","getImageFromTypedArray","typedArray","width","height","dataArray","Uint8ClampedArray","buffer","imageData","ImageData","canvas","document","createElement","getContext","putImageData","TextureManager","this","_defaultTexture","undefined","_textures","_loadedImages","_lastUpdatedFrame","fetchTexture2D","textureManager","textureId","textureUniform","resource","fetchImage","then","image","push","catch","texture","defined","destroy","createTexture","loadedImage","context","webgl2","getTextureAndMips","getWebGL1Texture","oldTexture","defaultTexture","sampler","getTextureFromTypedArray","Texture","source","samplerRequiresMipmap","generateMipmap","needMipmap","samplerRepeats","wrapS","TextureWrap","wrapT","isPowerOfTwo","every","CesiumMath","requiresResize","resizedImage","resizeImageToNextPowerOfTwo","pixelDatatype","PixelDatatype","imageFromArray","console","warn","TextureMinificationFilter","includes","minificationFilter","pixelFormat","arrayBufferView","flipY","prototype","getTexture","loadTexture2D","update","frameState","frameNumber","loadedImages","i","length","isDestroyed","textures","hasOwnProperty","instance","destroyObject","CustomShader","options","defaultValue","mode","CustomShaderMode","lightingModel","uniforms","varyings","vertexShaderText","fragmentShaderText","translucencyMode","CustomShaderTranslucencyMode","_textureManager","uniformMap","buildUniformMap","usedVariablesVertex","attributeSet","featureIdSet","metadataSet","usedVariablesFragment","materialSet","findUsedVariables","validateBuiltinVariables","customShader","uniformName","uniform","type","DeveloperError","value","createUniformTexture2DFunction","createUniformFunction","getVariables","shaderText","regex","outputSet","match","exec","variableName","attributeRegex","featureIdRegex","metadataRegex","materialRegex","expandCoordinateAbbreviations","modelCoordinatesRegex","worldCoordinatesRegex","eyeCoordinatesRegex","test","validateVariableUsage","variableSet","incorrectVariable","correctVariable","vertexOrFragment","message","attributesVS","attributesFS","setUniform","Check","clone","data","path","process","mounted","init","methods","viewer","Cesium","imageryProvider","url","subdomains","terrainProvider","resolutionScale","window","devicePixelRatio","scene","postProcessStages","fxaa","enabled","debugShowFramesPerSecond","initialPosition","initialOrientation","camera","setView","destination","orientation","endTransform","maxHeight","minHeight","tileset","readyPromise","maxheight","minheight","properties","maximum","minimum","primitives","add","__exports__","render"],"sourceRoot":""}