{"version":3,"file":"js/926.5f0af3a4.js","mappings":"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","sources":["webpack://webgis/./src/components/public/optimizing_lots_of_objects.vue","webpack://webgis/./node_modules/three/examples/jsm/utils/BufferGeometryUtils.js","webpack://webgis/./src/components/public/optimizing_lots_of_objects.vue?4eea"],"sourcesContent":["<template>\r\n  <div class=\"container\"><canvas id=\"c\"></canvas></div>\r\n</template>\r\n\r\n<script>\r\nimport * as THREE from 'three'\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'\r\nimport { mergeBufferGeometries } from 'three/examples/jsm/utils/BufferGeometryUtils'\r\n\r\nexport default {\r\n  mounted() {\r\n    this.init()\r\n  },\r\n  methods: {\r\n    init() {\r\n      const canvas = document.querySelector('#c')\r\n      const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true })\r\n\r\n      const fov = 60\r\n      const aspect = 2 // the canvas default\r\n      const near = 0.1\r\n      const far = 10\r\n      const camera = new THREE.PerspectiveCamera(fov, aspect, near, far)\r\n      camera.position.z = 2.5\r\n\r\n      const controls = new OrbitControls(camera, canvas)\r\n      controls.enableDamping = true\r\n      controls.enablePan = false\r\n      controls.minDistance = 1.2\r\n      controls.maxDistance = 4\r\n      controls.update()\r\n\r\n      const scene = new THREE.Scene()\r\n      scene.background = new THREE.Color('black')\r\n\r\n      {\r\n        const loader = new THREE.TextureLoader()\r\n        const texture = loader.load(\r\n          'https://threejsfundamentals.org/threejs/resources/images/world.jpg',\r\n          render\r\n        )\r\n        const geometry = new THREE.SphereGeometry(1, 64, 32)\r\n        const material = new THREE.MeshBasicMaterial({ map: texture })\r\n        scene.add(new THREE.Mesh(geometry, material))\r\n      }\r\n\r\n      async function loadFile(url) {\r\n        const req = await fetch(url)\r\n        return req.text()\r\n      }\r\n\r\n      function parseData(text) {\r\n        const data = []\r\n        const settings = { data }\r\n        let max\r\n        let min\r\n        // split into lines\r\n        text.split('\\n').forEach((line) => {\r\n          // split the line by whitespace\r\n          const parts = line.trim().split(/\\s+/)\r\n          if (parts.length === 2) {\r\n            // only 2 parts, must be a key/value pair\r\n            settings[parts[0]] = parseFloat(parts[1])\r\n          } else if (parts.length > 2) {\r\n            // more than 2 parts, must be data\r\n            const values = parts.map((v) => {\r\n              const value = parseFloat(v)\r\n              if (value === settings.NODATA_value) {\r\n                return undefined\r\n              }\r\n              max = Math.max(max === undefined ? value : max, value)\r\n              min = Math.min(min === undefined ? value : min, value)\r\n              return value\r\n            })\r\n            data.push(values)\r\n          }\r\n        })\r\n        return Object.assign(settings, { min, max })\r\n      }\r\n\r\n      function addBoxes(file) {\r\n        const { min, max, data } = file\r\n        const range = max - min\r\n\r\n        // these helpers will make it easy to position the boxes\r\n        // We can rotate the lon helper on its Y axis to the longitude\r\n        const lonHelper = new THREE.Object3D()\r\n        scene.add(lonHelper)\r\n        // We rotate the latHelper on its X axis to the latitude\r\n        const latHelper = new THREE.Object3D()\r\n        lonHelper.add(latHelper)\r\n        // The position helper moves the object to the edge of the sphere\r\n        const positionHelper = new THREE.Object3D()\r\n        positionHelper.position.z = 1.0\r\n        latHelper.add(positionHelper)\r\n        // Used to move the center of the box so it scales from the position Z axis\r\n        const originHelper = new THREE.Object3D()\r\n        originHelper.position.z = 0.5\r\n        positionHelper.add(originHelper)\r\n\r\n        const color = new THREE.Color()\r\n        const lonFudge = Math.PI * 0.5\r\n        const latFudge = Math.PI * -0.135\r\n        const geometries = []\r\n        data.forEach((row, latNdx) => {\r\n          row.forEach((value, lonNdx) => {\r\n            if (value === undefined) {\r\n              return\r\n            }\r\n            const amount = (value - min) / range\r\n\r\n            const boxWidth = 1\r\n            const boxHeight = 1\r\n            const boxDepth = 1\r\n            const geometry = new THREE.BoxGeometry(\r\n              boxWidth,\r\n              boxHeight,\r\n              boxDepth\r\n            )\r\n\r\n            // adjust the helpers to point to the latitude and longitude\r\n            lonHelper.rotation.y =\r\n              THREE.MathUtils.degToRad(lonNdx + file.xllcorner) + lonFudge\r\n            latHelper.rotation.x =\r\n              THREE.MathUtils.degToRad(latNdx + file.yllcorner) + latFudge\r\n\r\n            // use the world matrix of the origin helper to\r\n            // position this geometry\r\n            positionHelper.scale.set(\r\n              0.005,\r\n              0.005,\r\n              THREE.MathUtils.lerp(0.01, 0.5, amount)\r\n            )\r\n\r\n            originHelper.updateWorldMatrix(true, false)\r\n            geometry.applyMatrix4(originHelper.matrixWorld)\r\n\r\n            // compute a color\r\n            const hue = THREE.MathUtils.lerp(0.7, 0.3, amount)\r\n            const saturation = 1\r\n            const lightness = THREE.MathUtils.lerp(0.4, 1.0, amount)\r\n            color.setHSL(hue, saturation, lightness)\r\n            // get the colors as an array of values from 0 to 255\r\n            const rgb = color.toArray().map((v) => v * 255)\r\n\r\n            // make an array to store colors for each vertex\r\n            const numVerts = geometry.getAttribute('position').count\r\n            const itemSize = 3 // r, g, b\r\n            const colors = new Uint8Array(itemSize * numVerts)\r\n\r\n            // copy the color into the colors array for each vertex\r\n            colors.forEach((v, ndx) => {\r\n              colors[ndx] = rgb[ndx % 3]\r\n            })\r\n\r\n            const normalized = true\r\n            const colorAttrib = new THREE.BufferAttribute(\r\n              colors,\r\n              itemSize,\r\n              normalized\r\n            )\r\n            geometry.setAttribute('color', colorAttrib)\r\n\r\n            geometries.push(geometry)\r\n          })\r\n        })\r\n        const mergedGeometry = mergeBufferGeometries(geometries, false)\r\n        const material = new THREE.MeshBasicMaterial({\r\n          vertexColors: true,\r\n        })\r\n        const mesh = new THREE.Mesh(mergedGeometry, material)\r\n        scene.add(mesh)\r\n      }\r\n\r\n      loadFile(\r\n        'https://threejsfundamentals.org/threejs/resources/data/gpw/gpw_v4_basic_demographic_characteristics_rev10_a000_014mt_2010_cntm_1_deg.asc'\r\n      )\r\n        .then(parseData)\r\n        .then(addBoxes)\r\n        .then(render)\r\n\r\n      function resizeRendererToDisplaySize(renderer) {\r\n        const canvas = renderer.domElement\r\n        const width = canvas.clientWidth\r\n        const height = canvas.clientHeight\r\n        const needResize = canvas.width !== width || canvas.height !== height\r\n        if (needResize) {\r\n          renderer.setSize(width, height, false)\r\n        }\r\n        return needResize\r\n      }\r\n\r\n      let renderRequested = false\r\n\r\n      function render() {\r\n        renderRequested = undefined\r\n\r\n        if (resizeRendererToDisplaySize(renderer)) {\r\n          const canvas = renderer.domElement\r\n          camera.aspect = canvas.clientWidth / canvas.clientHeight\r\n          camera.updateProjectionMatrix()\r\n        }\r\n\r\n        controls.update()\r\n        renderer.render(scene, camera)\r\n      }\r\n      render()\r\n\r\n      function requestRenderIfNotRequested() {\r\n        if (!renderRequested) {\r\n          renderRequested = true\r\n          requestAnimationFrame(render)\r\n        }\r\n      }\r\n\r\n      controls.addEventListener('change', requestRenderIfNotRequested)\r\n      window.addEventListener('resize', requestRenderIfNotRequested)\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.container {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n\r\n#c {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  margin: 0%;\r\n}\r\n</style>\r\n","import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tInterleavedBuffer,\n\tInterleavedBufferAttribute,\n\tTriangleFanDrawMode,\n\tTriangleStripDrawMode,\n\tTrianglesDrawMode,\n\tVector3\n} from 'three';\n\n\nfunction computeTangents( geometry ) {\n\n\tgeometry.computeTangents();\n\tconsole.warn( 'THREE.BufferGeometryUtils: .computeTangents() has been removed. Use BufferGeometry.computeTangents() instead.' );\n\n}\n\n/**\n\t * @param  {Array<BufferGeometry>} geometries\n\t * @param  {Boolean} useGroups\n\t * @return {BufferGeometry}\n\t */\nfunction mergeBufferGeometries( geometries, useGroups = false ) {\n\n\tconst isIndexed = geometries[ 0 ].index !== null;\n\n\tconst attributesUsed = new Set( Object.keys( geometries[ 0 ].attributes ) );\n\tconst morphAttributesUsed = new Set( Object.keys( geometries[ 0 ].morphAttributes ) );\n\n\tconst attributes = {};\n\tconst morphAttributes = {};\n\n\tconst morphTargetsRelative = geometries[ 0 ].morphTargetsRelative;\n\n\tconst mergedGeometry = new BufferGeometry();\n\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\tconst geometry = geometries[ i ];\n\t\tlet attributesCount = 0;\n\n\t\t// ensure that all geometries are indexed, or none\n\n\t\tif ( isIndexed !== ( geometry.index !== null ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather attributes, exit early if they're different\n\n\t\tfor ( const name in geometry.attributes ) {\n\n\t\t\tif ( ! attributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure \"' + name + '\" attribute exists among all geometries, or in none of them.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( attributes[ name ] === undefined ) attributes[ name ] = [];\n\n\t\t\tattributes[ name ].push( geometry.attributes[ name ] );\n\n\t\t\tattributesCount ++;\n\n\t\t}\n\n\t\t// ensure geometries have the same number of attributes\n\n\t\tif ( attributesCount !== attributesUsed.size ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// gather morph attributes, exit early if they're different\n\n\t\tif ( morphTargetsRelative !== geometry.morphTargetsRelative ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tfor ( const name in geometry.morphAttributes ) {\n\n\t\t\tif ( ! morphAttributesUsed.has( name ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tif ( morphAttributes[ name ] === undefined ) morphAttributes[ name ] = [];\n\n\t\t\tmorphAttributes[ name ].push( geometry.morphAttributes[ name ] );\n\n\t\t}\n\n\t\t// gather .userData\n\n\t\tmergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || [];\n\t\tmergedGeometry.userData.mergedUserData.push( geometry.userData );\n\n\t\tif ( useGroups ) {\n\n\t\t\tlet count;\n\n\t\t\tif ( isIndexed ) {\n\n\t\t\t\tcount = geometry.index.count;\n\n\t\t\t} else if ( geometry.attributes.position !== undefined ) {\n\n\t\t\t\tcount = geometry.attributes.position.count;\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.addGroup( offset, count, i );\n\n\t\t\toffset += count;\n\n\t\t}\n\n\t}\n\n\t// merge indices\n\n\tif ( isIndexed ) {\n\n\t\tlet indexOffset = 0;\n\t\tconst mergedIndex = [];\n\n\t\tfor ( let i = 0; i < geometries.length; ++ i ) {\n\n\t\t\tconst index = geometries[ i ].index;\n\n\t\t\tfor ( let j = 0; j < index.count; ++ j ) {\n\n\t\t\t\tmergedIndex.push( index.getX( j ) + indexOffset );\n\n\t\t\t}\n\n\t\t\tindexOffset += geometries[ i ].attributes.position.count;\n\n\t\t}\n\n\t\tmergedGeometry.setIndex( mergedIndex );\n\n\t}\n\n\t// merge attributes\n\n\tfor ( const name in attributes ) {\n\n\t\tconst mergedAttribute = mergeBufferAttributes( attributes[ name ] );\n\n\t\tif ( ! mergedAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tmergedGeometry.setAttribute( name, mergedAttribute );\n\n\t}\n\n\t// merge morph attributes\n\n\tfor ( const name in morphAttributes ) {\n\n\t\tconst numMorphTargets = morphAttributes[ name ][ 0 ].length;\n\n\t\tif ( numMorphTargets === 0 ) break;\n\n\t\tmergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};\n\t\tmergedGeometry.morphAttributes[ name ] = [];\n\n\t\tfor ( let i = 0; i < numMorphTargets; ++ i ) {\n\n\t\t\tconst morphAttributesToMerge = [];\n\n\t\t\tfor ( let j = 0; j < morphAttributes[ name ].length; ++ j ) {\n\n\t\t\t\tmorphAttributesToMerge.push( morphAttributes[ name ][ j ][ i ] );\n\n\t\t\t}\n\n\t\t\tconst mergedMorphAttribute = mergeBufferAttributes( morphAttributesToMerge );\n\n\t\t\tif ( ! mergedMorphAttribute ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' morphAttribute.' );\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tmergedGeometry.morphAttributes[ name ].push( mergedMorphAttribute );\n\n\t\t}\n\n\t}\n\n\treturn mergedGeometry;\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nfunction mergeBufferAttributes( attributes ) {\n\n\tlet TypedArray;\n\tlet itemSize;\n\tlet normalized;\n\tlet arrayLength = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( itemSize === undefined ) itemSize = attribute.itemSize;\n\t\tif ( itemSize !== attribute.itemSize ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( normalized === undefined ) normalized = attribute.normalized;\n\t\tif ( normalized !== attribute.normalized ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\n\t}\n\n\tconst array = new TypedArray( arrayLength );\n\tlet offset = 0;\n\n\tfor ( let i = 0; i < attributes.length; ++ i ) {\n\n\t\tarray.set( attributes[ i ].array, offset );\n\n\t\toffset += attributes[ i ].array.length;\n\n\t}\n\n\treturn new BufferAttribute( array, itemSize, normalized );\n\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nfunction interleaveAttributes( attributes ) {\n\n\t// Interleaves the provided attributes into an InterleavedBuffer and returns\n\t// a set of InterleavedBufferAttributes for each attribute\n\tlet TypedArray;\n\tlet arrayLength = 0;\n\tlet stride = 0;\n\n\t// calculate the the length and type of the interleavedBuffer\n\tfor ( let i = 0, l = attributes.length; i < l; ++ i ) {\n\n\t\tconst attribute = attributes[ i ];\n\n\t\tif ( TypedArray === undefined ) TypedArray = attribute.array.constructor;\n\t\tif ( TypedArray !== attribute.array.constructor ) {\n\n\t\t\tconsole.error( 'AttributeBuffers of different types cannot be interleaved' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tarrayLength += attribute.array.length;\n\t\tstride += attribute.itemSize;\n\n\t}\n\n\t// Create the set of buffer attributes\n\tconst interleavedBuffer = new InterleavedBuffer( new TypedArray( arrayLength ), stride );\n\tlet offset = 0;\n\tconst res = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\tconst setters = [ 'setX', 'setY', 'setZ', 'setW' ];\n\n\tfor ( let j = 0, l = attributes.length; j < l; j ++ ) {\n\n\t\tconst attribute = attributes[ j ];\n\t\tconst itemSize = attribute.itemSize;\n\t\tconst count = attribute.count;\n\t\tconst iba = new InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, attribute.normalized );\n\t\tres.push( iba );\n\n\t\toffset += itemSize;\n\n\t\t// Move the data for each attribute into the new interleavedBuffer\n\t\t// at the appropriate offset\n\t\tfor ( let c = 0; c < count; c ++ ) {\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\tiba[ setters[ k ] ]( c, attribute[ getters[ k ] ]( c ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\treturn res;\n\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nfunction estimateBytesUsed( geometry ) {\n\n\t// Return the estimated memory used by this geometry in bytes\n\t// Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n\t// for InterleavedBufferAttributes.\n\tlet mem = 0;\n\tfor ( const name in geometry.attributes ) {\n\n\t\tconst attr = geometry.getAttribute( name );\n\t\tmem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;\n\n\t}\n\n\tconst indices = geometry.getIndex();\n\tmem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;\n\treturn mem;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nfunction mergeVertices( geometry, tolerance = 1e-4 ) {\n\n\ttolerance = Math.max( tolerance, Number.EPSILON );\n\n\t// Generate an index buffer if the geometry doesn't have one, or optimize it\n\t// if it's already available.\n\tconst hashToIndex = {};\n\tconst indices = geometry.getIndex();\n\tconst positions = geometry.getAttribute( 'position' );\n\tconst vertexCount = indices ? indices.count : positions.count;\n\n\t// next value for triangle indices\n\tlet nextIndex = 0;\n\n\t// attributes and new attribute arrays\n\tconst attributeNames = Object.keys( geometry.attributes );\n\tconst attrArrays = {};\n\tconst morphAttrsArrays = {};\n\tconst newIndices = [];\n\tconst getters = [ 'getX', 'getY', 'getZ', 'getW' ];\n\n\t// initialize the arrays\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\n\t\tattrArrays[ name ] = [];\n\n\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\tif ( morphAttr ) {\n\n\t\t\tmorphAttrsArrays[ name ] = new Array( morphAttr.length ).fill().map( () => [] );\n\n\t\t}\n\n\t}\n\n\t// convert the error tolerance to an amount of decimal places to truncate to\n\tconst decimalShift = Math.log10( 1 / tolerance );\n\tconst shiftMultiplier = Math.pow( 10, decimalShift );\n\tfor ( let i = 0; i < vertexCount; i ++ ) {\n\n\t\tconst index = indices ? indices.getX( i ) : i;\n\n\t\t// Generate a hash for the vertex attributes at the current index 'i'\n\t\tlet hash = '';\n\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t// double tilde truncates the decimal value\n\t\t\t\thash += `${ ~ ~ ( attribute[ getters[ k ] ]( index ) * shiftMultiplier ) },`;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// Add another reference to the vertex if it's already\n\t\t// used by another index\n\t\tif ( hash in hashToIndex ) {\n\n\t\t\tnewIndices.push( hashToIndex[ hash ] );\n\n\t\t} else {\n\n\t\t\t// copy data to the new index in the attribute arrays\n\t\t\tfor ( let j = 0, l = attributeNames.length; j < l; j ++ ) {\n\n\t\t\t\tconst name = attributeNames[ j ];\n\t\t\t\tconst attribute = geometry.getAttribute( name );\n\t\t\t\tconst morphAttr = geometry.morphAttributes[ name ];\n\t\t\t\tconst itemSize = attribute.itemSize;\n\t\t\t\tconst newarray = attrArrays[ name ];\n\t\t\t\tconst newMorphArrays = morphAttrsArrays[ name ];\n\n\t\t\t\tfor ( let k = 0; k < itemSize; k ++ ) {\n\n\t\t\t\t\tconst getterFunc = getters[ k ];\n\t\t\t\t\tnewarray.push( attribute[ getterFunc ]( index ) );\n\n\t\t\t\t\tif ( morphAttr ) {\n\n\t\t\t\t\t\tfor ( let m = 0, ml = morphAttr.length; m < ml; m ++ ) {\n\n\t\t\t\t\t\t\tnewMorphArrays[ m ].push( morphAttr[ m ][ getterFunc ]( index ) );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thashToIndex[ hash ] = nextIndex;\n\t\t\tnewIndices.push( nextIndex );\n\t\t\tnextIndex ++;\n\n\t\t}\n\n\t}\n\n\t// Generate typed arrays from new attribute arrays and update\n\t// the attributeBuffers\n\tconst result = geometry.clone();\n\tfor ( let i = 0, l = attributeNames.length; i < l; i ++ ) {\n\n\t\tconst name = attributeNames[ i ];\n\t\tconst oldAttribute = geometry.getAttribute( name );\n\n\t\tconst buffer = new oldAttribute.array.constructor( attrArrays[ name ] );\n\t\tconst attribute = new BufferAttribute( buffer, oldAttribute.itemSize, oldAttribute.normalized );\n\n\t\tresult.setAttribute( name, attribute );\n\n\t\t// Update the attribute arrays\n\t\tif ( name in morphAttrsArrays ) {\n\n\t\t\tfor ( let j = 0; j < morphAttrsArrays[ name ].length; j ++ ) {\n\n\t\t\t\tconst oldMorphAttribute = geometry.morphAttributes[ name ][ j ];\n\n\t\t\t\tconst buffer = new oldMorphAttribute.array.constructor( morphAttrsArrays[ name ][ j ] );\n\t\t\t\tconst morphAttribute = new BufferAttribute( buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized );\n\t\t\t\tresult.morphAttributes[ name ][ j ] = morphAttribute;\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\t// indices\n\n\tresult.setIndex( newIndices );\n\n\treturn result;\n\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry>}\n */\nfunction toTrianglesDrawMode( geometry, drawMode ) {\n\n\tif ( drawMode === TrianglesDrawMode ) {\n\n\t\tconsole.warn( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.' );\n\t\treturn geometry;\n\n\t}\n\n\tif ( drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode ) {\n\n\t\tlet index = geometry.getIndex();\n\n\t\t// generate index if not present\n\n\t\tif ( index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tconst position = geometry.getAttribute( 'position' );\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0; i < position.count; i ++ ) {\n\n\t\t\t\t\tindices.push( i );\n\n\t\t\t\t}\n\n\t\t\t\tgeometry.setIndex( indices );\n\t\t\t\tindex = geometry.getIndex();\n\n\t\t\t} else {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );\n\t\t\t\treturn geometry;\n\n\t\t\t}\n\n\t\t}\n\n\t\t//\n\n\t\tconst numberOfTriangles = index.count - 2;\n\t\tconst newIndices = [];\n\n\t\tif ( drawMode === TriangleFanDrawMode ) {\n\n\t\t\t// gl.TRIANGLE_FAN\n\n\t\t\tfor ( let i = 1; i <= numberOfTriangles; i ++ ) {\n\n\t\t\t\tnewIndices.push( index.getX( 0 ) );\n\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// gl.TRIANGLE_STRIP\n\n\t\t\tfor ( let i = 0; i < numberOfTriangles; i ++ ) {\n\n\t\t\t\tif ( i % 2 === 0 ) {\n\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tnewIndices.push( index.getX( i + 2 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i + 1 ) );\n\t\t\t\t\tnewIndices.push( index.getX( i ) );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( ( newIndices.length / 3 ) !== numberOfTriangles ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );\n\n\t\t}\n\n\t\t// build final geometry\n\n\t\tconst newGeometry = geometry.clone();\n\t\tnewGeometry.setIndex( newIndices );\n\t\tnewGeometry.clearGroups();\n\n\t\treturn newGeometry;\n\n\t} else {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode );\n\t\treturn geometry;\n\n\t}\n\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nfunction computeMorphedAttributes( object ) {\n\n\tif ( object.geometry.isBufferGeometry !== true ) {\n\n\t\tconsole.error( 'THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.' );\n\t\treturn null;\n\n\t}\n\n\tconst _vA = new Vector3();\n\tconst _vB = new Vector3();\n\tconst _vC = new Vector3();\n\n\tconst _tempA = new Vector3();\n\tconst _tempB = new Vector3();\n\tconst _tempC = new Vector3();\n\n\tconst _morphA = new Vector3();\n\tconst _morphB = new Vector3();\n\tconst _morphC = new Vector3();\n\n\tfunction _calculateMorphedAttributeData(\n\t\tobject,\n\t\tmaterial,\n\t\tattribute,\n\t\tmorphAttribute,\n\t\tmorphTargetsRelative,\n\t\ta,\n\t\tb,\n\t\tc,\n\t\tmodifiedAttributeArray\n\t) {\n\n\t\t_vA.fromBufferAttribute( attribute, a );\n\t\t_vB.fromBufferAttribute( attribute, b );\n\t\t_vC.fromBufferAttribute( attribute, c );\n\n\t\tconst morphInfluences = object.morphTargetInfluences;\n\n\t\tif ( material.morphTargets && morphAttribute && morphInfluences ) {\n\n\t\t\t_morphA.set( 0, 0, 0 );\n\t\t\t_morphB.set( 0, 0, 0 );\n\t\t\t_morphC.set( 0, 0, 0 );\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst influence = morphInfluences[ i ];\n\t\t\t\tconst morph = morphAttribute[ i ];\n\n\t\t\t\tif ( influence === 0 ) continue;\n\n\t\t\t\t_tempA.fromBufferAttribute( morph, a );\n\t\t\t\t_tempB.fromBufferAttribute( morph, b );\n\t\t\t\t_tempC.fromBufferAttribute( morph, c );\n\n\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA, influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB, influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC, influence );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t_morphA.addScaledVector( _tempA.sub( _vA ), influence );\n\t\t\t\t\t_morphB.addScaledVector( _tempB.sub( _vB ), influence );\n\t\t\t\t\t_morphC.addScaledVector( _tempC.sub( _vC ), influence );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_vA.add( _morphA );\n\t\t\t_vB.add( _morphB );\n\t\t\t_vC.add( _morphC );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) {\n\n\t\t\tobject.boneTransform( a, _vA );\n\t\t\tobject.boneTransform( b, _vB );\n\t\t\tobject.boneTransform( c, _vC );\n\n\t\t}\n\n\t\tmodifiedAttributeArray[ a * 3 + 0 ] = _vA.x;\n\t\tmodifiedAttributeArray[ a * 3 + 1 ] = _vA.y;\n\t\tmodifiedAttributeArray[ a * 3 + 2 ] = _vA.z;\n\t\tmodifiedAttributeArray[ b * 3 + 0 ] = _vB.x;\n\t\tmodifiedAttributeArray[ b * 3 + 1 ] = _vB.y;\n\t\tmodifiedAttributeArray[ b * 3 + 2 ] = _vB.z;\n\t\tmodifiedAttributeArray[ c * 3 + 0 ] = _vC.x;\n\t\tmodifiedAttributeArray[ c * 3 + 1 ] = _vC.y;\n\t\tmodifiedAttributeArray[ c * 3 + 2 ] = _vC.z;\n\n\t}\n\n\tconst geometry = object.geometry;\n\tconst material = object.material;\n\n\tlet a, b, c;\n\tconst index = geometry.index;\n\tconst positionAttribute = geometry.attributes.position;\n\tconst morphPosition = geometry.morphAttributes.position;\n\tconst morphTargetsRelative = geometry.morphTargetsRelative;\n\tconst normalAttribute = geometry.attributes.normal;\n\tconst morphNormal = geometry.morphAttributes.position;\n\n\tconst groups = geometry.groups;\n\tconst drawRange = geometry.drawRange;\n\tlet i, j, il, jl;\n\tlet group, groupMaterial;\n\tlet start, end;\n\n\tconst modifiedPosition = new Float32Array( positionAttribute.count * positionAttribute.itemSize );\n\tconst modifiedNormal = new Float32Array( normalAttribute.count * normalAttribute.itemSize );\n\n\tif ( index !== null ) {\n\n\t\t// indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = index.getX( j );\n\t\t\t\t\tb = index.getX( j + 1 );\n\t\t\t\t\tc = index.getX( j + 2 );\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( index.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = index.getX( i );\n\t\t\t\tb = index.getX( i + 1 );\n\t\t\t\tc = index.getX( i + 2 );\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t} else if ( positionAttribute !== undefined ) {\n\n\t\t// non-indexed buffer geometry\n\n\t\tif ( Array.isArray( material ) ) {\n\n\t\t\tfor ( i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\t\tgroup = groups[ i ];\n\t\t\t\tgroupMaterial = material[ group.materialIndex ];\n\n\t\t\t\tstart = Math.max( group.start, drawRange.start );\n\t\t\t\tend = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );\n\n\t\t\t\tfor ( j = start, jl = end; j < jl; j += 3 ) {\n\n\t\t\t\t\ta = j;\n\t\t\t\t\tb = j + 1;\n\t\t\t\t\tc = j + 2;\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tpositionAttribute,\n\t\t\t\t\t\tmorphPosition,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedPosition\n\t\t\t\t\t);\n\n\t\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\t\tobject,\n\t\t\t\t\t\tgroupMaterial,\n\t\t\t\t\t\tnormalAttribute,\n\t\t\t\t\t\tmorphNormal,\n\t\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\t\ta, b, c,\n\t\t\t\t\t\tmodifiedNormal\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tstart = Math.max( 0, drawRange.start );\n\t\t\tend = Math.min( positionAttribute.count, ( drawRange.start + drawRange.count ) );\n\n\t\t\tfor ( i = start, il = end; i < il; i += 3 ) {\n\n\t\t\t\ta = i;\n\t\t\t\tb = i + 1;\n\t\t\t\tc = i + 2;\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tpositionAttribute,\n\t\t\t\t\tmorphPosition,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedPosition\n\t\t\t\t);\n\n\t\t\t\t_calculateMorphedAttributeData(\n\t\t\t\t\tobject,\n\t\t\t\t\tmaterial,\n\t\t\t\t\tnormalAttribute,\n\t\t\t\t\tmorphNormal,\n\t\t\t\t\tmorphTargetsRelative,\n\t\t\t\t\ta, b, c,\n\t\t\t\t\tmodifiedNormal\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tconst morphedPositionAttribute = new Float32BufferAttribute( modifiedPosition, 3 );\n\tconst morphedNormalAttribute = new Float32BufferAttribute( modifiedNormal, 3 );\n\n\treturn {\n\n\t\tpositionAttribute: positionAttribute,\n\t\tnormalAttribute: normalAttribute,\n\t\tmorphedPositionAttribute: morphedPositionAttribute,\n\t\tmorphedNormalAttribute: morphedNormalAttribute\n\n\t};\n\n}\n\n\n\nexport {\n\tcomputeTangents,\n\tmergeBufferGeometries,\n\tmergeBufferAttributes,\n\tinterleaveAttributes,\n\testimateBytesUsed,\n\tmergeVertices,\n\ttoTrianglesDrawMode,\n\tcomputeMorphedAttributes,\n};\n","import { render } from \"./optimizing_lots_of_objects.vue?vue&type=template&id=1beabe6c&scoped=true\"\nimport script from \"./optimizing_lots_of_objects.vue?vue&type=script&lang=js\"\nexport * from \"./optimizing_lots_of_objects.vue?vue&type=script&lang=js\"\n\nimport \"./optimizing_lots_of_objects.vue?vue&type=style&index=0&id=1beabe6c&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-1beabe6c\"]])\n\nexport default __exports__"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","mergeBufferGeometries","geometries","useGroups","isIndexed","index","attributesUsed","Set","Object","keys","attributes","morphAttributesUsed","morphAttributes","morphTargetsRelative","mergedGeometry","BufferGeometry","offset","i","length","geometry","attributesCount","console","error","name","has","undefined","push","size","userData","mergedUserData","count","position","addGroup","indexOffset","mergedIndex","j","getX","setIndex","mergedAttribute","mergeBufferAttributes","setAttribute","numMorphTargets","morphAttributesToMerge","mergedMorphAttribute","TypedArray","itemSize","normalized","arrayLength","attribute","isInterleavedBufferAttribute","array","constructor","set","BufferAttribute","mounted","this","init","methods","canvas","document","querySelector","renderer","THREE","antialias","fov","aspect","near","far","camera","z","controls","OrbitControls","enableDamping","enablePan","minDistance","maxDistance","update","scene","background","loader","texture","load","render","material","map","add","async","loadFile","url","req","fetch","text","parseData","data","settings","max","min","split","forEach","line","parts","trim","parseFloat","values","v","value","NODATA_value","Math","assign","addBoxes","file","range","lonHelper","latHelper","positionHelper","originHelper","color","lonFudge","PI","latFudge","row","latNdx","lonNdx","amount","boxWidth","boxHeight","boxDepth","rotation","y","xllcorner","x","yllcorner","scale","updateWorldMatrix","applyMatrix4","matrixWorld","hue","saturation","lightness","setHSL","rgb","toArray","numVerts","getAttribute","colors","Uint8Array","ndx","colorAttrib","vertexColors","mesh","resizeRendererToDisplaySize","domElement","width","clientWidth","height","clientHeight","needResize","setSize","then","renderRequested","updateProjectionMatrix","requestRenderIfNotRequested","requestAnimationFrame","addEventListener","window","__exports__"],"sourceRoot":""}