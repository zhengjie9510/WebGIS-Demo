{"version":3,"file":"js/2833.6057b720.js","mappings":"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","sources":["webpack://webgis/./src/components/three/map_3d.vue","webpack://webgis/./src/components/three/map_3d.vue?937f","webpack://webgis/./node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["<template>\r\n  <div class=\"container\"><canvas id=\"c\"></canvas></div>\r\n</template>\r\n<script>\r\nimport * as THREE from 'three'\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { Reflector } from 'three/examples/jsm/objects/Reflector'\r\nconst chinaJson = require('../../../public/SampleData/china-mercator.json')\r\nlet mirror = undefined\r\nexport default {\r\n  mounted() {\r\n    this.init()\r\n  },\r\n  methods: {\r\n    init() {\r\n      const canvas = document.querySelector('#c')\r\n\r\n      const scene = new THREE.Scene()\r\n      const camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 0.1, 1000000000)\r\n      camera.position.set(0, -10000000, 10000000)\r\n      camera.lookAt(0, 0, 0)\r\n      scene.add(camera)\r\n\r\n      const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, logarithmicDepthBuffer: true });\r\n      renderer.setSize(canvas.innerWidth, canvas.innerHeight)\r\n      renderer.setPixelRatio(window.devicePixelRatio)\r\n      const controls = new OrbitControls(camera, renderer.domElement);\r\n      const ambientlight = new THREE.AmbientLight(0xffffff, 0.2);\r\n      scene.add(ambientlight);\r\n      const directionalLight = new THREE.DirectionalLight(0xffffff)\r\n      directionalLight.position.set(1, -1, 1)\r\n      scene.add(directionalLight)\r\n\r\n      chinaJson.features.forEach((elem, index) => {\r\n        const { coordinates } = elem.geometry;\r\n        coordinates.forEach(multiPolygon => {\r\n          const province = new THREE.Object3D();\r\n          const lines = new THREE.Object3D();\r\n          multiPolygon.forEach((polygon) => {\r\n            const shape = new THREE.Shape();\r\n            const points = [];\r\n            for (let i = 0; i < polygon.length; i++) {\r\n              let [x, y] = polygon[i];\r\n              x = x - 11600000\r\n              y = y - 4000000\r\n              if (i === 0) {\r\n                shape.moveTo(x, y);\r\n                points.push(new THREE.Vector3(x, y, 200001));\r\n              }\r\n              shape.lineTo(x, y);\r\n              points.push(new THREE.Vector3(x, y, 200001));\r\n            }\r\n\r\n            const extrudeSettings = {\r\n              steps: 2,\r\n              depth: 200000,\r\n              bevelEnabled: true,\r\n            };\r\n            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\r\n            const material1 = new THREE.MeshPhongMaterial({ color: '#02A1E2', transparent: true, opacity: 0.9 });\r\n            const material2 = new THREE.MeshPhongMaterial({ color: '#3480C4', transparent: true, opacity: 0.9 });\r\n            const mesh = new THREE.Mesh(geometry, [material1, material2]);\r\n            province.add(mesh)\r\n\r\n            const lineGeometry = new THREE.BufferGeometry().setFromPoints(points)\r\n            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xffffff })\r\n            const lineMesh = new THREE.Line(lineGeometry, lineMaterial);\r\n            lines.add(lineMesh)\r\n          })\r\n          scene.add(province)\r\n          scene.add(lines)\r\n        })\r\n      })\r\n\r\n      const geometry = new THREE.PlaneGeometry(400000000, 400000000);\r\n      mirror = new Reflector(geometry, {\r\n        clipBias: 0.001,\r\n        textureWidth: canvas.innerWidth * window.devicePixelRatio,\r\n        textureHeight: canvas.innerHeight * window.devicePixelRatio,\r\n      });\r\n      mirror.position.z = -200000;\r\n      mirror.rotateX(- Math.PI / 50)\r\n      // scene.add(mirror);\r\n\r\n      animate();\r\n      function animate() {\r\n        if (resizeRendererToDisplaySize(renderer)) {\r\n          const canvas = renderer.domElement\r\n          camera.aspect = canvas.clientWidth / canvas.clientHeight\r\n          camera.updateProjectionMatrix()\r\n        }\r\n        controls.update();\r\n        renderer.render(scene, camera);\r\n        requestAnimationFrame(animate);\r\n      }\r\n\r\n      function resizeRendererToDisplaySize(renderer) {\r\n        const canvas = renderer.domElement\r\n        const width = canvas.clientWidth\r\n        const height = canvas.clientHeight\r\n        const needResize = canvas.width !== width || canvas.height !== height\r\n        if (needResize) {\r\n          renderer.setSize(width, height, false)\r\n          mirror.getRenderTarget().setSize(\r\n            width * window.devicePixelRatio,\r\n            height * window.devicePixelRatio\r\n          );\r\n        }\r\n        return needResize\r\n      }\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.container {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n\r\n#c {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  margin: 0%;\r\n}\r\n</style>\r\n","import { render } from \"./map_3d.vue?vue&type=template&id=74eb6666&scoped=true\"\nimport script from \"./map_3d.vue?vue&type=script&lang=js\"\nexport * from \"./map_3d.vue?vue&type=script&lang=js\"\n\nimport \"./map_3d.vue?vue&type=style&index=0&id=74eb6666&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-74eb6666\"]])\n\nexport default __exports__","import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.type = 'Reflector';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = new PerspectiveCamera();\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.prototype.isReflector = true;\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Reflector };\n"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","chinaJson","require","mirror","mounted","this","init","methods","canvas","document","querySelector","scene","THREE","camera","clientWidth","clientHeight","position","set","lookAt","add","renderer","antialias","logarithmicDepthBuffer","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","controls","OrbitControls","domElement","ambientlight","directionalLight","features","forEach","elem","index","coordinates","geometry","multiPolygon","province","lines","polygon","shape","points","i","length","x","y","moveTo","push","lineTo","extrudeSettings","steps","depth","bevelEnabled","material1","color","transparent","opacity","material2","mesh","lineGeometry","setFromPoints","lineMaterial","lineMesh","animate","resizeRendererToDisplaySize","aspect","updateProjectionMatrix","update","render","requestAnimationFrame","width","height","needResize","getRenderTarget","Reflector","clipBias","textureWidth","textureHeight","z","rotateX","Math","PI","__exports__","Mesh","constructor","options","super","type","scope","undefined","Color","shader","ReflectorShader","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","renderTarget","WebGLRenderTarget","material","ShaderMaterial","uniforms","UniformsUtils","fragmentShader","vertexShader","value","texture","onBeforeRender","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","dot","reflect","negate","copy","up","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","constant","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","setMask","autoClear","clear","viewport","dispose","prototype","isReflector"],"sourceRoot":""}