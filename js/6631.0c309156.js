"use strict";(self["webpackChunkwebgis"]=self["webpackChunkwebgis"]||[]).push([[6631],{26631:function(t,e,n){n.r(e),n.d(e,{default:function(){return P}});var i=n(73396);const s=t=>((0,i.dD)("data-v-39c6d57a"),t=t(),(0,i.Cn)(),t),r={class:"container"},o=s((()=>(0,i._)("canvas",{id:"c"},null,-1))),a=[o];function h(t,e,n,s,o,h){return(0,i.wg)(),(0,i.iD)("div",r,a)}n(57658),n(63408),n(14590);var l=n(11114);const d={uFreq:new l.xWb(new l.Pa4(3,6,10)),uAmp:new l.xWb(new l.Pa4(30,30,20))},c=t=>.5*Math.sin(t)+.5,u={uniforms:d,getDistortion:"\n                uniform vec3 uAmp;\n                uniform vec3 uFreq;\n\n                #define PI 3.14159265358979\n                float nsin(float val){\n                    return sin(val) * 0.5+0.5;\n                }\n                \n                vec3 getDistortion(float progress){\n                    float movementProgressFix = 0.02;\n                    return vec3( \n                        cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n                        nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n                        nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n                    );\n                }\n            ",getJS:(t,e)=>{let n=.02,i=d.uFreq.value,s=d.uAmp.value,r=new l.Pa4(Math.cos(t*Math.PI*i.x+e)*s.x-Math.cos(n*Math.PI*i.x+e)*s.x,c(t*Math.PI*i.y+e)*s.y-c(n*Math.PI*i.y+e)*s.y,c(t*Math.PI*i.z+e)*s.z-c(n*Math.PI*i.z+e)*s.z),o=new l.Pa4(2,2,2),a=new l.Pa4(0,0,-5);return r.multiply(o).add(a)}};class m{constructor(t,e){this.options=e,this.canvas=t,this.clock=new l.SUY,this.renderer=new l.CP7({canvas:this.canvas,antialias:!0}),this.renderer.setSize(this.canvas.innerWidth,this.canvas.innerHeight),this.renderer.setPixelRatio(window.devicePixelRatio),this.scene=new l.xsS,this.camera=new l.cPb(45,this.canvas.clientWidth/this.canvas.clientHeight,.1,1e4),this.camera.position.z=-5,this.camera.position.y=7,this.camera.position.x=0,this.onMouseDown=this.onMouseDown.bind(this),this.onMouseUp=this.onMouseUp.bind(this),this.canvas.addEventListener("mousedown",this.onMouseDown),this.canvas.addEventListener("mouseup",this.onMouseUp),this.canvas.addEventListener("mouseout",this.onMouseUp),this.init()}init(){const t=this.options;this.speedUpTarget=0,this.speedUp=0,this.timeOffset=0,this.fovTarget=90,this.road=new f(this.scene,t),this.leftLights=new p(this.scene,t,t.color.leftCars,60),this.leftLights.mesh.position.setX(-t.roadWidth/2-t.islandWidth/2),this.rightLights=new p(this.scene,t,t.color.rightCars,-60),this.rightLights.mesh.position.setX(t.roadWidth/2+t.islandWidth/2),this.leftSticks=new g(this.scene,t),this.leftSticks.mesh.position.setX(-(t.roadWidth+t.islandWidth/2))}update(t){let e=-60*Math.log2(.9),n=Math.exp(-e*t);this.speedUp+=x(this.speedUp,this.speedUpTarget,n,1e-5),this.timeOffset+=this.speedUp*t;let i=this.clock.elapsedTime+this.timeOffset;this.road.update(i),this.leftLights.update(i),this.rightLights.update(i),this.leftSticks.update(i);let s=x(this.camera.fov,this.fovTarget,n);if(0!==s&&(this.camera.fov+=s*t*6,this.camera.updateProjectionMatrix()),this.options.distortion.getJS){const t=this.options.distortion.getJS(.025,i);this.camera.lookAt(new l.Pa4(this.camera.position.x+t.x,this.camera.position.y+t.y,this.camera.position.z+t.z))}}onMouseDown(t){this.speedUpTarget=4,this.fovTarget=140}onMouseUp(t){this.speedUpTarget=0,this.fovTarget=90}resizeRendererToDisplaySize(t){const e=t.domElement,n=e.clientWidth,i=e.clientHeight,s=e.width!==n||e.height!==i;return s&&t.setSize(n,i,!1),s}render(){if(this.resizeRendererToDisplaySize(this.renderer)){const t=this.renderer.domElement;this.camera.aspect=t.clientWidth/t.clientHeight,this.camera.updateProjectionMatrix()}const t=this.clock.getDelta();this.update(t),this.renderer.render(this.scene,this.camera),requestAnimationFrame(this.render.bind(this))}}class f{constructor(t,e){this.scene=t,this.options=e,this.init()}init(){const t=this.options,e=new l.BKK(t.width,t.length,20,200),n=new l.jyz({uniforms:Object.assign({uColor:new l.xWb(new l.Ilk(1052690)),uTime:new l.xWb(0),uTravelLength:new l.xWb(t.length)},t.distortion.uniforms),vertexShader:"\n                uniform float uTravelLength;\n                uniform float uTime;\n                #include <getDistortion_vertex>\n                void main(){\n                    vec3 transformed = position.xyz;\n                        \n                    float progress = (transformed.y + uTravelLength / 2.) / uTravelLength;\n                    vec3 distortion  = getDistortion(progress);\n                    transformed.x += distortion.x;\n                    transformed.z += distortion.y;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.);\n                }\n                ",fragmentShader:"\n                uniform vec3 uColor;\n                void main(){\n                    gl_FragColor = vec4(uColor,1.);\n                }\n                ",side:l.ehD});n.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>",t.distortion.getDistortion)};const i=new l.Kj0(e,n);i.rotation.x=-Math.PI/2,i.position.z=-t.length/2,this.scene.add(i),this.mesh=i}update(t){this.mesh.material.uniforms.uTime.value=t}}class p{constructor(t,e,n,i){this.scene=t,this.options=e,this.colors=n,this.speed=i,this.init()}init(){const t=this.options,e=new l.U7(new l.Pa4(0,0,0),new l.Pa4(0,0,-1)),n=new l.Lcc(e,25,1,8,!1),i=(new l.L5s).copy(n);i.instanceCount=2*t.nPairs;let s=[],r=[],o=[],a=this.colors;a=Array.isArray(a)?a.map((t=>new l.Ilk(t))):new l.Ilk(a);let h=t.roadWidth/t.roadSections;for(let l=0;l<t.nPairs;l++){let e=.1*Math.random()+.1,n=Math.random()*t.length*.08+.02*t.length,i=l%3,d=i*h-t.roadWidth/2+h/2,c=.5*h,u=.5*Math.random(),m=1.3*e,f=Math.random()*t.length;s.push(d-c/2+u),s.push(m),s.push(-f),s.push(d+c/2+u),s.push(m),s.push(-f),r.push(e),r.push(n),r.push(e),r.push(n);let p=w(a);o.push(p.r),o.push(p.g),o.push(p.b),o.push(p.r),o.push(p.g),o.push(p.b)}i.setAttribute("aOffset",new l.lb7(new Float32Array(s),3,!1)),i.setAttribute("aMetrics",new l.lb7(new Float32Array(r),2,!1)),i.setAttribute("aColor",new l.lb7(new Float32Array(o),3,!1));const d=new l.jyz({fragmentShader:"\n                in vec3 vColor;\n                void main() {\n                    gl_FragColor = vec4(vColor,1.);\n                }\n                ",vertexShader:"\n                in vec3 aOffset;\n                in vec2 aMetrics;\n                in vec3 aColor;\n                out vec3 vColor;\n                uniform float uTime;\n                uniform float uSpeed;\n                uniform float uTravelLength;\n                #include <getDistortion_vertex>\n                void main() {\n                    vec3 transformed = position.xyz;\n\n                    float radius = aMetrics.r;\n                    float len = aMetrics.g;\n                    transformed.xy *= radius; \n                    transformed.z *= len;\n\n                    float zOffset = uTime * uSpeed + aOffset.z;\n                    zOffset = len - mod(zOffset, uTravelLength);\n\n                    // transformed.z +=uTime * uSpeed;\n\n\n                    // Keep them separated to make the next step easier!\n                    transformed.z = transformed.z +zOffset ;\n                    transformed.xy += aOffset.xy;\n\n\n                    float progress = abs(transformed.z / uTravelLength);\n                    transformed.xyz += getDistortion(progress);\n\n                    vColor = aColor;\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n                    gl_Position = projectionMatrix * mvPosition;\n                }",uniforms:Object.assign({uColor:new l.xWb(new l.Ilk(this.color)),uTravelLength:new l.xWb(t.length),uTime:new l.xWb(0),uSpeed:new l.xWb(this.speed)},t.distortion.uniforms)});d.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>",t.distortion.getDistortion)};let c=new l.Kj0(i,d);c.frustumCulled=!1,this.mesh=c,this.scene.add(c)}update(t){this.mesh.material.uniforms.uTime.value=t}}class g{constructor(t,e){this.scene=t,this.options=e,this.init()}init(){const t=this.options,e=new l.BKK(1,1);let n=(new l.L5s).copy(e),i=t.totalSideLightSticks;n.instanceCount=i;let s=t.length/(i-1);const r=[],o=[],a=[];let h=this.options.color.sticks;h=Array.isArray(h)?h.map((t=>new l.Ilk(t))):new l.Ilk(h);for(let l=0;l<i;l++){let e=v(t.lightStickWidth),n=v(t.lightStickHeight);r.push((l-1)*s*2+s*Math.random());let i=w(h);o.push(i.r),o.push(i.g),o.push(i.b),a.push(e),a.push(n)}n.setAttribute("aOffset",new l.lb7(new Float32Array(r),1,!1)),n.setAttribute("aColor",new l.lb7(new Float32Array(o),3,!1)),n.setAttribute("aMetrics",new l.lb7(new Float32Array(a),2,!1));const d=new l.jyz({fragmentShader:"\n                varying vec3 vColor;\n                void main(){\n                    vec3 color = vec3(vColor);\n                    gl_FragColor = vec4(color,1.);\n                }\n                ",vertexShader:"\n                attribute float aOffset;\n                attribute vec3 aColor;\n\n                attribute vec2 aMetrics;\n\n                uniform float uTravelLength;\n                uniform float uTime;\n\n                varying vec3 vColor;\n                mat4 rotationY( in float angle ) {\n                    return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n                                            0,\t\t1.0,\t\t\t 0,\t0,\n                                    -sin(angle),\t0,\t\tcos(angle),\t0,\n                                            0, \t\t0,\t\t\t\t0,\t1);\n                }\n\n                #include <getDistortion_vertex>\n                void main(){\n                    vec3 transformed = position.xyz;\n                    float width = aMetrics.x;\n                    float height = aMetrics.y;\n\n                    transformed.xy *= vec2(width,height);\n                    float time = mod(uTime  * 60. *2. + aOffset , uTravelLength);\n\n                    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n\n                    transformed.z +=  - uTravelLength + time;\n\n\n                    float progress = abs(transformed.z / uTravelLength);\n                    transformed.xyz += getDistortion(progress);\n\n                    transformed.y += height /2.;\n                    transformed.x += -width/2.;\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n                    gl_Position = projectionMatrix * mvPosition;\n                    vColor = aColor;\n                }\n                ",side:l.ehD,uniforms:Object.assign({uTravelLength:new l.xWb(t.length),uTime:new l.xWb(0)},t.distortion.uniforms)});d.onBeforeCompile=e=>{e.vertexShader=e.vertexShader.replace("#include <getDistortion_vertex>",t.distortion.getDistortion)};const c=new l.Kj0(n,d);c.frustumCulled=!1,this.scene.add(c),this.mesh=c}update(t){this.mesh.material.uniforms.uTime.value=t}}function v(t){return Array.isArray(t)?Math.random()*(t[1]-t[0])+t[0]:Math.random()*t}function w(t){return Array.isArray(t)?t[Math.floor(Math.random()*t.length)]:t}function x(t,e,n=.1,i=.001){let s=(e-t)*n;return Math.abs(s)<i&&(s=e-t),s}var y={mounted(){this.init()},methods:{init(){const t=document.querySelector("#c"),e={length:400,width:20,roadWidth:9,islandWidth:2,nPairs:50,roadSections:3,distortion:u,totalSideLightSticks:50,lightStickWidth:[.12,.5],lightStickHeight:[1.3,1.7],color:{leftCars:[16715818,15415358,16715818],rightCars:[14342906,12499683,9410532],sticks:14342906}},n=new m(t,e);n.render()}}},M=n(40089);const b=(0,M.Z)(y,[["render",h],["__scopeId","data-v-39c6d57a"]]);var P=b}}]);
//# sourceMappingURL=6631.0c309156.js.map