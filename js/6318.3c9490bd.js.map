{"version":3,"file":"js/6318.3c9490bd.js","mappings":"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","sources":["webpack://webgis/./src/components/public/dynamic_water.vue","webpack://webgis/./node_modules/@cesium/engine/Source/Shaders/Appearances/EllipsoidSurfaceAppearanceFS.js","webpack://webgis/./node_modules/@cesium/engine/Source/Shaders/Appearances/EllipsoidSurfaceAppearanceVS.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/EllipsoidSurfaceAppearance.js","webpack://webgis/./src/components/public/dynamic_water.vue?ee5b"],"sourcesContent":["<template>\n  <div id=\"cesiumContainer\"></div>\n</template>\n\n<script>\nimport 'cesium/Build/Cesium/Widgets/widgets.css'\nimport * as Cesium from 'cesium'\n\nexport default {\n  mounted() {\n    this.init()\n  },\n  methods: {\n    async init() {\n      var viewer = new Cesium.Viewer('cesiumContainer', { terrainProvider: await Cesium.createWorldTerrainAsync() })\n      if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {\n        viewer.resolutionScale = window.devicePixelRatio\n      }\n      viewer.scene.postProcessStages.fxaa.enabled = true\n      viewer.scene.globe.depthTestAgainstTerrain = true\n\n      viewer.scene.primitives.add(\n        new Cesium.Primitive({\n          geometryInstances: new Cesium.GeometryInstance({\n            geometry: new Cesium.RectangleGeometry({\n              rectangle: Cesium.Rectangle.fromDegrees(\n                103.30, 29.25,\n                103.45, 29.35\n              ),\n              height: 1000 - 470,\n              vertexFormat: Cesium.VertexFormat.DEFAULT,\n            }),\n          }),\n          appearance: new Cesium.EllipsoidSurfaceAppearance({\n            material: new Cesium.Material({\n              fabric: {\n                type: \"Water\",\n                uniforms: {\n                  baseWaterColor: new Cesium.Color(64 / 255.0, 157 / 255.0, 200 / 255.0, 0.5),\n                  normalMap: Cesium.buildModuleUrl(\"Assets/Textures/waterNormals.jpg\"),\n                  frequency: 1000.0,\n                  animationSpeed: 0.1,\n                  amplitude: 10,\n                  specularIntensity: 10\n                }\n              }\n            })\n          }),\n        })\n      );\n      const center = Cesium.Cartesian3.fromDegrees(103.37, 29.15);\n      viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -47900.0, 39300.0));\n      viewer.camera.lookAtTransform(Cesium.Matrix4.IDENTITY);\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n#cesiumContainer {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n}\n</style>\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec3 v_positionMC;\\n\\\nin vec3 v_positionEC;\\n\\\nin vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    czm_materialInput materialInput;\\n\\\n\\n\\\n    vec3 normalEC = normalize(czm_normal3D * czm_geodeticSurfaceNormal(v_positionMC, vec3(0.0), vec3(1.0)));\\n\\\n#ifdef FACE_FORWARD\\n\\\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\\n\\\n#endif\\n\\\n\\n\\\n    materialInput.s = v_st.s;\\n\\\n    materialInput.st = v_st;\\n\\\n    materialInput.str = vec3(v_st, 0.0);\\n\\\n\\n\\\n    // Convert tangent space material normal to eye space\\n\\\n    materialInput.normalEC = normalEC;\\n\\\n    materialInput.tangentToEyeMatrix = czm_eastNorthUpToEyeCoordinates(v_positionMC, materialInput.normalEC);\\n\\\n\\n\\\n    // Convert view vector to world space\\n\\\n    vec3 positionToEyeEC = -v_positionEC;\\n\\\n    materialInput.positionToEyeEC = positionToEyeEC;\\n\\\n\\n\\\n    czm_material material = czm_getMaterial(materialInput);\\n\\\n\\n\\\n#ifdef FLAT\\n\\\n    out_FragColor = vec4(material.diffuse + material.emission, material.alpha);\\n\\\n#else\\n\\\n    out_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\\n\\\n#endif\\n\\\n}\\n\\\n\";\n","//This file is automatically rebuilt by the Cesium build process.\nexport default \"in vec3 position3DHigh;\\n\\\nin vec3 position3DLow;\\n\\\nin vec2 st;\\n\\\nin float batchId;\\n\\\n\\n\\\nout vec3 v_positionMC;\\n\\\nout vec3 v_positionEC;\\n\\\nout vec2 v_st;\\n\\\n\\n\\\nvoid main()\\n\\\n{\\n\\\n    vec4 p = czm_computePosition();\\n\\\n\\n\\\n    v_positionMC = position3DHigh + position3DLow;           // position in model coordinates\\n\\\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;     // position in eye coordinates\\n\\\n    v_st = st;\\n\\\n\\n\\\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\\n\\\n}\\n\\\n\";\n","import defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport VertexFormat from \"../Core/VertexFormat.js\";\nimport EllipsoidSurfaceAppearanceFS from \"../Shaders/Appearances/EllipsoidSurfaceAppearanceFS.js\";\nimport EllipsoidSurfaceAppearanceVS from \"../Shaders/Appearances/EllipsoidSurfaceAppearanceVS.js\";\nimport Appearance from \"./Appearance.js\";\nimport Material from \"./Material.js\";\n\n/**\n * An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}\n * and {@link RectangleGeometry}, which supports all materials like {@link MaterialAppearance}\n * with {@link MaterialAppearance.MaterialSupport.ALL}.  However, this appearance requires\n * fewer vertex attributes since the fragment shader can procedurally compute <code>normal</code>,\n * <code>tangent</code>, and <code>bitangent</code>.\n *\n * @alias EllipsoidSurfaceAppearance\n * @constructor\n *\n * @param {object} [options] Object with the following properties:\n * @param {boolean} [options.flat=false] When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.\n * @param {boolean} [options.faceForward=options.aboveGround] When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.\n * @param {boolean} [options.translucent=true] When <code>true</code>, the geometry is expected to appear translucent so {@link EllipsoidSurfaceAppearance#renderState} has alpha blending enabled.\n * @param {boolean} [options.aboveGround=false] When <code>true</code>, the geometry is expected to be on the ellipsoid's surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.\n * @param {Material} [options.material=Material.ColorType] The material used to determine the fragment color.\n * @param {string} [options.vertexShaderSource] Optional GLSL vertex shader source to override the default vertex shader.\n * @param {string} [options.fragmentShaderSource] Optional GLSL fragment shader source to override the default fragment shader.\n * @param {object} [options.renderState] Optional render state to override the default render state.\n *\n * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n *\n * @example\n * const primitive = new Cesium.Primitive({\n *   geometryInstances : new Cesium.GeometryInstance({\n *     geometry : new Cesium.PolygonGeometry({\n *       vertexFormat : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,\n *       // ...\n *     })\n *   }),\n *   appearance : new Cesium.EllipsoidSurfaceAppearance({\n *     material : Cesium.Material.fromType('Stripe')\n *   })\n * });\n */\nfunction EllipsoidSurfaceAppearance(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const translucent = defaultValue(options.translucent, true);\n  const aboveGround = defaultValue(options.aboveGround, false);\n\n  /**\n   * The material used to determine the fragment color.  Unlike other {@link EllipsoidSurfaceAppearance}\n   * properties, this is not read-only, so an appearance's material can change on the fly.\n   *\n   * @type Material\n   *\n   * @default {@link Material.ColorType}\n   *\n   * @see {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}\n   */\n  this.material = defined(options.material)\n    ? options.material\n    : Material.fromType(Material.ColorType);\n\n  /**\n   * When <code>true</code>, the geometry is expected to appear translucent.\n   *\n   * @type {boolean}\n   *\n   * @default true\n   */\n  this.translucent = defaultValue(options.translucent, true);\n\n  this._vertexShaderSource = defaultValue(\n    options.vertexShaderSource,\n    EllipsoidSurfaceAppearanceVS\n  );\n  this._fragmentShaderSource = defaultValue(\n    options.fragmentShaderSource,\n    EllipsoidSurfaceAppearanceFS\n  );\n  this._renderState = Appearance.getDefaultRenderState(\n    translucent,\n    !aboveGround,\n    options.renderState\n  );\n  this._closed = false;\n\n  // Non-derived members\n\n  this._flat = defaultValue(options.flat, false);\n  this._faceForward = defaultValue(options.faceForward, aboveGround);\n  this._aboveGround = aboveGround;\n}\n\nObject.defineProperties(EllipsoidSurfaceAppearance.prototype, {\n  /**\n   * The GLSL source code for the vertex shader.\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  vertexShaderSource: {\n    get: function () {\n      return this._vertexShaderSource;\n    },\n  },\n\n  /**\n   * The GLSL source code for the fragment shader.  The full fragment shader\n   * source is built procedurally taking into account {@link EllipsoidSurfaceAppearance#material},\n   * {@link EllipsoidSurfaceAppearance#flat}, and {@link EllipsoidSurfaceAppearance#faceForward}.\n   * Use {@link EllipsoidSurfaceAppearance#getFragmentShaderSource} to get the full source.\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {string}\n   * @readonly\n   */\n  fragmentShaderSource: {\n    get: function () {\n      return this._fragmentShaderSource;\n    },\n  },\n\n  /**\n   * The WebGL fixed-function state to use when rendering the geometry.\n   * <p>\n   * The render state can be explicitly defined when constructing a {@link EllipsoidSurfaceAppearance}\n   * instance, or it is set implicitly via {@link EllipsoidSurfaceAppearance#translucent}\n   * and {@link EllipsoidSurfaceAppearance#aboveGround}.\n   * </p>\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {object}\n   * @readonly\n   */\n  renderState: {\n    get: function () {\n      return this._renderState;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be closed so\n   * {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.\n   * If the viewer enters the geometry, it will not be visible.\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  closed: {\n    get: function () {\n      return this._closed;\n    },\n  },\n\n  /**\n   * The {@link VertexFormat} that this appearance instance is compatible with.\n   * A geometry can have more vertex attributes and still be compatible - at a\n   * potential performance cost - but it can't have less.\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type VertexFormat\n   * @readonly\n   *\n   * @default {@link EllipsoidSurfaceAppearance.VERTEX_FORMAT}\n   */\n  vertexFormat: {\n    get: function () {\n      return EllipsoidSurfaceAppearance.VERTEX_FORMAT;\n    },\n  },\n\n  /**\n   * When <code>true</code>, flat shading is used in the fragment shader,\n   * which means lighting is not taking into account.\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  flat: {\n    get: function () {\n      return this._flat;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the fragment shader flips the surface normal\n   * as needed to ensure that the normal faces the viewer to avoid\n   * dark spots.  This is useful when both sides of a geometry should be\n   * shaded like {@link WallGeometry}.\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default true\n   */\n  faceForward: {\n    get: function () {\n      return this._faceForward;\n    },\n  },\n\n  /**\n   * When <code>true</code>, the geometry is expected to be on the ellipsoid's\n   * surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState}\n   * has backface culling enabled.\n   *\n   *\n   * @memberof EllipsoidSurfaceAppearance.prototype\n   *\n   * @type {boolean}\n   * @readonly\n   *\n   * @default false\n   */\n  aboveGround: {\n    get: function () {\n      return this._aboveGround;\n    },\n  },\n});\n\n/**\n * The {@link VertexFormat} that all {@link EllipsoidSurfaceAppearance} instances\n * are compatible with, which requires only <code>position</code> and <code>st</code>\n * attributes.  Other attributes are procedurally computed in the fragment shader.\n *\n * @type VertexFormat\n *\n * @constant\n */\nEllipsoidSurfaceAppearance.VERTEX_FORMAT = VertexFormat.POSITION_AND_ST;\n\n/**\n * Procedurally creates the full GLSL fragment shader source.  For {@link EllipsoidSurfaceAppearance},\n * this is derived from {@link EllipsoidSurfaceAppearance#fragmentShaderSource}, {@link EllipsoidSurfaceAppearance#flat},\n * and {@link EllipsoidSurfaceAppearance#faceForward}.\n *\n * @function\n *\n * @returns {string} The full GLSL fragment shader source.\n */\nEllipsoidSurfaceAppearance.prototype.getFragmentShaderSource =\n  Appearance.prototype.getFragmentShaderSource;\n\n/**\n * Determines if the geometry is translucent based on {@link EllipsoidSurfaceAppearance#translucent} and {@link Material#isTranslucent}.\n *\n * @function\n *\n * @returns {boolean} <code>true</code> if the appearance is translucent.\n */\nEllipsoidSurfaceAppearance.prototype.isTranslucent =\n  Appearance.prototype.isTranslucent;\n\n/**\n * Creates a render state.  This is not the final render state instance; instead,\n * it can contain a subset of render state properties identical to the render state\n * created in the context.\n *\n * @function\n *\n * @returns {object} The render state.\n */\nEllipsoidSurfaceAppearance.prototype.getRenderState =\n  Appearance.prototype.getRenderState;\nexport default EllipsoidSurfaceAppearance;\n","import { render } from \"./dynamic_water.vue?vue&type=template&id=66df443c&scoped=true\"\nimport script from \"./dynamic_water.vue?vue&type=script&lang=js\"\nexport * from \"./dynamic_water.vue?vue&type=script&lang=js\"\n\nimport \"./dynamic_water.vue?vue&type=style&index=0&id=66df443c&lang=scss&scoped=true\"\n\nimport exportComponent from \"/Users/zhengjie/Documents/webgis/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-66df443c\"]])\n\nexport default __exports__"],"names":["id","_createElementBlock","_hoisted_1","EllipsoidSurfaceAppearance","options","defaultValue","translucent","aboveGround","this","material","defined","Material","_vertexShaderSource","vertexShaderSource","EllipsoidSurfaceAppearanceVS","_fragmentShaderSource","fragmentShaderSource","EllipsoidSurfaceAppearanceFS","_renderState","Appearance","renderState","_closed","_flat","flat","_faceForward","faceForward","_aboveGround","Object","defineProperties","prototype","get","closed","vertexFormat","VERTEX_FORMAT","VertexFormat","getFragmentShaderSource","isTranslucent","getRenderState","mounted","init","methods","async","viewer","Cesium","terrainProvider","resolutionScale","window","devicePixelRatio","scene","postProcessStages","fxaa","enabled","globe","depthTestAgainstTerrain","primitives","add","geometryInstances","geometry","rectangle","height","appearance","fabric","type","uniforms","baseWaterColor","normalMap","frequency","animationSpeed","amplitude","specularIntensity","center","camera","lookAt","lookAtTransform","__exports__","render"],"sourceRoot":""}