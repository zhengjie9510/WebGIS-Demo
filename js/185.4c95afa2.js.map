{"version":3,"file":"js/185.4c95afa2.js","mappings":"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","sources":["webpack://webgis/./src/components/cesium/dynamic_building.vue","webpack://webgis/./node_modules/cesium/Source/Core/getFilenameFromUri.js","webpack://webgis/./node_modules/cesium/Source/Core/PinBuilder.js","webpack://webgis/./node_modules/topojson-client/src/reverse.js","webpack://webgis/./node_modules/topojson-client/src/identity.js","webpack://webgis/./node_modules/topojson-client/src/transform.js","webpack://webgis/./node_modules/topojson-client/src/feature.js","webpack://webgis/./node_modules/cesium/Source/DataSources/GeoJsonDataSource.js","webpack://webgis/./src/components/cesium/plugins/PolygonGeometry.js","webpack://webgis/./src/components/cesium/dynamic_building.vue?090c"],"sourcesContent":["<template>\r\n  <div id=\"cesiumContainer\"></div>\r\n</template>\r\n\r\n<script>\r\nimport 'cesium/Build/Cesium/Widgets/widgets.css'\r\nimport {\r\n  Viewer,\r\n  FeatureDetection,\r\n  MaterialAppearance,\r\n  GeometryInstance,\r\n  Primitive,\r\n  Material,\r\n  Color,\r\n  GeoJsonDataSource,\r\n  Cartesian3,\r\n  Matrix4\r\n} from 'cesium'\r\nimport { default as PolygonGeometry } from './plugins/PolygonGeometry'\r\nconst building = '../../SampleData/building.json'\r\n\r\nexport default {\r\n  mounted() {\r\n    this.init()\r\n  },\r\n  methods: {\r\n    init() {\r\n      var viewer = new Viewer('cesiumContainer')\r\n      if (FeatureDetection.supportsImageRenderingPixelated()) {\r\n        //判断是否支持图像渲染像素化处理\r\n        viewer.resolutionScale = window.devicePixelRatio\r\n      }\r\n      viewer.scene.postProcessStages.fxaa.enabled = true\r\n      const scene = viewer.scene\r\n\r\n      const fragmentShaderSource = `\r\n        uniform float offset2;\r\n        uniform float offset1;\r\n        uniform vec4 color;\r\n        const float pi = 3.1415926;\r\n        czm_material czm_getMaterial(czm_materialInput materialInput)\r\n        {\r\n          czm_material material = czm_getDefaultMaterial(materialInput);\r\n          vec2 st = materialInput.st;\r\n\r\n          material.diffuse = czm_gammaCorrect(color.rgb); \r\n          // material.diffuse = vec3(st.t,st.t,st.t);\r\n          float a = abs(cos(st.t * pi * 3.0));\r\n          if(a<=0.2){\r\n            material.diffuse = vec3(189.0/255.0,196.0/255.0,210.0/255.0);\r\n          }\r\n          if(st.t> offset1-offset2 && st.t< offset1+offset2)\r\n          {\r\n            material.emission=vec3(0.7);\r\n          }\r\n          material.alpha = 1.0; \r\n          return material;\r\n        }\r\n        `\r\n\r\n      GeoJsonDataSource.load(building).then((dataSource) => {\r\n        const entities = dataSource.entities.values\r\n        const geometryInstances = []\r\n        for (const entity of entities) {\r\n          const polygon = new PolygonGeometry({\r\n            polygonHierarchy: entity.polygon.hierarchy.getValue(),\r\n            extrudedHeight: Math.random() * 40 + 10,\r\n          })\r\n          const geometry = PolygonGeometry.createGeometry(polygon)\r\n          const geometryInstance = new GeometryInstance({\r\n            geometry: geometry,\r\n          })\r\n          geometryInstances.push(geometryInstance)\r\n        }\r\n        const primitive = scene.primitives.add(\r\n          new Primitive({\r\n            asynchronous: false,\r\n            geometryInstances: geometryInstances,\r\n            appearance: new MaterialAppearance({\r\n              material: new Material({\r\n                translucent: false,\r\n                fabric: {\r\n                  uniforms: {\r\n                    color: new Color(87 / 255, 122 / 255, 150 / 255),\r\n                    offset1: 0.02,\r\n                    offset2: 0.02,\r\n                  },\r\n                  source: fragmentShaderSource\r\n                },\r\n              }),\r\n            }),\r\n          })\r\n        )\r\n\r\n        // 动态修改材质中的offset变量，从而实现动态效果。\r\n        viewer.scene.preUpdate.addEventListener(function () {\r\n          var offset = primitive.appearance.material.uniforms.offset1\r\n          offset += 0.01\r\n          if (offset > 0.98) {\r\n            offset = 0.02\r\n          }\r\n          primitive.appearance.material.uniforms.offset1 = offset\r\n        })\r\n        const center = Cartesian3.fromDegrees(104.06, 30.66);\r\n        viewer.camera.lookAt(center, new Cartesian3(0.0, -4790.0, 3930.0));\r\n        viewer.camera.lookAtTransform(Matrix4.IDENTITY);\r\n      })\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n#cesiumContainer {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n</style>\r\n","import Uri from \"urijs\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\n\n/**\n * Given a URI, returns the last segment of the URI, removing any path or query information.\n * @function getFilenameFromUri\n *\n * @param {String} uri The Uri.\n * @returns {String} The last segment of the Uri.\n *\n * @example\n * //fileName will be\"simple.czml\";\n * const fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');\n */\nfunction getFilenameFromUri(uri) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(uri)) {\n    throw new DeveloperError(\"uri is required.\");\n  }\n  //>>includeEnd('debug');\n\n  const uriObject = new Uri(uri);\n  uriObject.normalize();\n  let path = uriObject.path();\n  const index = path.lastIndexOf(\"/\");\n  if (index !== -1) {\n    path = path.substr(index + 1);\n  }\n  return path;\n}\nexport default getFilenameFromUri;\n","import buildModuleUrl from \"./buildModuleUrl.js\";\nimport Color from \"./Color.js\";\nimport defined from \"./defined.js\";\nimport DeveloperError from \"./DeveloperError.js\";\nimport Resource from \"./Resource.js\";\nimport writeTextToCanvas from \"./writeTextToCanvas.js\";\n\n/**\n * A utility class for generating custom map pins as canvas elements.\n * <br /><br />\n * <div align='center'>\n * <img src='Images/PinBuilder.png' width='500'/><br />\n * Example pins generated using both the maki icon set, which ships with Cesium, and single character text.\n * </div>\n *\n * @alias PinBuilder\n * @constructor\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Map%20Pins.html|Cesium Sandcastle PinBuilder Demo}\n */\nfunction PinBuilder() {\n  this._cache = {};\n}\n\n/**\n * Creates an empty pin of the specified color and size.\n *\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement} The canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromColor = function (color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n  return createPin(undefined, undefined, color, size, this._cache);\n};\n\n/**\n * Creates a pin with the specified icon, color, and size.\n *\n * @param {Resource|String} url The url of the image to be stamped onto the pin.\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement|Promise.<HTMLCanvasElement>} The canvas element or a Promise to the canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromUrl = function (url, color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(url)) {\n    throw new DeveloperError(\"url is required\");\n  }\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n  return createPin(url, undefined, color, size, this._cache);\n};\n\n/**\n * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.\n *\n * @param {String} id The id of the maki icon to be stamped onto the pin.\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement|Promise.<HTMLCanvasElement>} The canvas element or a Promise to the canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromMakiIconId = function (id, color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(id)) {\n    throw new DeveloperError(\"id is required\");\n  }\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n  return createPin(\n    buildModuleUrl(`Assets/Textures/maki/${encodeURIComponent(id)}.png`),\n    undefined,\n    color,\n    size,\n    this._cache\n  );\n};\n\n/**\n * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible\n * while still being contained completely within the pin.\n *\n * @param {String} text The text to be stamped onto the pin.\n * @param {Color} color The color of the pin.\n * @param {Number} size The size of the pin, in pixels.\n * @returns {HTMLCanvasElement} The canvas element that represents the generated pin.\n */\nPinBuilder.prototype.fromText = function (text, color, size) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(text)) {\n    throw new DeveloperError(\"text is required\");\n  }\n  if (!defined(color)) {\n    throw new DeveloperError(\"color is required\");\n  }\n  if (!defined(size)) {\n    throw new DeveloperError(\"size is required\");\n  }\n  //>>includeEnd('debug');\n\n  return createPin(undefined, text, color, size, this._cache);\n};\n\nconst colorScratch = new Color();\n\n//This function (except for the 3 commented lines) was auto-generated from an online tool,\n//http://www.professorcloud.com/svg-to-canvas/, using Assets/Textures/pin.svg as input.\n//The reason we simply can't load and draw the SVG directly to the canvas is because\n//it taints the canvas in Internet Explorer (and possibly some other browsers); making\n//it impossible to create a WebGL texture from the result.\nfunction drawPin(context2D, color, size) {\n  context2D.save();\n  context2D.scale(size / 24, size / 24); //Added to auto-generated code to scale up to desired size.\n  context2D.fillStyle = color.toCssColorString(); //Modified from auto-generated code.\n  context2D.strokeStyle = color.brighten(0.6, colorScratch).toCssColorString(); //Modified from auto-generated code.\n  context2D.lineWidth = 0.846;\n  context2D.beginPath();\n  context2D.moveTo(6.72, 0.422);\n  context2D.lineTo(17.28, 0.422);\n  context2D.bezierCurveTo(18.553, 0.422, 19.577, 1.758, 19.577, 3.415);\n  context2D.lineTo(19.577, 10.973);\n  context2D.bezierCurveTo(19.577, 12.63, 18.553, 13.966, 17.282, 13.966);\n  context2D.lineTo(14.386, 14.008);\n  context2D.lineTo(11.826, 23.578);\n  context2D.lineTo(9.614, 14.008);\n  context2D.lineTo(6.719, 13.965);\n  context2D.bezierCurveTo(5.446, 13.983, 4.422, 12.629, 4.422, 10.972);\n  context2D.lineTo(4.422, 3.416);\n  context2D.bezierCurveTo(4.423, 1.76, 5.447, 0.423, 6.718, 0.423);\n  context2D.closePath();\n  context2D.fill();\n  context2D.stroke();\n  context2D.restore();\n}\n\n//This function takes an image or canvas and uses it as a template\n//to \"stamp\" the pin with a white image outlined in black.  The color\n//values of the input image are ignored completely and only the alpha\n//values are used.\nfunction drawIcon(context2D, image, size) {\n  //Size is the largest image that looks good inside of pin box.\n  const imageSize = size / 2.5;\n  let sizeX = imageSize;\n  let sizeY = imageSize;\n\n  if (image.width > image.height) {\n    sizeY = imageSize * (image.height / image.width);\n  } else if (image.width < image.height) {\n    sizeX = imageSize * (image.width / image.height);\n  }\n\n  //x and y are the center of the pin box\n  const x = Math.round((size - sizeX) / 2);\n  const y = Math.round((7 / 24) * size - sizeY / 2);\n\n  context2D.globalCompositeOperation = \"destination-out\";\n  context2D.drawImage(image, x - 1, y, sizeX, sizeY);\n  context2D.drawImage(image, x, y - 1, sizeX, sizeY);\n  context2D.drawImage(image, x + 1, y, sizeX, sizeY);\n  context2D.drawImage(image, x, y + 1, sizeX, sizeY);\n\n  context2D.globalCompositeOperation = \"destination-over\";\n  context2D.fillStyle = Color.BLACK.toCssColorString();\n  context2D.fillRect(x - 1, y - 1, sizeX + 2, sizeY + 2);\n\n  context2D.globalCompositeOperation = \"destination-out\";\n  context2D.drawImage(image, x, y, sizeX, sizeY);\n\n  context2D.globalCompositeOperation = \"destination-over\";\n  context2D.fillStyle = Color.WHITE.toCssColorString();\n  context2D.fillRect(x - 1, y - 2, sizeX + 2, sizeY + 2);\n}\n\nconst stringifyScratch = new Array(4);\nfunction createPin(url, label, color, size, cache) {\n  //Use the parameters as a unique ID for caching.\n  stringifyScratch[0] = url;\n  stringifyScratch[1] = label;\n  stringifyScratch[2] = color;\n  stringifyScratch[3] = size;\n  const id = JSON.stringify(stringifyScratch);\n\n  const item = cache[id];\n  if (defined(item)) {\n    return item;\n  }\n\n  const canvas = document.createElement(\"canvas\");\n  canvas.width = size;\n  canvas.height = size;\n\n  const context2D = canvas.getContext(\"2d\");\n  drawPin(context2D, color, size);\n\n  if (defined(url)) {\n    const resource = Resource.createIfNeeded(url);\n\n    //If we have an image url, load it and then stamp the pin.\n    const promise = resource.fetchImage().then(function (image) {\n      drawIcon(context2D, image, size);\n      cache[id] = canvas;\n      return canvas;\n    });\n    cache[id] = promise;\n    return promise;\n  } else if (defined(label)) {\n    //If we have a label, write it to a canvas and then stamp the pin.\n    const image = writeTextToCanvas(label, {\n      font: `bold ${size}px sans-serif`,\n    });\n    drawIcon(context2D, image, size);\n  }\n\n  cache[id] = canvas;\n  return canvas;\n}\nexport default PinBuilder;\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","export default function(x) {\n  return x;\n}\n","import identity from \"./identity.js\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import reverse from \"./reverse.js\";\nimport transform from \"./transform.js\";\n\nexport default function(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nfunction feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","import ArcType from \"../Core/ArcType.js\";\nimport Cartesian3 from \"../Core/Cartesian3.js\";\nimport Color from \"../Core/Color.js\";\nimport createGuid from \"../Core/createGuid.js\";\nimport Credit from \"../Core/Credit.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport DeveloperError from \"../Core/DeveloperError.js\";\nimport Event from \"../Core/Event.js\";\nimport getFilenameFromUri from \"../Core/getFilenameFromUri.js\";\nimport PinBuilder from \"../Core/PinBuilder.js\";\nimport PolygonHierarchy from \"../Core/PolygonHierarchy.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport HeightReference from \"../Scene/HeightReference.js\";\nimport VerticalOrigin from \"../Scene/VerticalOrigin.js\";\nimport * as topojson from \"topojson-client\";\nimport BillboardGraphics from \"./BillboardGraphics.js\";\nimport CallbackProperty from \"./CallbackProperty.js\";\nimport ColorMaterialProperty from \"./ColorMaterialProperty.js\";\nimport ConstantPositionProperty from \"./ConstantPositionProperty.js\";\nimport ConstantProperty from \"./ConstantProperty.js\";\nimport DataSource from \"./DataSource.js\";\nimport EntityCluster from \"./EntityCluster.js\";\nimport EntityCollection from \"./EntityCollection.js\";\nimport PolygonGraphics from \"./PolygonGraphics.js\";\nimport PolylineGraphics from \"./PolylineGraphics.js\";\n\nfunction defaultCrsFunction(coordinates) {\n  return Cartesian3.fromDegrees(coordinates[0], coordinates[1], coordinates[2]);\n}\n\nconst crsNames = {\n  \"urn:ogc:def:crs:OGC:1.3:CRS84\": defaultCrsFunction,\n  \"EPSG:4326\": defaultCrsFunction,\n  \"urn:ogc:def:crs:EPSG::4326\": defaultCrsFunction,\n};\n\nconst crsLinkHrefs = {};\nconst crsLinkTypes = {};\nlet defaultMarkerSize = 48;\nlet defaultMarkerSymbol;\nlet defaultMarkerColor = Color.ROYALBLUE;\nlet defaultStroke = Color.YELLOW;\nlet defaultStrokeWidth = 2;\nlet defaultFill = Color.fromBytes(255, 255, 0, 100);\nlet defaultClampToGround = false;\n\nconst sizes = {\n  small: 24,\n  medium: 48,\n  large: 64,\n};\n\nconst simpleStyleIdentifiers = [\n  \"title\",\n  \"description\", //\n  \"marker-size\",\n  \"marker-symbol\",\n  \"marker-color\",\n  \"stroke\", //\n  \"stroke-opacity\",\n  \"stroke-width\",\n  \"fill\",\n  \"fill-opacity\",\n];\n\nfunction defaultDescribe(properties, nameProperty) {\n  let html = \"\";\n  for (const key in properties) {\n    if (properties.hasOwnProperty(key)) {\n      if (key === nameProperty || simpleStyleIdentifiers.indexOf(key) !== -1) {\n        continue;\n      }\n      const value = properties[key];\n      if (defined(value)) {\n        if (typeof value === \"object\") {\n          html += `<tr><th>${key}</th><td>${defaultDescribe(value)}</td></tr>`;\n        } else {\n          html += `<tr><th>${key}</th><td>${value}</td></tr>`;\n        }\n      }\n    }\n  }\n\n  if (html.length > 0) {\n    html = `<table class=\"cesium-infoBox-defaultTable\"><tbody>${html}</tbody></table>`;\n  }\n\n  return html;\n}\n\nfunction createDescriptionCallback(describe, properties, nameProperty) {\n  let description;\n  return function (time, result) {\n    if (!defined(description)) {\n      description = describe(properties, nameProperty);\n    }\n    return description;\n  };\n}\n\nfunction defaultDescribeProperty(properties, nameProperty) {\n  return new CallbackProperty(\n    createDescriptionCallback(defaultDescribe, properties, nameProperty),\n    true\n  );\n}\n\n//GeoJSON specifies only the Feature object has a usable id property\n//But since \"multi\" geometries create multiple entity,\n//we can't use it for them either.\nfunction createObject(geoJson, entityCollection, describe) {\n  let id = geoJson.id;\n  if (!defined(id) || geoJson.type !== \"Feature\") {\n    id = createGuid();\n  } else {\n    let i = 2;\n    let finalId = id;\n    while (defined(entityCollection.getById(finalId))) {\n      finalId = `${id}_${i}`;\n      i++;\n    }\n    id = finalId;\n  }\n\n  const entity = entityCollection.getOrCreateEntity(id);\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    entity.properties = properties;\n\n    let nameProperty;\n\n    //Check for the simplestyle specified name first.\n    const name = properties.title;\n    if (defined(name)) {\n      entity.name = name;\n      nameProperty = \"title\";\n    } else {\n      //Else, find the name by selecting an appropriate property.\n      //The name will be obtained based on this order:\n      //1) The first case-insensitive property with the name 'title',\n      //2) The first case-insensitive property with the name 'name',\n      //3) The first property containing the word 'title'.\n      //4) The first property containing the word 'name',\n      let namePropertyPrecedence = Number.MAX_VALUE;\n      for (const key in properties) {\n        if (properties.hasOwnProperty(key) && properties[key]) {\n          const lowerKey = key.toLowerCase();\n\n          if (namePropertyPrecedence > 1 && lowerKey === \"title\") {\n            namePropertyPrecedence = 1;\n            nameProperty = key;\n            break;\n          } else if (namePropertyPrecedence > 2 && lowerKey === \"name\") {\n            namePropertyPrecedence = 2;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 3 && /title/i.test(key)) {\n            namePropertyPrecedence = 3;\n            nameProperty = key;\n          } else if (namePropertyPrecedence > 4 && /name/i.test(key)) {\n            namePropertyPrecedence = 4;\n            nameProperty = key;\n          }\n        }\n      }\n      if (defined(nameProperty)) {\n        entity.name = properties[nameProperty];\n      }\n    }\n\n    const description = properties.description;\n    if (description !== null) {\n      entity.description = !defined(description)\n        ? describe(properties, nameProperty)\n        : new ConstantProperty(description);\n    }\n  }\n  return entity;\n}\n\nfunction coordinatesArrayToCartesianArray(coordinates, crsFunction) {\n  const positions = new Array(coordinates.length);\n  for (let i = 0; i < coordinates.length; i++) {\n    positions[i] = crsFunction(coordinates[i]);\n  }\n  return positions;\n}\n\nconst geoJsonObjectTypes = {\n  Feature: processFeature,\n  FeatureCollection: processFeatureCollection,\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology,\n};\n\nconst geometryTypes = {\n  GeometryCollection: processGeometryCollection,\n  LineString: processLineString,\n  MultiLineString: processMultiLineString,\n  MultiPoint: processMultiPoint,\n  MultiPolygon: processMultiPolygon,\n  Point: processPoint,\n  Polygon: processPolygon,\n  Topology: processTopology,\n};\n\n// GeoJSON processing functions\nfunction processFeature(dataSource, feature, notUsed, crsFunction, options) {\n  if (feature.geometry === null) {\n    //Null geometry is allowed, so just create an empty entity instance for it.\n    createObject(feature, dataSource._entityCollection, options.describe);\n    return;\n  }\n\n  if (!defined(feature.geometry)) {\n    throw new RuntimeError(\"feature.geometry is required.\");\n  }\n\n  const geometryType = feature.geometry.type;\n  const geometryHandler = geometryTypes[geometryType];\n  if (!defined(geometryHandler)) {\n    throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n  }\n  geometryHandler(dataSource, feature, feature.geometry, crsFunction, options);\n}\n\nfunction processFeatureCollection(\n  dataSource,\n  featureCollection,\n  notUsed,\n  crsFunction,\n  options\n) {\n  const features = featureCollection.features;\n  for (let i = 0, len = features.length; i < len; i++) {\n    processFeature(dataSource, features[i], undefined, crsFunction, options);\n  }\n}\n\nfunction processGeometryCollection(\n  dataSource,\n  geoJson,\n  geometryCollection,\n  crsFunction,\n  options\n) {\n  const geometries = geometryCollection.geometries;\n  for (let i = 0, len = geometries.length; i < len; i++) {\n    const geometry = geometries[i];\n    const geometryType = geometry.type;\n    const geometryHandler = geometryTypes[geometryType];\n    if (!defined(geometryHandler)) {\n      throw new RuntimeError(`Unknown geometry type: ${geometryType}`);\n    }\n    geometryHandler(dataSource, geoJson, geometry, crsFunction, options);\n  }\n}\n\nfunction createPoint(dataSource, geoJson, crsFunction, coordinates, options) {\n  let symbol = options.markerSymbol;\n  let color = options.markerColor;\n  let size = options.markerSize;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const cssColor = properties[\"marker-color\"];\n    if (defined(cssColor)) {\n      color = Color.fromCssColorString(cssColor);\n    }\n\n    size = defaultValue(sizes[properties[\"marker-size\"]], size);\n    const markerSymbol = properties[\"marker-symbol\"];\n    if (defined(markerSymbol)) {\n      symbol = markerSymbol;\n    }\n  }\n\n  let canvasOrPromise;\n  if (defined(symbol)) {\n    if (symbol.length === 1) {\n      canvasOrPromise = dataSource._pinBuilder.fromText(\n        symbol.toUpperCase(),\n        color,\n        size\n      );\n    } else {\n      canvasOrPromise = dataSource._pinBuilder.fromMakiIconId(\n        symbol,\n        color,\n        size\n      );\n    }\n  } else {\n    canvasOrPromise = dataSource._pinBuilder.fromColor(color, size);\n  }\n\n  const billboard = new BillboardGraphics();\n  billboard.verticalOrigin = new ConstantProperty(VerticalOrigin.BOTTOM);\n\n  // Clamp to ground if there isn't a height specified\n  if (coordinates.length === 2 && options.clampToGround) {\n    billboard.heightReference = HeightReference.CLAMP_TO_GROUND;\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe\n  );\n  entity.billboard = billboard;\n  entity.position = new ConstantPositionProperty(crsFunction(coordinates));\n\n  const promise = Promise.resolve(canvasOrPromise)\n    .then(function (image) {\n      billboard.image = new ConstantProperty(image);\n    })\n    .catch(function () {\n      billboard.image = new ConstantProperty(\n        dataSource._pinBuilder.fromColor(color, size)\n      );\n    });\n\n  dataSource._promises.push(promise);\n}\n\nfunction processPoint(dataSource, geoJson, geometry, crsFunction, options) {\n  createPoint(dataSource, geoJson, crsFunction, geometry.coordinates, options);\n}\n\nfunction processMultiPoint(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  const coordinates = geometry.coordinates;\n  for (let i = 0; i < coordinates.length; i++) {\n    createPoint(dataSource, geoJson, crsFunction, coordinates[i], options);\n  }\n}\n\nfunction createLineString(\n  dataSource,\n  geoJson,\n  crsFunction,\n  coordinates,\n  options\n) {\n  let material = options.strokeMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    const opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = material.color.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n    if (defined(color)) {\n      material = new ColorMaterialProperty(color);\n    }\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe\n  );\n  const polylineGraphics = new PolylineGraphics();\n  entity.polyline = polylineGraphics;\n\n  polylineGraphics.clampToGround = options.clampToGround;\n  polylineGraphics.material = material;\n  polylineGraphics.width = widthProperty;\n  polylineGraphics.positions = new ConstantProperty(\n    coordinatesArrayToCartesianArray(coordinates, crsFunction)\n  );\n  polylineGraphics.arcType = ArcType.RHUMB;\n}\n\nfunction processLineString(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  createLineString(\n    dataSource,\n    geoJson,\n    crsFunction,\n    geometry.coordinates,\n    options\n  );\n}\n\nfunction processMultiLineString(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  const lineStrings = geometry.coordinates;\n  for (let i = 0; i < lineStrings.length; i++) {\n    createLineString(dataSource, geoJson, crsFunction, lineStrings[i], options);\n  }\n}\n\nfunction createPolygon(dataSource, geoJson, crsFunction, coordinates, options) {\n  if (coordinates.length === 0 || coordinates[0].length === 0) {\n    return;\n  }\n\n  let outlineColorProperty = options.strokeMaterialProperty.color;\n  let material = options.fillMaterialProperty;\n  let widthProperty = options.strokeWidthProperty;\n\n  const properties = geoJson.properties;\n  if (defined(properties)) {\n    const width = properties[\"stroke-width\"];\n    if (defined(width)) {\n      widthProperty = new ConstantProperty(width);\n    }\n\n    let color;\n    const stroke = properties.stroke;\n    if (defined(stroke)) {\n      color = Color.fromCssColorString(stroke);\n    }\n    let opacity = properties[\"stroke-opacity\"];\n    if (defined(opacity) && opacity !== 1.0) {\n      if (!defined(color)) {\n        color = outlineColorProperty.getValue().clone();\n      }\n      color.alpha = opacity;\n    }\n\n    if (defined(color)) {\n      outlineColorProperty = new ConstantProperty(color);\n    }\n\n    let fillColor;\n    const fill = properties.fill;\n    const materialColor = material.color.getValue();\n    if (defined(fill)) {\n      fillColor = Color.fromCssColorString(fill);\n      fillColor.alpha = materialColor.alpha;\n    }\n    opacity = properties[\"fill-opacity\"];\n    if (defined(opacity) && opacity !== materialColor.alpha) {\n      if (!defined(fillColor)) {\n        fillColor = materialColor.clone();\n      }\n      fillColor.alpha = opacity;\n    }\n    if (defined(fillColor)) {\n      material = new ColorMaterialProperty(fillColor);\n    }\n  }\n\n  const polygon = new PolygonGraphics();\n  polygon.outline = new ConstantProperty(true);\n  polygon.outlineColor = outlineColorProperty;\n  polygon.outlineWidth = widthProperty;\n  polygon.material = material;\n  polygon.arcType = ArcType.RHUMB;\n\n  const holes = [];\n  for (let i = 1, len = coordinates.length; i < len; i++) {\n    holes.push(\n      new PolygonHierarchy(\n        coordinatesArrayToCartesianArray(coordinates[i], crsFunction)\n      )\n    );\n  }\n\n  const positions = coordinates[0];\n  polygon.hierarchy = new ConstantProperty(\n    new PolygonHierarchy(\n      coordinatesArrayToCartesianArray(positions, crsFunction),\n      holes\n    )\n  );\n  if (positions[0].length > 2) {\n    polygon.perPositionHeight = new ConstantProperty(true);\n  } else if (!options.clampToGround) {\n    polygon.height = 0;\n  }\n\n  const entity = createObject(\n    geoJson,\n    dataSource._entityCollection,\n    options.describe\n  );\n  entity.polygon = polygon;\n}\n\nfunction processPolygon(dataSource, geoJson, geometry, crsFunction, options) {\n  createPolygon(\n    dataSource,\n    geoJson,\n    crsFunction,\n    geometry.coordinates,\n    options\n  );\n}\n\nfunction processMultiPolygon(\n  dataSource,\n  geoJson,\n  geometry,\n  crsFunction,\n  options\n) {\n  const polygons = geometry.coordinates;\n  for (let i = 0; i < polygons.length; i++) {\n    createPolygon(dataSource, geoJson, crsFunction, polygons[i], options);\n  }\n}\n\nfunction processTopology(dataSource, geoJson, geometry, crsFunction, options) {\n  for (const property in geometry.objects) {\n    if (geometry.objects.hasOwnProperty(property)) {\n      const feature = topojson.feature(geometry, geometry.objects[property]);\n      const typeHandler = geoJsonObjectTypes[feature.type];\n      typeHandler(dataSource, feature, feature, crsFunction, options);\n    }\n  }\n}\n\n/**\n * @typedef {Object} GeoJsonDataSource.LoadOptions\n *\n * Initialization options for the <code>load</code> method.\n *\n * @property {String} [sourceUri] Overrides the url to use for resolving relative links.\n * @property {GeoJsonDataSource.describe} [describe=GeoJsonDataSource.defaultDescribeProperty] A function which returns a Property object (or just a string).\n * @property {Number} [markerSize=GeoJsonDataSource.markerSize] The default size of the map pin created for each point, in pixels.\n * @property {String} [markerSymbol=GeoJsonDataSource.markerSymbol] The default symbol of the map pin created for each point.\n * @property {Color} [markerColor=GeoJsonDataSource.markerColor] The default color of the map pin created for each point.\n * @property {Color} [stroke=GeoJsonDataSource.stroke] The default color of polylines and polygon outlines.\n * @property {Number} [strokeWidth=GeoJsonDataSource.strokeWidth] The default width of polylines and polygon outlines.\n * @property {Color} [fill=GeoJsonDataSource.fill] The default color for polygon interiors.\n * @property {Boolean} [clampToGround=GeoJsonDataSource.clampToGround] true if we want the geometry features (polygons or linestrings) clamped to the ground.\n * @property {Credit|String} [credit] A credit for the data source, which is displayed on the canvas.\n */\n\n/**\n * A {@link DataSource} which processes both\n * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.\n * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they\n * are present.\n *\n * @alias GeoJsonDataSource\n * @constructor\n *\n * @param {String} [name] The name of this data source.  If undefined, a name will be taken from\n *                        the name of the GeoJSON file.\n *\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20and%20TopoJSON.html|Cesium Sandcastle GeoJSON and TopoJSON Demo}\n * @demo {@link https://sandcastle.cesium.com/index.html?src=GeoJSON%20simplestyle.html|Cesium Sandcastle GeoJSON simplestyle Demo}\n *\n * @example\n * const viewer = new Cesium.Viewer('cesiumContainer');\n * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {\n *   stroke: Cesium.Color.HOTPINK,\n *   fill: Cesium.Color.PINK,\n *   strokeWidth: 3,\n *   markerSymbol: '?'\n * }));\n */\nfunction GeoJsonDataSource(name) {\n  this._name = name;\n  this._changed = new Event();\n  this._error = new Event();\n  this._isLoading = false;\n  this._loading = new Event();\n  this._entityCollection = new EntityCollection(this);\n  this._promises = [];\n  this._pinBuilder = new PinBuilder();\n  this._entityCluster = new EntityCluster();\n  this._credit = undefined;\n  this._resourceCredits = [];\n}\n\n/**\n * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.\n *\n * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise.<GeoJsonDataSource>} A promise that will resolve when the data is loaded.\n */\nGeoJsonDataSource.load = function (data, options) {\n  return new GeoJsonDataSource().load(data, options);\n};\n\nObject.defineProperties(GeoJsonDataSource, {\n  /**\n   * Gets or sets the default size of the map pin created for each point, in pixels.\n   * @memberof GeoJsonDataSource\n   * @type {Number}\n   * @default 48\n   */\n  markerSize: {\n    get: function () {\n      return defaultMarkerSize;\n    },\n    set: function (value) {\n      defaultMarkerSize = value;\n    },\n  },\n  /**\n   * Gets or sets the default symbol of the map pin created for each point.\n   * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,\n   * or blank if no symbol is to be used.\n   * @memberof GeoJsonDataSource\n   * @type {String}\n   */\n  markerSymbol: {\n    get: function () {\n      return defaultMarkerSymbol;\n    },\n    set: function (value) {\n      defaultMarkerSymbol = value;\n    },\n  },\n  /**\n   * Gets or sets the default color of the map pin created for each point.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.ROYALBLUE\n   */\n  markerColor: {\n    get: function () {\n      return defaultMarkerColor;\n    },\n    set: function (value) {\n      defaultMarkerColor = value;\n    },\n  },\n  /**\n   * Gets or sets the default color of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.BLACK\n   */\n  stroke: {\n    get: function () {\n      return defaultStroke;\n    },\n    set: function (value) {\n      defaultStroke = value;\n    },\n  },\n  /**\n   * Gets or sets the default width of polylines and polygon outlines.\n   * @memberof GeoJsonDataSource\n   * @type {Number}\n   * @default 2.0\n   */\n  strokeWidth: {\n    get: function () {\n      return defaultStrokeWidth;\n    },\n    set: function (value) {\n      defaultStrokeWidth = value;\n    },\n  },\n  /**\n   * Gets or sets default color for polygon interiors.\n   * @memberof GeoJsonDataSource\n   * @type {Color}\n   * @default Color.YELLOW\n   */\n  fill: {\n    get: function () {\n      return defaultFill;\n    },\n    set: function (value) {\n      defaultFill = value;\n    },\n  },\n  /**\n   * Gets or sets default of whether to clamp to the ground.\n   * @memberof GeoJsonDataSource\n   * @type {Boolean}\n   * @default false\n   */\n  clampToGround: {\n    get: function () {\n      return defaultClampToGround;\n    },\n    set: function (value) {\n      defaultClampToGround = value;\n    },\n  },\n\n  /**\n   * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate\n   * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which\n   * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,\n   * for example 'EPSG:4326'.\n   * @memberof GeoJsonDataSource\n   * @type {Object}\n   */\n  crsNames: {\n    get: function () {\n      return crsNames;\n    },\n  },\n\n  /**\n   * Gets an object that maps the href property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming\n   * the link has a type specified.\n   * @memberof GeoJsonDataSource\n   * @type {Object}\n   */\n  crsLinkHrefs: {\n    get: function () {\n      return crsLinkHrefs;\n    },\n  },\n\n  /**\n   * Gets an object that maps the type property of a crs link to a callback function\n   * which takes the crs properties object and returns a Promise that resolves\n   * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.\n   * Items in <code>crsLinkHrefs</code> take precedence over this object.\n   * @memberof GeoJsonDataSource\n   * @type {Object}\n   */\n  crsLinkTypes: {\n    get: function () {\n      return crsLinkTypes;\n    },\n  },\n});\n\nObject.defineProperties(GeoJsonDataSource.prototype, {\n  /**\n   * Gets or sets a human-readable name for this instance.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {String}\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n    set: function (value) {\n      if (this._name !== value) {\n        this._name = value;\n        this._changed.raiseEvent(this);\n      }\n    },\n  },\n  /**\n   * This DataSource only defines static data, therefore this property is always undefined.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {DataSourceClock}\n   */\n  clock: {\n    value: undefined,\n    writable: false,\n  },\n  /**\n   * Gets the collection of {@link Entity} instances.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCollection}\n   */\n  entities: {\n    get: function () {\n      return this._entityCollection;\n    },\n  },\n  /**\n   * Gets a value indicating if the data source is currently loading data.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Boolean}\n   */\n  isLoading: {\n    get: function () {\n      return this._isLoading;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the underlying data changes.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  changedEvent: {\n    get: function () {\n      return this._changed;\n    },\n  },\n  /**\n   * Gets an event that will be raised if an error is encountered during processing.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  errorEvent: {\n    get: function () {\n      return this._error;\n    },\n  },\n  /**\n   * Gets an event that will be raised when the data source either starts or stops loading.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Event}\n   */\n  loadingEvent: {\n    get: function () {\n      return this._loading;\n    },\n  },\n  /**\n   * Gets whether or not this data source should be displayed.\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Boolean}\n   */\n  show: {\n    get: function () {\n      return this._entityCollection.show;\n    },\n    set: function (value) {\n      this._entityCollection.show = value;\n    },\n  },\n\n  /**\n   * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.\n   *\n   * @memberof GeoJsonDataSource.prototype\n   * @type {EntityCluster}\n   */\n  clustering: {\n    get: function () {\n      return this._entityCluster;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      if (!defined(value)) {\n        throw new DeveloperError(\"value must be defined.\");\n      }\n      //>>includeEnd('debug');\n      this._entityCluster = value;\n    },\n  },\n  /**\n   * Gets the credit that will be displayed for the data source\n   * @memberof GeoJsonDataSource.prototype\n   * @type {Credit}\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n});\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.\n *\n * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise.<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.load = function (data, options) {\n  return preload(this, data, options, true);\n};\n\n/**\n * Asynchronously loads the provided GeoJSON or TopoJSON data, without replacing any existing data.\n *\n * @param {Resource|String|Object} data A url, GeoJSON object, or TopoJSON object to be loaded.\n * @param {GeoJsonDataSource.LoadOptions} [options] An object specifying configuration options\n *\n * @returns {Promise.<GeoJsonDataSource>} a promise that will resolve when the GeoJSON is loaded.\n */\nGeoJsonDataSource.prototype.process = function (data, options) {\n  return preload(this, data, options, false);\n};\n\nfunction preload(that, data, options, clear) {\n  //>>includeStart('debug', pragmas.debug);\n  if (!defined(data)) {\n    throw new DeveloperError(\"data is required.\");\n  }\n  //>>includeEnd('debug');\n\n  DataSource.setLoading(that, true);\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // User specified credit\n  let credit = options.credit;\n  if (typeof credit === \"string\") {\n    credit = new Credit(credit);\n  }\n  that._credit = credit;\n\n  let promise = data;\n  let sourceUri = options.sourceUri;\n  if (typeof data === \"string\" || data instanceof Resource) {\n    data = Resource.createIfNeeded(data);\n    promise = data.fetchJson();\n    sourceUri = defaultValue(sourceUri, data.getUrlComponent());\n\n    // Add resource credits to our list of credits to display\n    const resourceCredits = that._resourceCredits;\n    const credits = data.credits;\n    if (defined(credits)) {\n      const length = credits.length;\n      for (let i = 0; i < length; i++) {\n        resourceCredits.push(credits[i]);\n      }\n    }\n  }\n\n  options = {\n    describe: defaultValue(options.describe, defaultDescribeProperty),\n    markerSize: defaultValue(options.markerSize, defaultMarkerSize),\n    markerSymbol: defaultValue(options.markerSymbol, defaultMarkerSymbol),\n    markerColor: defaultValue(options.markerColor, defaultMarkerColor),\n    strokeWidthProperty: new ConstantProperty(\n      defaultValue(options.strokeWidth, defaultStrokeWidth)\n    ),\n    strokeMaterialProperty: new ColorMaterialProperty(\n      defaultValue(options.stroke, defaultStroke)\n    ),\n    fillMaterialProperty: new ColorMaterialProperty(\n      defaultValue(options.fill, defaultFill)\n    ),\n    clampToGround: defaultValue(options.clampToGround, defaultClampToGround),\n  };\n\n  return Promise.resolve(promise)\n    .then(function (geoJson) {\n      return load(that, geoJson, options, sourceUri, clear);\n    })\n    .catch(function (error) {\n      DataSource.setLoading(that, false);\n      that._error.raiseEvent(that, error);\n      throw error;\n    });\n}\n\n/**\n * Updates the data source to the provided time.  This function is optional and\n * is not required to be implemented.  It is provided for data sources which\n * retrieve data based on the current animation time or scene state.\n * If implemented, update will be called by {@link DataSourceDisplay} once a frame.\n *\n * @param {JulianDate} time The simulation time.\n * @returns {Boolean} True if this data source is ready to be displayed at the provided time, false otherwise.\n */\nGeoJsonDataSource.prototype.update = function (time) {\n  return true;\n};\n\nfunction load(that, geoJson, options, sourceUri, clear) {\n  let name;\n  if (defined(sourceUri)) {\n    name = getFilenameFromUri(sourceUri);\n  }\n\n  if (defined(name) && that._name !== name) {\n    that._name = name;\n    that._changed.raiseEvent(that);\n  }\n\n  const typeHandler = geoJsonObjectTypes[geoJson.type];\n  if (!defined(typeHandler)) {\n    throw new RuntimeError(`Unsupported GeoJSON object type: ${geoJson.type}`);\n  }\n\n  //Check for a Coordinate Reference System.\n  const crs = geoJson.crs;\n  let crsFunction = crs !== null ? defaultCrsFunction : null;\n\n  if (defined(crs)) {\n    if (!defined(crs.properties)) {\n      throw new RuntimeError(\"crs.properties is undefined.\");\n    }\n\n    const properties = crs.properties;\n    if (crs.type === \"name\") {\n      crsFunction = crsNames[properties.name];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs name: ${properties.name}`);\n      }\n    } else if (crs.type === \"link\") {\n      let handler = crsLinkHrefs[properties.href];\n      if (!defined(handler)) {\n        handler = crsLinkTypes[properties.type];\n      }\n\n      if (!defined(handler)) {\n        throw new RuntimeError(\n          `Unable to resolve crs link: ${JSON.stringify(properties)}`\n        );\n      }\n\n      crsFunction = handler(properties);\n    } else if (crs.type === \"EPSG\") {\n      crsFunction = crsNames[`EPSG:${properties.code}`];\n      if (!defined(crsFunction)) {\n        throw new RuntimeError(`Unknown crs EPSG code: ${properties.code}`);\n      }\n    } else {\n      throw new RuntimeError(`Unknown crs type: ${crs.type}`);\n    }\n  }\n\n  return Promise.resolve(crsFunction).then(function (crsFunction) {\n    if (clear) {\n      that._entityCollection.removeAll();\n    }\n\n    // null is a valid value for the crs, but means the entire load process becomes a no-op\n    // because we can't assume anything about the coordinates.\n    if (crsFunction !== null) {\n      typeHandler(that, geoJson, geoJson, crsFunction, options);\n    }\n\n    return Promise.all(that._promises).then(function () {\n      that._promises.length = 0;\n      DataSource.setLoading(that, false);\n      return that;\n    });\n  });\n}\n\n/**\n * This callback is displayed as part of the GeoJsonDataSource class.\n * @callback GeoJsonDataSource.describe\n * @param {Object} properties The properties of the feature.\n * @param {String} nameProperty The property key that Cesium estimates to have the name of the feature.\n */\nexport default GeoJsonDataSource;\n","import {\r\n  ArcType, BoundingRectangle, BoundingSphere, Cartesian2, Cartesian3, Cartographic,\r\n  Check, ComponentDatatype, defaultValue, defined, DeveloperError, Ellipsoid,\r\n  EllipsoidGeodesic, EllipsoidTangentPlane, Geometry, GeometryAttribute, GeometryInstance,\r\n  GeometryOffsetAttribute, GeometryPipeline, IndexDatatype, Math as CesiumMath, Matrix3, PolygonGeometryLibrary,\r\n  PolygonPipeline, Quaternion, Rectangle, VertexFormat, WindingOrder,\r\n} from 'cesium'\r\n\r\n\r\nconst scratchCarto1 = new Cartographic();\r\nconst scratchCarto2 = new Cartographic();\r\nfunction adjustPosHeightsForNormal(position, p1, p2, ellipsoid) {\r\n  const carto1 = ellipsoid.cartesianToCartographic(position, scratchCarto1);\r\n  const height = carto1.height;\r\n  const p1Carto = ellipsoid.cartesianToCartographic(p1, scratchCarto2);\r\n  p1Carto.height = height;\r\n  ellipsoid.cartographicToCartesian(p1Carto, p1);\r\n\r\n  const p2Carto = ellipsoid.cartesianToCartographic(p2, scratchCarto2);\r\n  p2Carto.height = height - 100;\r\n  ellipsoid.cartographicToCartesian(p2Carto, p2);\r\n}\r\n\r\nconst scratchBoundingRectangle = new BoundingRectangle();\r\nconst scratchPosition = new Cartesian3();\r\nconst scratchNormal = new Cartesian3();\r\nconst scratchTangent = new Cartesian3();\r\nconst scratchBitangent = new Cartesian3();\r\nconst p1Scratch = new Cartesian3();\r\nconst p2Scratch = new Cartesian3();\r\nlet scratchPerPosNormal = new Cartesian3();\r\nlet scratchPerPosTangent = new Cartesian3();\r\nlet scratchPerPosBitangent = new Cartesian3();\r\n\r\nconst appendTextureCoordinatesOrigin = new Cartesian2();\r\nconst appendTextureCoordinatesCartesian2 = new Cartesian2();\r\nconst appendTextureCoordinatesCartesian3 = new Cartesian3();\r\nconst appendTextureCoordinatesQuaternion = new Quaternion();\r\nconst appendTextureCoordinatesMatrix3 = new Matrix3();\r\nconst tangentMatrixScratch = new Matrix3();\r\n\r\nfunction computeAttributes(options) {\r\n  const vertexFormat = options.vertexFormat;\r\n  const geometry = options.geometry;\r\n  const shadowVolume = options.shadowVolume;\r\n  const flatPositions = geometry.attributes.position.values;\r\n  const flatTexcoords = defined(geometry.attributes.st)\r\n    ? geometry.attributes.st.values\r\n    : undefined;\r\n\r\n  let length = flatPositions.length;\r\n  const wall = options.wall;\r\n  const top = options.top || wall;\r\n  const bottom = options.bottom || wall;\r\n  if (\r\n    vertexFormat.st ||\r\n    vertexFormat.normal ||\r\n    vertexFormat.tangent ||\r\n    vertexFormat.bitangent ||\r\n    shadowVolume\r\n  ) {\r\n    // PERFORMANCE_IDEA: Compute before subdivision, then just interpolate during subdivision.\r\n    // PERFORMANCE_IDEA: Compute with createGeometryFromPositions() for fast path when there's no holes.\r\n    const boundingRectangle = options.boundingRectangle;\r\n    const tangentPlane = options.tangentPlane;\r\n    const ellipsoid = options.ellipsoid;\r\n    const stRotation = options.stRotation;\r\n    const perPositionHeight = options.perPositionHeight;\r\n\r\n    const origin = appendTextureCoordinatesOrigin;\r\n    origin.x = boundingRectangle.x;\r\n    origin.y = boundingRectangle.y;\r\n\r\n    const textureCoordinates = vertexFormat.st\r\n      ? new Float32Array(2 * (length / 3))\r\n      : undefined;\r\n    let normals;\r\n    if (vertexFormat.normal) {\r\n      if (perPositionHeight && top && !wall) {\r\n        normals = geometry.attributes.normal.values;\r\n      } else {\r\n        normals = new Float32Array(length);\r\n      }\r\n    }\r\n    const tangents = vertexFormat.tangent\r\n      ? new Float32Array(length)\r\n      : undefined;\r\n    const bitangents = vertexFormat.bitangent\r\n      ? new Float32Array(length)\r\n      : undefined;\r\n    const extrudeNormals = shadowVolume ? new Float32Array(length) : undefined;\r\n\r\n    let textureCoordIndex = 0;\r\n    let attrIndex = 0;\r\n\r\n    let normal = scratchNormal;\r\n    let tangent = scratchTangent;\r\n    let bitangent = scratchBitangent;\r\n    let recomputeNormal = true;\r\n\r\n    let textureMatrix = appendTextureCoordinatesMatrix3;\r\n    let tangentRotationMatrix = tangentMatrixScratch;\r\n    if (stRotation !== 0.0) {\r\n      let rotation = Quaternion.fromAxisAngle(\r\n        tangentPlane._plane.normal,\r\n        stRotation,\r\n        appendTextureCoordinatesQuaternion\r\n      );\r\n      textureMatrix = Matrix3.fromQuaternion(rotation, textureMatrix);\r\n\r\n      rotation = Quaternion.fromAxisAngle(\r\n        tangentPlane._plane.normal,\r\n        -stRotation,\r\n        appendTextureCoordinatesQuaternion\r\n      );\r\n      tangentRotationMatrix = Matrix3.fromQuaternion(\r\n        rotation,\r\n        tangentRotationMatrix\r\n      );\r\n    } else {\r\n      textureMatrix = Matrix3.clone(Matrix3.IDENTITY, textureMatrix);\r\n      tangentRotationMatrix = Matrix3.clone(\r\n        Matrix3.IDENTITY,\r\n        tangentRotationMatrix\r\n      );\r\n    }\r\n\r\n    let bottomOffset = 0;\r\n    let bottomOffset2 = 0;\r\n\r\n    if (top && bottom) {\r\n      bottomOffset = length / 2;\r\n      bottomOffset2 = length / 3;\r\n\r\n      length /= 2;\r\n    }\r\n\r\n    for (let i = 0; i < length; i += 3) {\r\n      const position = Cartesian3.fromArray(\r\n        flatPositions,\r\n        i,\r\n        appendTextureCoordinatesCartesian3\r\n      );\r\n\r\n      if (vertexFormat.st) {\r\n        if (!defined(flatTexcoords)) {\r\n          let p = Matrix3.multiplyByVector(\r\n            textureMatrix,\r\n            position,\r\n            scratchPosition\r\n          );\r\n          p = ellipsoid.scaleToGeodeticSurface(p, p);\r\n          const st = tangentPlane.projectPointOntoPlane(\r\n            p,\r\n            appendTextureCoordinatesCartesian2\r\n          );\r\n          Cartesian2.subtract(st, origin, st);\r\n          // 修改纹理坐标值 开始\r\n          // const stx = CesiumMath.clamp(st.x / boundingRectangle.width, 0, 1);\r\n          // const sty = CesiumMath.clamp(st.y / boundingRectangle.height, 0, 1);\r\n          if (bottom) {\r\n            textureCoordinates[textureCoordIndex + bottomOffset2] = 0;\r\n            textureCoordinates[textureCoordIndex + 1 + bottomOffset2] = 0;\r\n          }\r\n          if (top) {\r\n            textureCoordinates[textureCoordIndex] = 0;\r\n            textureCoordinates[textureCoordIndex + 1] = 1;\r\n          }\r\n          // 修改纹理坐标值 结束\r\n\r\n          textureCoordIndex += 2;\r\n        }\r\n      }\r\n\r\n      if (\r\n        vertexFormat.normal ||\r\n        vertexFormat.tangent ||\r\n        vertexFormat.bitangent ||\r\n        shadowVolume\r\n      ) {\r\n        const attrIndex1 = attrIndex + 1;\r\n        const attrIndex2 = attrIndex + 2;\r\n\r\n        if (wall) {\r\n          if (i + 3 < length) {\r\n            const p1 = Cartesian3.fromArray(flatPositions, i + 3, p1Scratch);\r\n\r\n            if (recomputeNormal) {\r\n              const p2 = Cartesian3.fromArray(\r\n                flatPositions,\r\n                i + length,\r\n                p2Scratch\r\n              );\r\n              if (perPositionHeight) {\r\n                adjustPosHeightsForNormal(position, p1, p2, ellipsoid);\r\n              }\r\n              Cartesian3.subtract(p1, position, p1);\r\n              Cartesian3.subtract(p2, position, p2);\r\n              normal = Cartesian3.normalize(\r\n                Cartesian3.cross(p2, p1, normal),\r\n                normal\r\n              );\r\n              recomputeNormal = false;\r\n            }\r\n\r\n            if (Cartesian3.equalsEpsilon(p1, position, CesiumMath.EPSILON10)) {\r\n              // if we've reached a corner\r\n              recomputeNormal = true;\r\n            }\r\n          }\r\n\r\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            bitangent = ellipsoid.geodeticSurfaceNormal(position, bitangent);\r\n            if (vertexFormat.tangent) {\r\n              tangent = Cartesian3.normalize(\r\n                Cartesian3.cross(bitangent, normal, tangent),\r\n                tangent\r\n              );\r\n            }\r\n          }\r\n        } else {\r\n          normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n          if (vertexFormat.tangent || vertexFormat.bitangent) {\r\n            if (perPositionHeight) {\r\n              scratchPerPosNormal = Cartesian3.fromArray(\r\n                normals,\r\n                attrIndex,\r\n                scratchPerPosNormal\r\n              );\r\n              scratchPerPosTangent = Cartesian3.cross(\r\n                Cartesian3.UNIT_Z,\r\n                scratchPerPosNormal,\r\n                scratchPerPosTangent\r\n              );\r\n              scratchPerPosTangent = Cartesian3.normalize(\r\n                Matrix3.multiplyByVector(\r\n                  tangentRotationMatrix,\r\n                  scratchPerPosTangent,\r\n                  scratchPerPosTangent\r\n                ),\r\n                scratchPerPosTangent\r\n              );\r\n              if (vertexFormat.bitangent) {\r\n                scratchPerPosBitangent = Cartesian3.normalize(\r\n                  Cartesian3.cross(\r\n                    scratchPerPosNormal,\r\n                    scratchPerPosTangent,\r\n                    scratchPerPosBitangent\r\n                  ),\r\n                  scratchPerPosBitangent\r\n                );\r\n              }\r\n            }\r\n\r\n            tangent = Cartesian3.cross(Cartesian3.UNIT_Z, normal, tangent);\r\n            tangent = Cartesian3.normalize(\r\n              Matrix3.multiplyByVector(tangentRotationMatrix, tangent, tangent),\r\n              tangent\r\n            );\r\n            if (vertexFormat.bitangent) {\r\n              bitangent = Cartesian3.normalize(\r\n                Cartesian3.cross(normal, tangent, bitangent),\r\n                bitangent\r\n              );\r\n            }\r\n          }\r\n        }\r\n\r\n        if (vertexFormat.normal) {\r\n          if (options.wall) {\r\n            normals[attrIndex + bottomOffset] = normal.x;\r\n            normals[attrIndex1 + bottomOffset] = normal.y;\r\n            normals[attrIndex2 + bottomOffset] = normal.z;\r\n          } else if (bottom) {\r\n            normals[attrIndex + bottomOffset] = -normal.x;\r\n            normals[attrIndex1 + bottomOffset] = -normal.y;\r\n            normals[attrIndex2 + bottomOffset] = -normal.z;\r\n          }\r\n\r\n          if ((top && !perPositionHeight) || wall) {\r\n            normals[attrIndex] = normal.x;\r\n            normals[attrIndex1] = normal.y;\r\n            normals[attrIndex2] = normal.z;\r\n          }\r\n        }\r\n\r\n        if (shadowVolume) {\r\n          if (wall) {\r\n            normal = ellipsoid.geodeticSurfaceNormal(position, normal);\r\n          }\r\n          extrudeNormals[attrIndex + bottomOffset] = -normal.x;\r\n          extrudeNormals[attrIndex1 + bottomOffset] = -normal.y;\r\n          extrudeNormals[attrIndex2 + bottomOffset] = -normal.z;\r\n        }\r\n\r\n        if (vertexFormat.tangent) {\r\n          if (options.wall) {\r\n            tangents[attrIndex + bottomOffset] = tangent.x;\r\n            tangents[attrIndex1 + bottomOffset] = tangent.y;\r\n            tangents[attrIndex2 + bottomOffset] = tangent.z;\r\n          } else if (bottom) {\r\n            tangents[attrIndex + bottomOffset] = -tangent.x;\r\n            tangents[attrIndex1 + bottomOffset] = -tangent.y;\r\n            tangents[attrIndex2 + bottomOffset] = -tangent.z;\r\n          }\r\n\r\n          if (top) {\r\n            if (perPositionHeight) {\r\n              tangents[attrIndex] = scratchPerPosTangent.x;\r\n              tangents[attrIndex1] = scratchPerPosTangent.y;\r\n              tangents[attrIndex2] = scratchPerPosTangent.z;\r\n            } else {\r\n              tangents[attrIndex] = tangent.x;\r\n              tangents[attrIndex1] = tangent.y;\r\n              tangents[attrIndex2] = tangent.z;\r\n            }\r\n          }\r\n        }\r\n\r\n        if (vertexFormat.bitangent) {\r\n          if (bottom) {\r\n            bitangents[attrIndex + bottomOffset] = bitangent.x;\r\n            bitangents[attrIndex1 + bottomOffset] = bitangent.y;\r\n            bitangents[attrIndex2 + bottomOffset] = bitangent.z;\r\n          }\r\n          if (top) {\r\n            if (perPositionHeight) {\r\n              bitangents[attrIndex] = scratchPerPosBitangent.x;\r\n              bitangents[attrIndex1] = scratchPerPosBitangent.y;\r\n              bitangents[attrIndex2] = scratchPerPosBitangent.z;\r\n            } else {\r\n              bitangents[attrIndex] = bitangent.x;\r\n              bitangents[attrIndex1] = bitangent.y;\r\n              bitangents[attrIndex2] = bitangent.z;\r\n            }\r\n          }\r\n        }\r\n        attrIndex += 3;\r\n      }\r\n    }\r\n\r\n    if (vertexFormat.st && !defined(flatTexcoords)) {\r\n      geometry.attributes.st = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 2,\r\n        values: textureCoordinates,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.normal) {\r\n      geometry.attributes.normal = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: normals,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.tangent) {\r\n      geometry.attributes.tangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: tangents,\r\n      });\r\n    }\r\n\r\n    if (vertexFormat.bitangent) {\r\n      geometry.attributes.bitangent = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: bitangents,\r\n      });\r\n    }\r\n\r\n    if (shadowVolume) {\r\n      geometry.attributes.extrudeDirection = new GeometryAttribute({\r\n        componentDatatype: ComponentDatatype.FLOAT,\r\n        componentsPerAttribute: 3,\r\n        values: extrudeNormals,\r\n      });\r\n    }\r\n  }\r\n\r\n  if (options.extrude && defined(options.offsetAttribute)) {\r\n    const size = flatPositions.length / 3;\r\n    let offsetAttribute = new Uint8Array(size);\r\n\r\n    if (options.offsetAttribute === GeometryOffsetAttribute.TOP) {\r\n      if ((top && bottom) || wall) {\r\n        offsetAttribute = offsetAttribute.fill(1, 0, size / 2);\r\n      } else if (top) {\r\n        offsetAttribute = offsetAttribute.fill(1);\r\n      }\r\n    } else {\r\n      const offsetValue =\r\n        options.offsetAttribute === GeometryOffsetAttribute.NONE ? 0 : 1;\r\n      offsetAttribute = offsetAttribute.fill(offsetValue);\r\n    }\r\n\r\n    geometry.attributes.applyOffset = new GeometryAttribute({\r\n      componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n      componentsPerAttribute: 1,\r\n      values: offsetAttribute,\r\n    });\r\n  }\r\n\r\n  return geometry;\r\n}\r\n\r\nconst startCartographicScratch = new Cartographic();\r\nconst endCartographicScratch = new Cartographic();\r\nconst idlCross = {\r\n  westOverIDL: 0.0,\r\n  eastOverIDL: 0.0,\r\n};\r\nlet ellipsoidGeodesic = new EllipsoidGeodesic();\r\nfunction computeRectangle(positions, ellipsoid, arcType, granularity, result) {\r\n  result = defaultValue(result, new Rectangle());\r\n  if (!defined(positions) || positions.length < 3) {\r\n    result.west = 0.0;\r\n    result.north = 0.0;\r\n    result.south = 0.0;\r\n    result.east = 0.0;\r\n    return result;\r\n  }\r\n\r\n  if (arcType === ArcType.RHUMB) {\r\n    return Rectangle.fromCartesianArray(positions, ellipsoid, result);\r\n  }\r\n\r\n  if (!ellipsoidGeodesic.ellipsoid.equals(ellipsoid)) {\r\n    ellipsoidGeodesic = new EllipsoidGeodesic(undefined, undefined, ellipsoid);\r\n  }\r\n\r\n  result.west = Number.POSITIVE_INFINITY;\r\n  result.east = Number.NEGATIVE_INFINITY;\r\n  result.south = Number.POSITIVE_INFINITY;\r\n  result.north = Number.NEGATIVE_INFINITY;\r\n\r\n  idlCross.westOverIDL = Number.POSITIVE_INFINITY;\r\n  idlCross.eastOverIDL = Number.NEGATIVE_INFINITY;\r\n\r\n  const inverseChordLength =\r\n    1.0 / CesiumMath.chordLength(granularity, ellipsoid.maximumRadius);\r\n  const positionsLength = positions.length;\r\n  let endCartographic = ellipsoid.cartesianToCartographic(\r\n    positions[0],\r\n    endCartographicScratch\r\n  );\r\n  let startCartographic = startCartographicScratch;\r\n  let swap;\r\n\r\n  for (let i = 1; i < positionsLength; i++) {\r\n    swap = startCartographic;\r\n    startCartographic = endCartographic;\r\n    endCartographic = ellipsoid.cartesianToCartographic(positions[i], swap);\r\n    ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n    interpolateAndGrowRectangle(\r\n      ellipsoidGeodesic,\r\n      inverseChordLength,\r\n      result,\r\n      idlCross\r\n    );\r\n  }\r\n\r\n  swap = startCartographic;\r\n  startCartographic = endCartographic;\r\n  endCartographic = ellipsoid.cartesianToCartographic(positions[0], swap);\r\n  ellipsoidGeodesic.setEndPoints(startCartographic, endCartographic);\r\n  interpolateAndGrowRectangle(\r\n    ellipsoidGeodesic,\r\n    inverseChordLength,\r\n    result,\r\n    idlCross\r\n  );\r\n\r\n  if (result.east - result.west > idlCross.eastOverIDL - idlCross.westOverIDL) {\r\n    result.west = idlCross.westOverIDL;\r\n    result.east = idlCross.eastOverIDL;\r\n\r\n    if (result.east > CesiumMath.PI) {\r\n      result.east = result.east - CesiumMath.TWO_PI;\r\n    }\r\n    if (result.west > CesiumMath.PI) {\r\n      result.west = result.west - CesiumMath.TWO_PI;\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nconst interpolatedCartographicScratch = new Cartographic();\r\nfunction interpolateAndGrowRectangle(\r\n  ellipsoidGeodesic,\r\n  inverseChordLength,\r\n  result,\r\n  idlCross\r\n) {\r\n  const segmentLength = ellipsoidGeodesic.surfaceDistance;\r\n\r\n  const numPoints = Math.ceil(segmentLength * inverseChordLength);\r\n  const subsegmentDistance =\r\n    numPoints > 0 ? segmentLength / (numPoints - 1) : Number.POSITIVE_INFINITY;\r\n  let interpolationDistance = 0.0;\r\n\r\n  for (let i = 0; i < numPoints; i++) {\r\n    const interpolatedCartographic = ellipsoidGeodesic.interpolateUsingSurfaceDistance(\r\n      interpolationDistance,\r\n      interpolatedCartographicScratch\r\n    );\r\n    interpolationDistance += subsegmentDistance;\r\n    const longitude = interpolatedCartographic.longitude;\r\n    const latitude = interpolatedCartographic.latitude;\r\n\r\n    result.west = Math.min(result.west, longitude);\r\n    result.east = Math.max(result.east, longitude);\r\n    result.south = Math.min(result.south, latitude);\r\n    result.north = Math.max(result.north, latitude);\r\n\r\n    const lonAdjusted =\r\n      longitude >= 0 ? longitude : longitude + CesiumMath.TWO_PI;\r\n    idlCross.westOverIDL = Math.min(idlCross.westOverIDL, lonAdjusted);\r\n    idlCross.eastOverIDL = Math.max(idlCross.eastOverIDL, lonAdjusted);\r\n  }\r\n}\r\n\r\nconst createGeometryFromPositionsExtrudedPositions = [];\r\n\r\nfunction createGeometryFromPositionsExtruded(\r\n  ellipsoid,\r\n  polygon,\r\n  textureCoordinates,\r\n  granularity,\r\n  hierarchy,\r\n  perPositionHeight,\r\n  closeTop,\r\n  closeBottom,\r\n  vertexFormat,\r\n  arcType\r\n) {\r\n  const geos = {\r\n    walls: [],\r\n  };\r\n  let i;\r\n\r\n  if (closeTop || closeBottom) {\r\n    const topGeo = PolygonGeometryLibrary.createGeometryFromPositions(\r\n      ellipsoid,\r\n      polygon,\r\n      textureCoordinates,\r\n      granularity,\r\n      perPositionHeight,\r\n      vertexFormat,\r\n      arcType\r\n    );\r\n\r\n    const edgePoints = topGeo.attributes.position.values;\r\n    const indices = topGeo.indices;\r\n    let numPositions;\r\n    let newIndices;\r\n\r\n    if (closeTop && closeBottom) {\r\n      const topBottomPositions = edgePoints.concat(edgePoints);\r\n\r\n      numPositions = topBottomPositions.length / 3;\r\n\r\n      newIndices = IndexDatatype.createTypedArray(\r\n        numPositions,\r\n        indices.length * 2\r\n      );\r\n      newIndices.set(indices);\r\n      const ilength = indices.length;\r\n\r\n      const length = numPositions / 2;\r\n\r\n      for (i = 0; i < ilength; i += 3) {\r\n        const i0 = newIndices[i] + length;\r\n        const i1 = newIndices[i + 1] + length;\r\n        const i2 = newIndices[i + 2] + length;\r\n\r\n        newIndices[i + ilength] = i2;\r\n        newIndices[i + 1 + ilength] = i1;\r\n        newIndices[i + 2 + ilength] = i0;\r\n      }\r\n\r\n      topGeo.attributes.position.values = topBottomPositions;\r\n      if (perPositionHeight && vertexFormat.normal) {\r\n        const normals = topGeo.attributes.normal.values;\r\n        topGeo.attributes.normal.values = new Float32Array(\r\n          topBottomPositions.length\r\n        );\r\n        topGeo.attributes.normal.values.set(normals);\r\n      }\r\n\r\n      if (vertexFormat.st && defined(textureCoordinates)) {\r\n        const texcoords = topGeo.attributes.st.values;\r\n        topGeo.attributes.st.values = new Float32Array(numPositions * 2);\r\n        topGeo.attributes.st.values = texcoords.concat(texcoords);\r\n      }\r\n\r\n      topGeo.indices = newIndices;\r\n    } else if (closeBottom) {\r\n      numPositions = edgePoints.length / 3;\r\n      newIndices = IndexDatatype.createTypedArray(numPositions, indices.length);\r\n\r\n      for (i = 0; i < indices.length; i += 3) {\r\n        newIndices[i] = indices[i + 2];\r\n        newIndices[i + 1] = indices[i + 1];\r\n        newIndices[i + 2] = indices[i];\r\n      }\r\n\r\n      topGeo.indices = newIndices;\r\n    }\r\n\r\n    geos.topAndBottom = new GeometryInstance({\r\n      geometry: topGeo,\r\n    });\r\n  }\r\n\r\n  let outerRing = hierarchy.outerRing;\r\n  let tangentPlane = EllipsoidTangentPlane.fromPoints(outerRing, ellipsoid);\r\n  let positions2D = tangentPlane.projectPointsOntoPlane(\r\n    outerRing,\r\n    createGeometryFromPositionsExtrudedPositions\r\n  );\r\n\r\n  let windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n  if (windingOrder === WindingOrder.CLOCKWISE) {\r\n    outerRing = outerRing.slice().reverse();\r\n  }\r\n\r\n  let wallGeo = PolygonGeometryLibrary.computeWallGeometry(\r\n    outerRing,\r\n    textureCoordinates,\r\n    ellipsoid,\r\n    granularity,\r\n    perPositionHeight,\r\n    arcType\r\n  );\r\n  geos.walls.push(\r\n    new GeometryInstance({\r\n      geometry: wallGeo,\r\n    })\r\n  );\r\n\r\n  const holes = hierarchy.holes;\r\n  for (i = 0; i < holes.length; i++) {\r\n    let hole = holes[i];\r\n\r\n    tangentPlane = EllipsoidTangentPlane.fromPoints(hole, ellipsoid);\r\n    positions2D = tangentPlane.projectPointsOntoPlane(\r\n      hole,\r\n      createGeometryFromPositionsExtrudedPositions\r\n    );\r\n\r\n    windingOrder = PolygonPipeline.computeWindingOrder2D(positions2D);\r\n    if (windingOrder === WindingOrder.COUNTER_CLOCKWISE) {\r\n      hole = hole.slice().reverse();\r\n    }\r\n\r\n    wallGeo = PolygonGeometryLibrary.computeWallGeometry(\r\n      hole,\r\n      textureCoordinates,\r\n      ellipsoid,\r\n      granularity,\r\n      perPositionHeight,\r\n      arcType\r\n    );\r\n    geos.walls.push(\r\n      new GeometryInstance({\r\n        geometry: wallGeo,\r\n      })\r\n    );\r\n  }\r\n\r\n  return geos;\r\n}\r\n\r\n/**\r\n * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @alias PolygonGeometry\r\n * @constructor\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.height=0.0] The distance in meters between the polygon and the ellipsoid surface.\r\n * @param {Number} [options.extrudedHeight] The distance in meters between the polygon's extruded face and the ellipsoid surface.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\r\n *\r\n * @see PolygonGeometry#createGeometry\r\n * @see PolygonGeometry#fromPositions\r\n *\r\n * @demo {@link https://sandcastle.cesium.com/index.html?src=Polygon.html|Cesium Sandcastle Polygon Demo}\r\n *\r\n * @example\r\n * // 1. create a polygon from points\r\n * const polygon = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n *\r\n * // 2. create a nested polygon with holes\r\n * const polygonWithHole = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -109.0, 30.0,\r\n *       -95.0, 30.0,\r\n *       -95.0, 40.0,\r\n *       -109.0, 40.0\r\n *     ]),\r\n *     [new Cesium.PolygonHierarchy(\r\n *       Cesium.Cartesian3.fromDegreesArray([\r\n *         -107.0, 31.0,\r\n *         -107.0, 39.0,\r\n *         -97.0, 39.0,\r\n *         -97.0, 31.0\r\n *       ]),\r\n *       [new Cesium.PolygonHierarchy(\r\n *         Cesium.Cartesian3.fromDegreesArray([\r\n *           -105.0, 33.0,\r\n *           -99.0, 33.0,\r\n *           -99.0, 37.0,\r\n *           -105.0, 37.0\r\n *         ]),\r\n *         [new Cesium.PolygonHierarchy(\r\n *           Cesium.Cartesian3.fromDegreesArray([\r\n *             -103.0, 34.0,\r\n *             -101.0, 34.0,\r\n *             -101.0, 36.0,\r\n *             -103.0, 36.0\r\n *           ])\r\n *         )]\r\n *       )]\r\n *     )]\r\n *   )\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);\r\n *\r\n * // 3. create extruded polygon\r\n * const extrudedPolygon = new Cesium.PolygonGeometry({\r\n *   polygonHierarchy : new Cesium.PolygonHierarchy(\r\n *     Cesium.Cartesian3.fromDegreesArray([\r\n *       -72.0, 40.0,\r\n *       -70.0, 35.0,\r\n *       -75.0, 30.0,\r\n *       -70.0, 30.0,\r\n *       -68.0, 40.0\r\n *     ])\r\n *   ),\r\n *   extrudedHeight: 300000\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);\r\n */\r\nfunction PolygonGeometry(options) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n  if (\r\n    defined(options.perPositionHeight) &&\r\n    options.perPositionHeight &&\r\n    defined(options.height)\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Cannot use both options.perPositionHeight and options.height\"\r\n    );\r\n  }\r\n  if (\r\n    defined(options.arcType) &&\r\n    options.arcType !== ArcType.GEODESIC &&\r\n    options.arcType !== ArcType.RHUMB\r\n  ) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const vertexFormat = defaultValue(options.vertexFormat, VertexFormat.DEFAULT);\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const stRotation = defaultValue(options.stRotation, 0.0);\r\n  const textureCoordinates = options.textureCoordinates;\r\n  const perPositionHeight = defaultValue(options.perPositionHeight, false);\r\n  const perPositionHeightExtrude =\r\n    perPositionHeight && defined(options.extrudedHeight);\r\n  let height = defaultValue(options.height, 0.0);\r\n  let extrudedHeight = defaultValue(options.extrudedHeight, height);\r\n\r\n  if (!perPositionHeightExtrude) {\r\n    const h = Math.max(height, extrudedHeight);\r\n    extrudedHeight = Math.min(height, extrudedHeight);\r\n    height = h;\r\n  }\r\n\r\n  this._vertexFormat = VertexFormat.clone(vertexFormat);\r\n  this._ellipsoid = Ellipsoid.clone(ellipsoid);\r\n  this._granularity = granularity;\r\n  this._stRotation = stRotation;\r\n  this._height = height;\r\n  this._extrudedHeight = extrudedHeight;\r\n  this._closeTop = defaultValue(options.closeTop, true);\r\n  this._closeBottom = defaultValue(options.closeBottom, true);\r\n  this._polygonHierarchy = polygonHierarchy;\r\n  this._perPositionHeight = perPositionHeight;\r\n  this._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  this._shadowVolume = defaultValue(options.shadowVolume, false);\r\n  this._workerName = \"createPolygonGeometry\";\r\n  this._offsetAttribute = options.offsetAttribute;\r\n  this._arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n\r\n  this._rectangle = undefined;\r\n  this._textureCoordinateRotationPoints = undefined;\r\n  this._textureCoordinates = textureCoordinates;\r\n\r\n  /**\r\n   * The number of elements used to pack the object into an array.\r\n   * @type {Number}\r\n   */\r\n  this.packedLength =\r\n    PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n      polygonHierarchy,\r\n      Cartesian3\r\n    ) +\r\n    Ellipsoid.packedLength +\r\n    VertexFormat.packedLength +\r\n    (textureCoordinates\r\n      ? PolygonGeometryLibrary.computeHierarchyPackedLength(\r\n        textureCoordinates,\r\n        Cartesian2\r\n      )\r\n      : 1) +\r\n    12;\r\n}\r\n\r\n/**\r\n * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {Cartesian3[]} options.positions An array of positions that defined the corner points of the polygon.\r\n * @param {Number} [options.height=0.0] The height of the polygon.\r\n * @param {Number} [options.extrudedHeight] The height of the polygon extrusion.\r\n * @param {VertexFormat} [options.vertexFormat=VertexFormat.DEFAULT] The vertex attributes to be computed.\r\n * @param {Number} [options.stRotation=0.0] The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.\r\n * @param {Boolean} [options.perPositionHeight=false] Use the height of options.positions for each position instead of using options.height to determine the height.\r\n * @param {Boolean} [options.closeTop=true] When false, leaves off the top of an extruded polygon open.\r\n * @param {Boolean} [options.closeBottom=true] When false, leaves off the bottom of an extruded polygon open.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {PolygonHierarchy} [options.textureCoordinates] Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.\r\n * @returns {PolygonGeometry}\r\n *\r\n * @example\r\n * // create a polygon from points\r\n * const polygon = Cesium.PolygonGeometry.fromPositions({\r\n *   positions : Cesium.Cartesian3.fromDegreesArray([\r\n *     -72.0, 40.0,\r\n *     -70.0, 35.0,\r\n *     -75.0, 30.0,\r\n *     -70.0, 30.0,\r\n *     -68.0, 40.0\r\n *   ])\r\n * });\r\n * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);\r\n *\r\n * @see PolygonGeometry#createGeometry\r\n */\r\nPolygonGeometry.fromPositions = function (options) {\r\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\r\n\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"options.positions\", options.positions);\r\n  //>>includeEnd('debug');\r\n\r\n  const newOptions = {\r\n    polygonHierarchy: {\r\n      positions: options.positions,\r\n    },\r\n    height: options.height,\r\n    extrudedHeight: options.extrudedHeight,\r\n    vertexFormat: options.vertexFormat,\r\n    stRotation: options.stRotation,\r\n    ellipsoid: options.ellipsoid,\r\n    granularity: options.granularity,\r\n    perPositionHeight: options.perPositionHeight,\r\n    closeTop: options.closeTop,\r\n    closeBottom: options.closeBottom,\r\n    offsetAttribute: options.offsetAttribute,\r\n    arcType: options.arcType,\r\n    textureCoordinates: options.textureCoordinates,\r\n  };\r\n  return new PolygonGeometry(newOptions);\r\n};\r\n\r\n/**\r\n * Stores the provided instance into the provided array.\r\n *\r\n * @param {PolygonGeometry} value The value to pack.\r\n * @param {Number[]} array The array to pack into.\r\n * @param {Number} [startingIndex=0] The index into the array at which to start packing the elements.\r\n *\r\n * @returns {Number[]} The array that was packed into\r\n */\r\nPolygonGeometry.pack = function (value, array, startingIndex) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"value\", value);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n    value._polygonHierarchy,\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n\r\n  Ellipsoid.pack(value._ellipsoid, array, startingIndex);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  VertexFormat.pack(value._vertexFormat, array, startingIndex);\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  array[startingIndex++] = value._height;\r\n  array[startingIndex++] = value._extrudedHeight;\r\n  array[startingIndex++] = value._granularity;\r\n  array[startingIndex++] = value._stRotation;\r\n  array[startingIndex++] = value._perPositionHeightExtrude ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._perPositionHeight ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._closeTop ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._closeBottom ? 1.0 : 0.0;\r\n  array[startingIndex++] = value._shadowVolume ? 1.0 : 0.0;\r\n  array[startingIndex++] = defaultValue(value._offsetAttribute, -1);\r\n  array[startingIndex++] = value._arcType;\r\n  if (defined(value._textureCoordinates)) {\r\n    startingIndex = PolygonGeometryLibrary.packPolygonHierarchy(\r\n      value._textureCoordinates,\r\n      array,\r\n      startingIndex,\r\n      Cartesian2\r\n    );\r\n  } else {\r\n    array[startingIndex++] = -1.0;\r\n  }\r\n  array[startingIndex++] = value.packedLength;\r\n  return array;\r\n};\r\n\r\nconst scratchEllipsoid = Ellipsoid.clone(Ellipsoid.UNIT_SPHERE);\r\nconst scratchVertexFormat = new VertexFormat();\r\n\r\n//Only used to avoid inability to default construct.\r\nconst dummyOptions = {\r\n  polygonHierarchy: {},\r\n};\r\n\r\n/**\r\n * Retrieves an instance from a packed array.\r\n *\r\n * @param {Number[]} array The packed array.\r\n * @param {Number} [startingIndex=0] The starting index of the element to be unpacked.\r\n * @param {PolygonGeometry} [result] The object into which to store the result.\r\n */\r\nPolygonGeometry.unpack = function (array, startingIndex, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.defined(\"array\", array);\r\n  //>>includeEnd('debug');\r\n\r\n  startingIndex = defaultValue(startingIndex, 0);\r\n\r\n  const polygonHierarchy = PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n    array,\r\n    startingIndex,\r\n    Cartesian3\r\n  );\r\n  startingIndex = polygonHierarchy.startingIndex;\r\n  delete polygonHierarchy.startingIndex;\r\n\r\n  const ellipsoid = Ellipsoid.unpack(array, startingIndex, scratchEllipsoid);\r\n  startingIndex += Ellipsoid.packedLength;\r\n\r\n  const vertexFormat = VertexFormat.unpack(\r\n    array,\r\n    startingIndex,\r\n    scratchVertexFormat\r\n  );\r\n  startingIndex += VertexFormat.packedLength;\r\n\r\n  const height = array[startingIndex++];\r\n  const extrudedHeight = array[startingIndex++];\r\n  const granularity = array[startingIndex++];\r\n  const stRotation = array[startingIndex++];\r\n  const perPositionHeightExtrude = array[startingIndex++] === 1.0;\r\n  const perPositionHeight = array[startingIndex++] === 1.0;\r\n  const closeTop = array[startingIndex++] === 1.0;\r\n  const closeBottom = array[startingIndex++] === 1.0;\r\n  const shadowVolume = array[startingIndex++] === 1.0;\r\n  const offsetAttribute = array[startingIndex++];\r\n  const arcType = array[startingIndex++];\r\n  const textureCoordinates =\r\n    array[startingIndex] === -1.0\r\n      ? undefined\r\n      : PolygonGeometryLibrary.unpackPolygonHierarchy(\r\n        array,\r\n        startingIndex,\r\n        Cartesian2\r\n      );\r\n  if (defined(textureCoordinates)) {\r\n    startingIndex = textureCoordinates.startingIndex;\r\n    delete textureCoordinates.startingIndex;\r\n  } else {\r\n    startingIndex++;\r\n  }\r\n  const packedLength = array[startingIndex++];\r\n\r\n  if (!defined(result)) {\r\n    result = new PolygonGeometry(dummyOptions);\r\n  }\r\n\r\n  result._polygonHierarchy = polygonHierarchy;\r\n  result._ellipsoid = Ellipsoid.clone(ellipsoid, result._ellipsoid);\r\n  result._vertexFormat = VertexFormat.clone(vertexFormat, result._vertexFormat);\r\n  result._height = height;\r\n  result._extrudedHeight = extrudedHeight;\r\n  result._granularity = granularity;\r\n  result._stRotation = stRotation;\r\n  result._perPositionHeightExtrude = perPositionHeightExtrude;\r\n  result._perPositionHeight = perPositionHeight;\r\n  result._closeTop = closeTop;\r\n  result._closeBottom = closeBottom;\r\n  result._shadowVolume = shadowVolume;\r\n  result._offsetAttribute =\r\n    offsetAttribute === -1 ? undefined : offsetAttribute;\r\n  result._arcType = arcType;\r\n  result._textureCoordinates = textureCoordinates;\r\n  result.packedLength = packedLength;\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Returns the bounding rectangle given the provided options\r\n *\r\n * @param {Object} options Object with the following properties:\r\n * @param {PolygonHierarchy} options.polygonHierarchy A polygon hierarchy that can include holes.\r\n * @param {Number} [options.granularity=CesiumMath.RADIANS_PER_DEGREE] The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.\r\n * @param {ArcType} [options.arcType=ArcType.GEODESIC] The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.\r\n * @param {Ellipsoid} [options.ellipsoid=Ellipsoid.WGS84] The ellipsoid to be used as a reference.\r\n * @param {Rectangle} [result] An object in which to store the result.\r\n *\r\n * @returns {Rectangle} The result rectangle\r\n */\r\nPolygonGeometry.computeRectangle = function (options, result) {\r\n  //>>includeStart('debug', pragmas.debug);\r\n  Check.typeOf.object(\"options\", options);\r\n  Check.typeOf.object(\"options.polygonHierarchy\", options.polygonHierarchy);\r\n  //>>includeEnd('debug');\r\n\r\n  const granularity = defaultValue(\r\n    options.granularity,\r\n    CesiumMath.RADIANS_PER_DEGREE\r\n  );\r\n  const arcType = defaultValue(options.arcType, ArcType.GEODESIC);\r\n  //>>includeStart('debug', pragmas.debug);\r\n  if (arcType !== ArcType.GEODESIC && arcType !== ArcType.RHUMB) {\r\n    throw new DeveloperError(\r\n      \"Invalid arcType. Valid options are ArcType.GEODESIC and ArcType.RHUMB.\"\r\n    );\r\n  }\r\n  //>>includeEnd('debug');\r\n\r\n  const polygonHierarchy = options.polygonHierarchy;\r\n  const ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\r\n\r\n  return computeRectangle(\r\n    polygonHierarchy.positions,\r\n    ellipsoid,\r\n    arcType,\r\n    granularity,\r\n    result\r\n  );\r\n};\r\n\r\n/**\r\n * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.\r\n *\r\n * @param {PolygonGeometry} polygonGeometry A description of the polygon.\r\n * @returns {Geometry|undefined} The computed vertices and indices.\r\n */\r\nPolygonGeometry.createGeometry = function (polygonGeometry) {\r\n  const vertexFormat = polygonGeometry._vertexFormat;\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const granularity = polygonGeometry._granularity;\r\n  const stRotation = polygonGeometry._stRotation;\r\n  const polygonHierarchy = polygonGeometry._polygonHierarchy;\r\n  const perPositionHeight = polygonGeometry._perPositionHeight;\r\n  const closeTop = polygonGeometry._closeTop;\r\n  const closeBottom = polygonGeometry._closeBottom;\r\n  const arcType = polygonGeometry._arcType;\r\n  const textureCoordinates = polygonGeometry._textureCoordinates;\r\n\r\n  const hasTextureCoordinates = defined(textureCoordinates);\r\n\r\n  let outerPositions = polygonHierarchy.positions;\r\n  if (outerPositions.length < 3) {\r\n    return;\r\n  }\r\n\r\n  const tangentPlane = EllipsoidTangentPlane.fromPoints(\r\n    outerPositions,\r\n    ellipsoid\r\n  );\r\n\r\n  const results = PolygonGeometryLibrary.polygonsFromHierarchy(\r\n    polygonHierarchy,\r\n    hasTextureCoordinates,\r\n    tangentPlane.projectPointsOntoPlane.bind(tangentPlane),\r\n    !perPositionHeight,\r\n    ellipsoid\r\n  );\r\n\r\n  const hierarchy = results.hierarchy;\r\n  const polygons = results.polygons;\r\n\r\n  const dummyFunction = function (identity) {\r\n    return identity;\r\n  };\r\n\r\n  const textureCoordinatePolygons = hasTextureCoordinates\r\n    ? PolygonGeometryLibrary.polygonsFromHierarchy(\r\n      textureCoordinates,\r\n      true,\r\n      dummyFunction,\r\n      false\r\n    ).polygons\r\n    : undefined;\r\n\r\n  if (hierarchy.length === 0) {\r\n    return;\r\n  }\r\n\r\n  outerPositions = hierarchy[0].outerRing;\r\n  const boundingRectangle = PolygonGeometryLibrary.computeBoundingRectangle(\r\n    tangentPlane.plane.normal,\r\n    tangentPlane.projectPointOntoPlane.bind(tangentPlane),\r\n    outerPositions,\r\n    stRotation,\r\n    scratchBoundingRectangle\r\n  );\r\n\r\n  const geometries = [];\r\n\r\n  const height = polygonGeometry._height;\r\n  const extrudedHeight = polygonGeometry._extrudedHeight;\r\n  const extrude =\r\n    polygonGeometry._perPositionHeightExtrude ||\r\n    !CesiumMath.equalsEpsilon(height, extrudedHeight, 0, CesiumMath.EPSILON2);\r\n\r\n  const options = {\r\n    perPositionHeight: perPositionHeight,\r\n    vertexFormat: vertexFormat,\r\n    geometry: undefined,\r\n    tangentPlane: tangentPlane,\r\n    boundingRectangle: boundingRectangle,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: stRotation,\r\n    textureCoordinates: undefined,\r\n    bottom: false,\r\n    top: true,\r\n    wall: false,\r\n    extrude: false,\r\n    arcType: arcType,\r\n  };\r\n\r\n  let i;\r\n\r\n  if (extrude) {\r\n    options.extrude = true;\r\n    options.top = closeTop;\r\n    options.bottom = closeBottom;\r\n    options.shadowVolume = polygonGeometry._shadowVolume;\r\n    options.offsetAttribute = polygonGeometry._offsetAttribute;\r\n    for (i = 0; i < polygons.length; i++) {\r\n      const splitGeometry = createGeometryFromPositionsExtruded(\r\n        ellipsoid,\r\n        polygons[i],\r\n        hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\r\n        granularity,\r\n        hierarchy[i],\r\n        perPositionHeight,\r\n        closeTop,\r\n        closeBottom,\r\n        vertexFormat,\r\n        arcType\r\n      );\r\n\r\n      let topAndBottom;\r\n      if (closeTop && closeBottom) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n          topAndBottom.geometry,\r\n          height,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          perPositionHeight\r\n        );\r\n      } else if (closeTop) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n          topAndBottom.geometry.attributes.position.values,\r\n          height,\r\n          ellipsoid,\r\n          !perPositionHeight\r\n        );\r\n        options.geometry = topAndBottom.geometry;\r\n      } else if (closeBottom) {\r\n        topAndBottom = splitGeometry.topAndBottom;\r\n        topAndBottom.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n          topAndBottom.geometry.attributes.position.values,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          true\r\n        );\r\n        options.geometry = topAndBottom.geometry;\r\n      }\r\n      if (closeTop || closeBottom) {\r\n        options.wall = false;\r\n        topAndBottom.geometry = computeAttributes(options);\r\n        geometries.push(topAndBottom);\r\n      }\r\n\r\n      const walls = splitGeometry.walls;\r\n      options.wall = true;\r\n      for (let k = 0; k < walls.length; k++) {\r\n        const wall = walls[k];\r\n        options.geometry = PolygonGeometryLibrary.scaleToGeodeticHeightExtruded(\r\n          wall.geometry,\r\n          height,\r\n          extrudedHeight,\r\n          ellipsoid,\r\n          perPositionHeight\r\n        );\r\n        wall.geometry = computeAttributes(options);\r\n        geometries.push(wall);\r\n      }\r\n    }\r\n  } else {\r\n    for (i = 0; i < polygons.length; i++) {\r\n      const geometryInstance = new GeometryInstance({\r\n        geometry: PolygonGeometryLibrary.createGeometryFromPositions(\r\n          ellipsoid,\r\n          polygons[i],\r\n          hasTextureCoordinates ? textureCoordinatePolygons[i] : undefined,\r\n          granularity,\r\n          perPositionHeight,\r\n          vertexFormat,\r\n          arcType\r\n        ),\r\n      });\r\n      geometryInstance.geometry.attributes.position.values = PolygonPipeline.scaleToGeodeticHeight(\r\n        geometryInstance.geometry.attributes.position.values,\r\n        height,\r\n        ellipsoid,\r\n        !perPositionHeight\r\n      );\r\n      options.geometry = geometryInstance.geometry;\r\n\r\n      geometryInstance.geometry = computeAttributes(options);\r\n\r\n      if (defined(polygonGeometry._offsetAttribute)) {\r\n        const length =\r\n          geometryInstance.geometry.attributes.position.values.length;\r\n        const offsetValue =\r\n          polygonGeometry._offsetAttribute === GeometryOffsetAttribute.NONE\r\n            ? 0\r\n            : 1;\r\n        const applyOffset = new Uint8Array(length / 3).fill(offsetValue);\r\n        geometryInstance.geometry.attributes.applyOffset = new GeometryAttribute(\r\n          {\r\n            componentDatatype: ComponentDatatype.UNSIGNED_BYTE,\r\n            componentsPerAttribute: 1,\r\n            values: applyOffset,\r\n          }\r\n        );\r\n      }\r\n\r\n      geometries.push(geometryInstance);\r\n    }\r\n  }\r\n\r\n  const geometry = GeometryPipeline.combineInstances(geometries)[0];\r\n  geometry.attributes.position.values = new Float64Array(\r\n    geometry.attributes.position.values\r\n  );\r\n  geometry.indices = IndexDatatype.createTypedArray(\r\n    geometry.attributes.position.values.length / 3,\r\n    geometry.indices\r\n  );\r\n\r\n  const attributes = geometry.attributes;\r\n  const boundingSphere = BoundingSphere.fromVertices(\r\n    attributes.position.values\r\n  );\r\n\r\n  if (!vertexFormat.position) {\r\n    delete attributes.position;\r\n  }\r\n\r\n  return new Geometry({\r\n    attributes: attributes,\r\n    indices: geometry.indices,\r\n    primitiveType: geometry.primitiveType,\r\n    boundingSphere: boundingSphere,\r\n    offsetAttribute: polygonGeometry._offsetAttribute,\r\n  });\r\n};\r\n\r\n/**\r\n * @private\r\n */\r\nPolygonGeometry.createShadowVolume = function (\r\n  polygonGeometry,\r\n  minHeightFunc,\r\n  maxHeightFunc\r\n) {\r\n  const granularity = polygonGeometry._granularity;\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n\r\n  const minHeight = minHeightFunc(granularity, ellipsoid);\r\n  const maxHeight = maxHeightFunc(granularity, ellipsoid);\r\n\r\n  return new PolygonGeometry({\r\n    polygonHierarchy: polygonGeometry._polygonHierarchy,\r\n    ellipsoid: ellipsoid,\r\n    stRotation: polygonGeometry._stRotation,\r\n    granularity: granularity,\r\n    perPositionHeight: false,\r\n    extrudedHeight: minHeight,\r\n    height: maxHeight,\r\n    vertexFormat: VertexFormat.POSITION_ONLY,\r\n    shadowVolume: true,\r\n    arcType: polygonGeometry._arcType,\r\n  });\r\n};\r\n\r\nfunction textureCoordinateRotationPoints(polygonGeometry) {\r\n  const stRotation = -polygonGeometry._stRotation;\r\n  if (stRotation === 0.0) {\r\n    return [0, 0, 0, 1, 1, 0];\r\n  }\r\n  const ellipsoid = polygonGeometry._ellipsoid;\r\n  const positions = polygonGeometry._polygonHierarchy.positions;\r\n  const boundingRectangle = polygonGeometry.rectangle;\r\n  return Geometry._textureCoordinateRotationPoints(\r\n    positions,\r\n    stRotation,\r\n    ellipsoid,\r\n    boundingRectangle\r\n  );\r\n}\r\n\r\nObject.defineProperties(PolygonGeometry.prototype, {\r\n  /**\r\n   * @private\r\n   */\r\n  rectangle: {\r\n    get: function () {\r\n      if (!defined(this._rectangle)) {\r\n        const positions = this._polygonHierarchy.positions;\r\n        this._rectangle = computeRectangle(\r\n          positions,\r\n          this._ellipsoid,\r\n          this._arcType,\r\n          this._granularity\r\n        );\r\n      }\r\n\r\n      return this._rectangle;\r\n    },\r\n  },\r\n  /**\r\n   * For remapping texture coordinates when rendering PolygonGeometries as GroundPrimitives.\r\n   * @private\r\n   */\r\n  textureCoordinateRotationPoints: {\r\n    get: function () {\r\n      if (!defined(this._textureCoordinateRotationPoints)) {\r\n        this._textureCoordinateRotationPoints = textureCoordinateRotationPoints(\r\n          this\r\n        );\r\n      }\r\n      return this._textureCoordinateRotationPoints;\r\n    },\r\n  },\r\n});\r\nexport default PolygonGeometry;\r\n","import { render } from \"./dynamic_building.vue?vue&type=template&id=53cc5236&scoped=true\"\nimport script from \"./dynamic_building.vue?vue&type=script&lang=js\"\nexport * from \"./dynamic_building.vue?vue&type=script&lang=js\"\n\nimport \"./dynamic_building.vue?vue&type=style&index=0&id=53cc5236&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-53cc5236\"]])\n\nexport default __exports__"],"names":["id","_createElementBlock","_hoisted_1","getFilenameFromUri","uri","defined","DeveloperError","uriObject","Uri","normalize","path","index","lastIndexOf","substr","PinBuilder","this","_cache","prototype","fromColor","color","size","createPin","undefined","fromUrl","url","fromMakiIconId","buildModuleUrl","encodeURIComponent","fromText","text","colorScratch","Color","drawPin","context2D","save","scale","fillStyle","toCssColorString","strokeStyle","brighten","lineWidth","beginPath","moveTo","lineTo","bezierCurveTo","closePath","fill","stroke","restore","drawIcon","image","imageSize","sizeX","sizeY","width","height","x","Math","round","y","globalCompositeOperation","drawImage","fillRect","stringifyScratch","Array","label","cache","JSON","stringify","item","canvas","document","createElement","getContext","resource","Resource","promise","fetchImage","then","writeTextToCanvas","font","array","n","t","j","length","i","transform","identity","x0","y0","kx","ky","dx","translate","dy","input","output","topology","o","objects","type","features","geometries","map","feature","bbox","properties","geometry","object","transformPoint","arcs","arc","points","pop","a","k","push","reverse","point","p","line","ring","polygon","coordinates","defaultCrsFunction","Cartesian3","crsNames","crsLinkHrefs","crsLinkTypes","defaultMarkerSymbol","defaultMarkerSize","defaultMarkerColor","defaultStroke","defaultStrokeWidth","defaultFill","defaultClampToGround","sizes","small","medium","large","simpleStyleIdentifiers","defaultDescribe","nameProperty","html","key","hasOwnProperty","indexOf","value","createDescriptionCallback","describe","description","time","result","defaultDescribeProperty","CallbackProperty","createObject","geoJson","entityCollection","finalId","getById","createGuid","entity","getOrCreateEntity","name","title","namePropertyPrecedence","Number","MAX_VALUE","lowerKey","toLowerCase","test","ConstantProperty","coordinatesArrayToCartesianArray","crsFunction","positions","geoJsonObjectTypes","Feature","processFeature","FeatureCollection","processFeatureCollection","GeometryCollection","processGeometryCollection","LineString","processLineString","MultiLineString","processMultiLineString","MultiPoint","processMultiPoint","MultiPolygon","processMultiPolygon","Point","processPoint","Polygon","processPolygon","Topology","processTopology","geometryTypes","dataSource","notUsed","options","_entityCollection","RuntimeError","geometryType","geometryHandler","featureCollection","len","geometryCollection","createPoint","symbol","markerSymbol","markerColor","markerSize","cssColor","defaultValue","canvasOrPromise","_pinBuilder","toUpperCase","billboard","BillboardGraphics","verticalOrigin","VerticalOrigin","clampToGround","heightReference","HeightReference","position","ConstantPositionProperty","Promise","resolve","catch","_promises","createLineString","material","strokeMaterialProperty","widthProperty","strokeWidthProperty","opacity","getValue","clone","alpha","ColorMaterialProperty","polylineGraphics","PolylineGraphics","polyline","arcType","ArcType","lineStrings","createPolygon","outlineColorProperty","fillMaterialProperty","fillColor","materialColor","PolygonGraphics","outline","outlineColor","outlineWidth","holes","PolygonHierarchy","hierarchy","perPositionHeight","polygons","property","topojson","typeHandler","GeoJsonDataSource","_name","_changed","Event","_error","_isLoading","_loading","EntityCollection","_entityCluster","EntityCluster","_credit","_resourceCredits","preload","that","data","clear","DataSource","credit","Credit","sourceUri","fetchJson","getUrlComponent","resourceCredits","credits","strokeWidth","load","error","raiseEvent","crs","handler","href","code","removeAll","all","Object","defineProperties","get","set","clock","writable","entities","isLoading","changedEvent","errorEvent","loadingEvent","show","clustering","process","update","scratchCarto1","Cartographic","scratchCarto2","adjustPosHeightsForNormal","p1","p2","ellipsoid","carto1","cartesianToCartographic","p1Carto","cartographicToCartesian","p2Carto","scratchBoundingRectangle","BoundingRectangle","scratchPosition","scratchNormal","scratchTangent","scratchBitangent","p1Scratch","p2Scratch","scratchPerPosNormal","scratchPerPosTangent","scratchPerPosBitangent","appendTextureCoordinatesOrigin","Cartesian2","appendTextureCoordinatesCartesian2","appendTextureCoordinatesCartesian3","appendTextureCoordinatesQuaternion","Quaternion","appendTextureCoordinatesMatrix3","Matrix3","tangentMatrixScratch","computeAttributes","vertexFormat","shadowVolume","flatPositions","attributes","values","flatTexcoords","st","wall","top","bottom","normal","tangent","bitangent","boundingRectangle","tangentPlane","stRotation","origin","textureCoordinates","Float32Array","normals","tangents","bitangents","extrudeNormals","textureCoordIndex","attrIndex","recomputeNormal","textureMatrix","tangentRotationMatrix","rotation","_plane","bottomOffset","bottomOffset2","scaleToGeodeticSurface","projectPointOntoPlane","attrIndex1","attrIndex2","CesiumMath","geodeticSurfaceNormal","z","GeometryAttribute","componentDatatype","ComponentDatatype","componentsPerAttribute","extrudeDirection","extrude","offsetAttribute","Uint8Array","GeometryOffsetAttribute","offsetValue","applyOffset","startCartographicScratch","endCartographicScratch","idlCross","westOverIDL","eastOverIDL","ellipsoidGeodesic","EllipsoidGeodesic","computeRectangle","granularity","Rectangle","west","north","south","east","equals","POSITIVE_INFINITY","NEGATIVE_INFINITY","inverseChordLength","maximumRadius","positionsLength","swap","endCartographic","startCartographic","setEndPoints","interpolateAndGrowRectangle","interpolatedCartographicScratch","segmentLength","surfaceDistance","numPoints","ceil","subsegmentDistance","interpolationDistance","interpolatedCartographic","interpolateUsingSurfaceDistance","longitude","latitude","min","max","lonAdjusted","createGeometryFromPositionsExtrudedPositions","createGeometryFromPositionsExtruded","closeTop","closeBottom","geos","walls","topGeo","PolygonGeometryLibrary","edgePoints","indices","numPositions","newIndices","topBottomPositions","concat","IndexDatatype","ilength","i0","i1","i2","texcoords","topAndBottom","GeometryInstance","outerRing","EllipsoidTangentPlane","positions2D","projectPointsOntoPlane","windingOrder","PolygonPipeline","WindingOrder","slice","wallGeo","hole","PolygonGeometry","Check","polygonHierarchy","VertexFormat","Ellipsoid","perPositionHeightExtrude","extrudedHeight","h","_vertexFormat","_ellipsoid","_granularity","_stRotation","_height","_extrudedHeight","_closeTop","_closeBottom","_polygonHierarchy","_perPositionHeight","_perPositionHeightExtrude","_shadowVolume","_workerName","_offsetAttribute","_arcType","_rectangle","_textureCoordinateRotationPoints","_textureCoordinates","packedLength","fromPositions","newOptions","pack","startingIndex","scratchEllipsoid","scratchVertexFormat","dummyOptions","textureCoordinateRotationPoints","polygonGeometry","rectangle","Geometry","unpack","createGeometry","hasTextureCoordinates","outerPositions","results","bind","dummyFunction","textureCoordinatePolygons","plane","splitGeometry","geometryInstance","GeometryPipeline","Float64Array","boundingSphere","BoundingSphere","primitiveType","createShadowVolume","minHeightFunc","maxHeightFunc","minHeight","maxHeight","building","mounted","init","methods","viewer","Viewer","FeatureDetection","resolutionScale","window","devicePixelRatio","scene","postProcessStages","fxaa","enabled","fragmentShaderSource","geometryInstances","random","primitive","primitives","add","Primitive","asynchronous","appearance","MaterialAppearance","Material","translucent","fabric","uniforms","offset1","offset2","source","preUpdate","addEventListener","offset","center","camera","lookAt","lookAtTransform","Matrix4","__exports__","render"],"sourceRoot":""}