{"version":3,"file":"js/6631.faeb93c0.js","mappings":"wOACSA,MAAM,a,UAAYC,EAAAA,EAAAA,GAAwB,UAAhBC,GAAG,KAAG,W,GAAdC,G,0CAAvBC,EAAAA,EAAAA,IAAqD,MAArDC,EAAqD,E,2CAIzD,MAAMC,EAAmB,CAErBC,MAAO,IAAIC,EAAAA,IAAc,IAAIA,EAAAA,IAAc,EAAG,EAAG,KACjDC,KAAM,IAAID,EAAAA,IAAc,IAAIA,EAAAA,IAAc,GAAI,GAAI,MAEhDE,EAAOC,GAAuB,GAAhBC,KAAKC,IAAIF,GAAa,GACpCG,EAAqB,CACvBC,SAAUT,EACVU,cAAe,40BAkBfC,MAAO,CAACC,EAAUC,KACd,IAAIC,EAAsB,IAEtBb,EAAQD,EAAiBC,MAAMc,MAC/BZ,EAAOH,EAAiBG,KAAKY,MAE7BC,EAAa,IAAId,EAAAA,IACjBI,KAAKW,IAAIL,EAAWN,KAAKY,GAAKjB,EAAMkB,EAAIN,GAAQV,EAAKgB,EACrDb,KAAKW,IAAIH,EAAsBR,KAAKY,GAAKjB,EAAMkB,EAAIN,GAAQV,EAAKgB,EAChEf,EAAKQ,EAAWN,KAAKY,GAAKjB,EAAMmB,EAAIP,GAAQV,EAAKiB,EACjDhB,EAAKU,EAAsBR,KAAKY,GAAKjB,EAAMmB,EAAIP,GAAQV,EAAKiB,EAC5DhB,EAAKQ,EAAWN,KAAKY,GAAKjB,EAAMoB,EAAIR,GAAQV,EAAKkB,EACjDjB,EAAKU,EAAsBR,KAAKY,GAAKjB,EAAMoB,EAAIR,GAAQV,EAAKkB,GAG5DC,EAAY,IAAIpB,EAAAA,IAAc,EAAG,EAAG,GACpCqB,EAAe,IAAIrB,EAAAA,IAAc,EAAG,GAAI,GAC5C,OAAOc,EAAWQ,SAASF,GAAWG,IAAIF,EAAa,GAG/D,MAAMG,EACFC,YAAYC,EAAQC,GAChBC,KAAKD,QAAUA,EACfC,KAAKF,OAASA,EACdE,KAAKC,MAAQ,IAAI7B,EAAAA,IACjB4B,KAAKE,SAAW,IAAI9B,EAAAA,IAAoB,CAAE0B,OAAQE,KAAKF,OAAQK,WAAW,IAC1EH,KAAKE,SAASE,QAAQJ,KAAKF,OAAOO,WAAYL,KAAKF,OAAOQ,aAC1DN,KAAKE,SAASK,cAAcC,OAAOC,kBAEnCT,KAAKU,MAAQ,IAAItC,EAAAA,IACjB4B,KAAKW,OAAS,IAAIvC,EAAAA,IAAwB,GAAI4B,KAAKF,OAAOc,YAAcZ,KAAKF,OAAOe,aAAc,GAAK,KACvGb,KAAKW,OAAOG,SAASvB,GAAK,EAC1BS,KAAKW,OAAOG,SAASxB,EAAI,EACzBU,KAAKW,OAAOG,SAASzB,EAAI,EAEzBW,KAAKe,YAAcf,KAAKe,YAAYC,KAAKhB,MACzCA,KAAKiB,UAAYjB,KAAKiB,UAAUD,KAAKhB,MACrCA,KAAKF,OAAOoB,iBAAiB,YAAalB,KAAKe,aAC/Cf,KAAKF,OAAOoB,iBAAiB,UAAWlB,KAAKiB,WAC7CjB,KAAKF,OAAOoB,iBAAiB,WAAYlB,KAAKiB,WAE9CjB,KAAKmB,MACT,CACAA,OACI,MAAMpB,EAAUC,KAAKD,QACrBC,KAAKoB,cAAgB,EACrBpB,KAAKqB,QAAU,EACfrB,KAAKsB,WAAa,EAClBtB,KAAKuB,UAAY,GAEjBvB,KAAKwB,KAAO,IAAIC,EAAKzB,KAAKU,MAAOX,GACjCC,KAAK0B,WAAa,IAAIC,EAAU3B,KAAKU,MAAOX,EAASA,EAAQ6B,MAAMC,SAAU,IAC7E7B,KAAK0B,WAAWI,KAAKhB,SAASiB,MACzBhC,EAAQiC,UAAY,EAAIjC,EAAQkC,YAAc,GAEnDjC,KAAKkC,YAAc,IAAIP,EAAU3B,KAAKU,MAAOX,EAASA,EAAQ6B,MAAMO,WAAY,IAChFnC,KAAKkC,YAAYJ,KAAKhB,SAASiB,KAC3BhC,EAAQiC,UAAY,EAAIjC,EAAQkC,YAAc,GAElDjC,KAAKoC,WAAa,IAAIC,EAAarC,KAAKU,MAAOX,GAC/CC,KAAKoC,WAAWN,KAAKhB,SAASiB,OACxBhC,EAAQiC,UAAYjC,EAAQkC,YAAc,GAEpD,CAEAK,OAAOC,GACH,IAAIC,GAAe,GAAKhE,KAAKiE,KAAK,IAC9BC,EAAQlE,KAAKmE,KAAKH,EAAcD,GACpCvC,KAAKqB,SAAWuB,EACZ5C,KAAKqB,QACLrB,KAAKoB,cAELsB,EACA,MAGJ1C,KAAKsB,YAActB,KAAKqB,QAAUkB,EAElC,IAAIxD,EAAOiB,KAAKC,MAAM4C,YAAc7C,KAAKsB,WACzCtB,KAAKwB,KAAKc,OAAOvD,GACjBiB,KAAK0B,WAAWY,OAAOvD,GACvBiB,KAAKkC,YAAYI,OAAOvD,GACxBiB,KAAKoC,WAAWE,OAAOvD,GAEvB,IAAI+D,EAAYF,EAAK5C,KAAKW,OAAOoC,IAAK/C,KAAKuB,UAAWmB,GAKtD,GAJkB,IAAdI,IACA9C,KAAKW,OAAOoC,KAAOD,EAAYP,EAAQ,EACvCvC,KAAKW,OAAOqC,0BAEZhD,KAAKD,QAAQb,WAAWL,MAAO,CAC/B,MAAMK,EAAac,KAAKD,QAAQb,WAAWL,MAAM,KAAOE,GAExDiB,KAAKW,OAAOsC,OACR,IAAI7E,EAAAA,IACA4B,KAAKW,OAAOG,SAASzB,EAAIH,EAAWG,EACpCW,KAAKW,OAAOG,SAASxB,EAAIJ,EAAWI,EACpCU,KAAKW,OAAOG,SAASvB,EAAIL,EAAWK,GAEhD,CACJ,CACAwB,YAAYmC,GACRlD,KAAKoB,cAAgB,EACrBpB,KAAKuB,UAAY,GACrB,CACAN,UAAUiC,GACNlD,KAAKoB,cAAgB,EACrBpB,KAAKuB,UAAY,EACrB,CACA4B,4BAA4BjD,GACxB,MAAMJ,EAASI,EAASkD,WAClBC,EAAQvD,EAAOc,YACf0C,EAASxD,EAAOe,aAChB0C,EAAazD,EAAOuD,QAAUA,GAASvD,EAAOwD,SAAWA,EAI/D,OAHIC,GACArD,EAASE,QAAQiD,EAAOC,GAAQ,GAE7BC,CACX,CACAC,SACI,GAAIxD,KAAKmD,4BAA4BnD,KAAKE,UAAW,CACjD,MAAMJ,EAASE,KAAKE,SAASkD,WAC7BpD,KAAKW,OAAO8C,OAAS3D,EAAOc,YAAcd,EAAOe,aACjDb,KAAKW,OAAOqC,wBAChB,CACA,MAAMT,EAAQvC,KAAKC,MAAMyD,WACzB1D,KAAKsC,OAAOC,GACZvC,KAAKE,SAASsD,OAAOxD,KAAKU,MAAOV,KAAKW,QACtCgD,sBAAsB3D,KAAKwD,OAAOxC,KAAKhB,MAC3C,EAEJ,MAAMyB,EACF5B,YAAYa,EAAOX,GACfC,KAAKU,MAAQA,EACbV,KAAKD,QAAUA,EACfC,KAAKmB,MACT,CACAA,OACI,MAAMpB,EAAUC,KAAKD,QACf6D,EAAW,IAAIxF,EAAAA,IAA0B2B,EAAQsD,MAAOtD,EAAQ8D,OAAQ,GAAI,KAE5EC,EAAW,IAAI1F,EAAAA,IAAqB,CACtCO,SAAUoF,OAAOC,OACb,CACIC,OAAQ,IAAI7F,EAAAA,IAAc,IAAIA,EAAAA,IAAY,UAC1C8F,MAAO,IAAI9F,EAAAA,IAAc,GACzB+F,cAAe,IAAI/F,EAAAA,IAAc2B,EAAQ8D,SAE7C9D,EAAQb,WAAWP,UAEvByF,aAAc,moBAcdC,eAAgB,iKAMhBC,KAAMlG,EAAAA,MAEV0F,EAASS,gBAAkBC,IACvBA,EAAOJ,aAAeI,EAAOJ,aAAaK,QACtC,kCACA1E,EAAQb,WAAWN,cACtB,EAEL,MAAMkD,EAAO,IAAI1D,EAAAA,IAAWwF,EAAUE,GAEtChC,EAAK4C,SAASrF,GAAKb,KAAKY,GAAK,EAC7B0C,EAAKhB,SAASvB,GAAKQ,EAAQ8D,OAAS,EAEpC7D,KAAKU,MAAMf,IAAImC,GACf9B,KAAK8B,KAAOA,CAChB,CACAQ,OAAOvD,GACHiB,KAAK8B,KAAKgC,SAASnF,SAASuF,MAAMjF,MAAQF,CAC9C,EAEJ,MAAM4C,EACF9B,YAAYa,EAAOX,EAAS4E,EAAQC,GAChC5E,KAAKU,MAAQA,EACbV,KAAKD,QAAUA,EACfC,KAAK2E,OAASA,EACd3E,KAAK4E,MAAQA,EACb5E,KAAKmB,MACT,CACAA,OACI,MAAMpB,EAAUC,KAAKD,QAEf8E,EAAQ,IAAIzG,EAAAA,GACd,IAAIA,EAAAA,IAAc,EAAG,EAAG,GACxB,IAAIA,EAAAA,IAAc,EAAG,GAAI,IAEvB0G,EAAe,IAAI1G,EAAAA,IAAyByG,EAAO,GAAI,EAAG,GAAG,GAE7DE,GAAY,IAAI3G,EAAAA,KAAgC4G,KAAKF,GAC3DC,EAAUE,cAAiC,EAAjBlF,EAAQmF,OAElC,IAAIC,EAAU,GACVC,EAAW,GACXC,EAAS,GAETV,EAAS3E,KAAK2E,OAEdA,EADAW,MAAMC,QAAQZ,GACLA,EAAOa,KAAIC,GAAK,IAAIrH,EAAAA,IAAYqH,KAEhC,IAAIrH,EAAAA,IAAYuG,GAG7B,IAAIe,EAAe3F,EAAQiC,UAAYjC,EAAQ4F,aAC/C,IAAK,IAAIC,EAAI,EAAGA,EAAI7F,EAAQmF,OAAQU,IAAK,CACrC,IAAIC,EAAyB,GAAhBrH,KAAKsH,SAAiB,GAC/BjC,EACArF,KAAKsH,SAAW/F,EAAQ8D,OAAS,IAAwB,IAAjB9D,EAAQ8D,OAGhDkC,EAAUH,EAAI,EAGdI,EAAWD,EAAUL,EAAe3F,EAAQiC,UAAY,EAAI0D,EAAe,EAC3EO,EAAW,GAAMP,EACjBQ,EAAU,GAAM1H,KAAKsH,SAErBK,EAAmB,IAATN,EAEVO,EAAU5H,KAAKsH,SAAW/F,EAAQ8D,OAEtCsB,EAAQkB,KAAKL,EAAWC,EAAW,EAAIC,GACvCf,EAAQkB,KAAKF,GACbhB,EAAQkB,MAAMD,GAEdjB,EAAQkB,KAAKL,EAAWC,EAAW,EAAIC,GACvCf,EAAQkB,KAAKF,GACbhB,EAAQkB,MAAMD,GAEdhB,EAASiB,KAAKR,GACdT,EAASiB,KAAKxC,GAEduB,EAASiB,KAAKR,GACdT,EAASiB,KAAKxC,GAEd,IAAIjC,EAAQ0E,EAAW3B,GACvBU,EAAOgB,KAAKzE,EAAM2E,GAClBlB,EAAOgB,KAAKzE,EAAM4E,GAClBnB,EAAOgB,KAAKzE,EAAM6E,GAElBpB,EAAOgB,KAAKzE,EAAM2E,GAClBlB,EAAOgB,KAAKzE,EAAM4E,GAClBnB,EAAOgB,KAAKzE,EAAM6E,EACtB,CAEA1B,EAAU2B,aACN,UACA,IAAItI,EAAAA,IAA+B,IAAIuI,aAAaxB,GAAU,GAAG,IAErEJ,EAAU2B,aACN,WACA,IAAItI,EAAAA,IAA+B,IAAIuI,aAAavB,GAAW,GAAG,IAEtEL,EAAU2B,aACN,SACA,IAAItI,EAAAA,IAA+B,IAAIuI,aAAatB,GAAS,GAAG,IAEpE,MAAMvB,EAAW,IAAI1F,EAAAA,IAAqB,CACtCiG,eAAgB,6JAMhBD,aAAc,+xCAmCdzF,SAAUoF,OAAOC,OACb,CACIC,OAAQ,IAAI7F,EAAAA,IAAc,IAAIA,EAAAA,IAAY4B,KAAK4B,QAC/CuC,cAAe,IAAI/F,EAAAA,IAAc2B,EAAQ8D,QACzCK,MAAO,IAAI9F,EAAAA,IAAc,GACzBwI,OAAQ,IAAIxI,EAAAA,IAAc4B,KAAK4E,QAEnC7E,EAAQb,WAAWP,YAG3BmF,EAASS,gBAAkBC,IACvBA,EAAOJ,aAAeI,EAAOJ,aAAaK,QACtC,kCACA1E,EAAQb,WAAWN,cACtB,EAEL,IAAIkD,EAAO,IAAI1D,EAAAA,IAAW2G,EAAWjB,GACrChC,EAAK+E,eAAgB,EACrB7G,KAAK8B,KAAOA,EACZ9B,KAAKU,MAAMf,IAAImC,EACnB,CACAQ,OAAOvD,GACHiB,KAAK8B,KAAKgC,SAASnF,SAASuF,MAAMjF,MAAQF,CAC9C,EAEJ,MAAMsD,EACFxC,YAAYa,EAAOX,GACfC,KAAKU,MAAQA,EACbV,KAAKD,QAAUA,EACfC,KAAKmB,MACT,CACAA,OACI,MAAMpB,EAAUC,KAAKD,QACf6D,EAAW,IAAIxF,EAAAA,IAA0B,EAAG,GAClD,IAAI2G,GAAY,IAAI3G,EAAAA,KAAgC4G,KAAKpB,GACrDkD,EAAc/G,EAAQgH,qBAC1BhC,EAAUE,cAAgB6B,EAE1B,IAAIE,EAAcjH,EAAQ8D,QAAUiD,EAAc,GAClD,MAAM3B,EAAU,GACVE,EAAS,GACTD,EAAW,GAEjB,IAAIT,EAAS3E,KAAKD,QAAQ6B,MAAMqF,OAG5BtC,EADAW,MAAMC,QAAQZ,GACLA,EAAOa,KAAIC,GAAK,IAAIrH,EAAAA,IAAYqH,KAEhC,IAAIrH,EAAAA,IAAYuG,GAG7B,IAAK,IAAIiB,EAAI,EAAGA,EAAIkB,EAAalB,IAAK,CAClC,IAAIvC,EAAQyC,EAAO/F,EAAQmH,iBACvB5D,EAASwC,EAAO/F,EAAQoH,kBAC5BhC,EAAQkB,MAAMT,EAAI,GAAKoB,EAAc,EAAIA,EAAcxI,KAAKsH,UAE5D,IAAIlE,EAAQ0E,EAAW3B,GACvBU,EAAOgB,KAAKzE,EAAM2E,GAClBlB,EAAOgB,KAAKzE,EAAM4E,GAClBnB,EAAOgB,KAAKzE,EAAM6E,GAElBrB,EAASiB,KAAKhD,GACd+B,EAASiB,KAAK/C,EAClB,CACAyB,EAAU2B,aACN,UACA,IAAItI,EAAAA,IAA+B,IAAIuI,aAAaxB,GAAU,GAAG,IAErEJ,EAAU2B,aACN,SACA,IAAItI,EAAAA,IAA+B,IAAIuI,aAAatB,GAAS,GAAG,IAEpEN,EAAU2B,aACN,WACA,IAAItI,EAAAA,IAA+B,IAAIuI,aAAavB,GAAW,GAAG,IAEtE,MAAMtB,EAAW,IAAI1F,EAAAA,IAAqB,CACtCiG,eAAgB,gNAOhBD,aAAc,+jDA0CdE,KAAMlG,EAAAA,IACNO,SAAUoF,OAAOC,OACb,CACIG,cAAe,IAAI/F,EAAAA,IAAc2B,EAAQ8D,QACzCK,MAAO,IAAI9F,EAAAA,IAAc,IAE7B2B,EAAQb,WAAWP,YAI3BmF,EAASS,gBAAkBC,IACvBA,EAAOJ,aAAeI,EAAOJ,aAAaK,QACtC,kCACA1E,EAAQb,WAAWN,cACtB,EAGL,MAAMkD,EAAO,IAAI1D,EAAAA,IAAW2G,EAAWjB,GAEvChC,EAAK+E,eAAgB,EAErB7G,KAAKU,MAAMf,IAAImC,GACf9B,KAAK8B,KAAOA,CAChB,CACAQ,OAAOvD,GACHiB,KAAK8B,KAAKgC,SAASnF,SAASuF,MAAMjF,MAAQF,CAC9C,EAGJ,SAAS+G,EAAOsB,GACZ,OAAI9B,MAAMC,QAAQ6B,GAAc5I,KAAKsH,UAAYsB,EAAK,GAAKA,EAAK,IAAMA,EAAK,GACpE5I,KAAKsH,SAAWsB,CAC3B,CACA,SAASd,EAAWe,GAChB,OAAI/B,MAAMC,QAAQ8B,GAAaA,EAAI7I,KAAK8I,MAAM9I,KAAKsH,SAAWuB,EAAIxD,SAC3DwD,CACX,CACA,SAASzE,EAAK2E,EAASC,EAAQ5C,EAAQ,GAAK6C,EAAQ,MAChD,IAAIC,GAAUF,EAASD,GAAW3C,EAIlC,OAHIpG,KAAKmJ,IAAID,GAAUD,IACnBC,EAASF,EAASD,GAEfG,CACX,CACA,OACIE,UACI5H,KAAKmB,MACT,EACA0G,QAAS,CACL1G,OACI,MAAMrB,EAASgI,SAASC,cAAc,MAChChI,EAAU,CACZ8D,OAAQ,IACRR,MAAO,GACPrB,UAAW,EACXC,YAAa,EACbiD,OAAQ,GACRS,aAAc,EACdzG,WAAYR,EAEZqI,qBAAsB,GACtBG,gBAAiB,CAAC,IAAM,IACxBC,iBAAkB,CAAC,IAAK,KAExBvF,MAAO,CAEHC,SAAU,CAAC,SAAU,SAAU,UAC/BM,UAAW,CAAC,SAAU,SAAU,SAChC8E,OAAQ,WAGVe,EAAM,IAAIpI,EAAIE,EAAQC,GAC5BiI,EAAIxE,QACR,I,WC3hBR,MAAMyE,GAA2B,OAAgB,EAAQ,CAAC,CAAC,SAASzE,GAAQ,CAAC,YAAY,qBAEzF,O","sources":["webpack://webgis/./src/components/three/high_speed_light_trails.vue","webpack://webgis/./src/components/three/high_speed_light_trails.vue?e9ca"],"sourcesContent":["<template>\r\n    <div class=\"container\"><canvas id=\"c\"></canvas></div>\r\n</template>\r\n<script>\r\nimport * as THREE from 'three'\r\nconst mountainUniforms = {\r\n    // x, y, z\r\n    uFreq: new THREE.Uniform(new THREE.Vector3(3, 6, 10)),\r\n    uAmp: new THREE.Uniform(new THREE.Vector3(30, 30, 20))\r\n};\r\nconst nsin = val => Math.sin(val) * 0.5 + 0.5;\r\nconst mountainDistortion = {\r\n    uniforms: mountainUniforms,\r\n    getDistortion: `\r\n                uniform vec3 uAmp;\r\n                uniform vec3 uFreq;\r\n\r\n                #define PI 3.14159265358979\r\n                float nsin(float val){\r\n                    return sin(val) * 0.5+0.5;\r\n                }\r\n                \r\n                vec3 getDistortion(float progress){\r\n                    float movementProgressFix = 0.02;\r\n                    return vec3( \r\n                        cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\r\n                        nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\r\n                        nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\r\n                    );\r\n                }\r\n            `,\r\n    getJS: (progress, time) => {\r\n        let movementProgressFix = 0.02;\r\n\r\n        let uFreq = mountainUniforms.uFreq.value;\r\n        let uAmp = mountainUniforms.uAmp.value;\r\n\r\n        let distortion = new THREE.Vector3(\r\n            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\r\n            Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\r\n            nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\r\n            nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\r\n            nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\r\n            nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z\r\n        );\r\n\r\n        let lookAtAmp = new THREE.Vector3(2, 2, 2);\r\n        let lookAtOffset = new THREE.Vector3(0, 0, -5);\r\n        return distortion.multiply(lookAtAmp).add(lookAtOffset);\r\n    }\r\n};\r\nclass App {\r\n    constructor(canvas, options) {\r\n        this.options = options\r\n        this.canvas = canvas\r\n        this.clock = new THREE.Clock();\r\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });\r\n        this.renderer.setSize(this.canvas.innerWidth, this.canvas.innerHeight)\r\n        this.renderer.setPixelRatio(window.devicePixelRatio)\r\n\r\n        this.scene = new THREE.Scene()\r\n        this.camera = new THREE.PerspectiveCamera(45, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 10000)\r\n        this.camera.position.z = -5;\r\n        this.camera.position.y = 7;\r\n        this.camera.position.x = 0;\r\n\r\n        this.onMouseDown = this.onMouseDown.bind(this);\r\n        this.onMouseUp = this.onMouseUp.bind(this);\r\n        this.canvas.addEventListener(\"mousedown\", this.onMouseDown);\r\n        this.canvas.addEventListener(\"mouseup\", this.onMouseUp);\r\n        this.canvas.addEventListener(\"mouseout\", this.onMouseUp);\r\n\r\n        this.init()\r\n    }\r\n    init() {\r\n        const options = this.options;\r\n        this.speedUpTarget = 0;\r\n        this.speedUp = 0;\r\n        this.timeOffset = 0;\r\n        this.fovTarget = 90;\r\n\r\n        this.road = new Road(this.scene, options);\r\n        this.leftLights = new CarLights(this.scene, options, options.color.leftCars, 60);\r\n        this.leftLights.mesh.position.setX(\r\n            -options.roadWidth / 2 - options.islandWidth / 2\r\n        );\r\n        this.rightLights = new CarLights(this.scene, options, options.color.rightCars, -60);\r\n        this.rightLights.mesh.position.setX(\r\n            options.roadWidth / 2 + options.islandWidth / 2\r\n        );\r\n        this.leftSticks = new LightsSticks(this.scene, options);\r\n        this.leftSticks.mesh.position.setX(\r\n            -(options.roadWidth + options.islandWidth / 2)\r\n        );\r\n    }\r\n\r\n    update(delta) {\r\n        let coefficient = -60 * Math.log2(1 - 0.1);\r\n        let lerpT = Math.exp(-coefficient * delta);\r\n        this.speedUp += lerp(\r\n            this.speedUp,\r\n            this.speedUpTarget,\r\n            // 10% each frame\r\n            lerpT,\r\n            0.00001\r\n        );\r\n        // Also frame-dependent\r\n        this.timeOffset += this.speedUp * delta;\r\n\r\n        let time = this.clock.elapsedTime + this.timeOffset;\r\n        this.road.update(time)\r\n        this.leftLights.update(time);\r\n        this.rightLights.update(time);\r\n        this.leftSticks.update(time);\r\n\r\n        let fovChange = lerp(this.camera.fov, this.fovTarget, lerpT);\r\n        if (fovChange !== 0) {\r\n            this.camera.fov += fovChange * delta * 6;\r\n            this.camera.updateProjectionMatrix();\r\n        }\r\n        if (this.options.distortion.getJS) {\r\n            const distortion = this.options.distortion.getJS(0.025, time);\r\n\r\n            this.camera.lookAt(\r\n                new THREE.Vector3(\r\n                    this.camera.position.x + distortion.x,\r\n                    this.camera.position.y + distortion.y,\r\n                    this.camera.position.z + distortion.z\r\n                ))\r\n        }\r\n    }\r\n    onMouseDown(ev) {\r\n        this.speedUpTarget = 4;\r\n        this.fovTarget = 140;\r\n    }\r\n    onMouseUp(ev) {\r\n        this.speedUpTarget = 0;\r\n        this.fovTarget = 90;\r\n    }\r\n    resizeRendererToDisplaySize(renderer) {\r\n        const canvas = renderer.domElement\r\n        const width = canvas.clientWidth\r\n        const height = canvas.clientHeight\r\n        const needResize = canvas.width !== width || canvas.height !== height\r\n        if (needResize) {\r\n            renderer.setSize(width, height, false)\r\n        }\r\n        return needResize\r\n    }\r\n    render() {\r\n        if (this.resizeRendererToDisplaySize(this.renderer)) {\r\n            const canvas = this.renderer.domElement\r\n            this.camera.aspect = canvas.clientWidth / canvas.clientHeight\r\n            this.camera.updateProjectionMatrix()\r\n        }\r\n        const delta = this.clock.getDelta();\r\n        this.update(delta);\r\n        this.renderer.render(this.scene, this.camera);\r\n        requestAnimationFrame(this.render.bind(this));\r\n    }\r\n}\r\nclass Road {\r\n    constructor(scene, options) {\r\n        this.scene = scene;\r\n        this.options = options;\r\n        this.init()\r\n    }\r\n    init() {\r\n        const options = this.options;\r\n        const geometry = new THREE.PlaneBufferGeometry(options.width, options.length, 20, 200\r\n        );\r\n        const material = new THREE.ShaderMaterial({\r\n            uniforms: Object.assign(\r\n                {\r\n                    uColor: new THREE.Uniform(new THREE.Color(0x101012)),\r\n                    uTime: new THREE.Uniform(0),\r\n                    uTravelLength: new THREE.Uniform(options.length)\r\n                },\r\n                options.distortion.uniforms\r\n            ),\r\n            vertexShader: `\r\n                uniform float uTravelLength;\r\n                uniform float uTime;\r\n                #include <getDistortion_vertex>\r\n                void main(){\r\n                    vec3 transformed = position.xyz;\r\n                        \r\n                    float progress = (transformed.y + uTravelLength / 2.) / uTravelLength;\r\n                    vec3 distortion  = getDistortion(progress);\r\n                    transformed.x += distortion.x;\r\n                    transformed.z += distortion.y;\r\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.);\r\n                }\r\n                `,\r\n            fragmentShader: `\r\n                uniform vec3 uColor;\r\n                void main(){\r\n                    gl_FragColor = vec4(uColor,1.);\r\n                }\r\n                `,\r\n            side: THREE.DoubleSide\r\n        })\r\n        material.onBeforeCompile = shader => {\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n                \"#include <getDistortion_vertex>\",\r\n                options.distortion.getDistortion\r\n            );\r\n        };\r\n        const mesh = new THREE.Mesh(geometry, material);\r\n\r\n        mesh.rotation.x = -Math.PI / 2;\r\n        mesh.position.z = -options.length / 2;\r\n\r\n        this.scene.add(mesh);\r\n        this.mesh = mesh\r\n    }\r\n    update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;\r\n    }\r\n}\r\nclass CarLights {\r\n    constructor(scene, options, colors, speed) {\r\n        this.scene = scene;\r\n        this.options = options;\r\n        this.colors = colors;\r\n        this.speed = speed;\r\n        this.init()\r\n    }\r\n    init() {\r\n        const options = this.options;\r\n\r\n        const curve = new THREE.LineCurve3(\r\n            new THREE.Vector3(0, 0, 0),\r\n            new THREE.Vector3(0, 0, -1)\r\n        )\r\n        const baseGeometry = new THREE.TubeBufferGeometry(curve, 25, 1, 8, false);\r\n\r\n        const instanced = new THREE.InstancedBufferGeometry().copy(baseGeometry);\r\n        instanced.instanceCount = options.nPairs * 2;\r\n\r\n        let aOffset = [];\r\n        let aMetrics = [];\r\n        let aColor = [];\r\n\r\n        let colors = this.colors;\r\n        if (Array.isArray(colors)) {\r\n            colors = colors.map(c => new THREE.Color(c));\r\n        } else {\r\n            colors = new THREE.Color(colors);\r\n        }\r\n\r\n        let sectionWidth = options.roadWidth / options.roadSections;\r\n        for (let i = 0; i < options.nPairs; i++) {\r\n            let radius = Math.random() * 0.1 + 0.1;\r\n            let length =\r\n                Math.random() * options.length * 0.08 + options.length * 0.02;\r\n            // 1a. Get it's lane index\r\n            // Instead of random, keep lights per lane consistent\r\n            let section = i % 3;\r\n\r\n            // 1b. Get its lane's centered position\r\n            let sectionX = section * sectionWidth - options.roadWidth / 2 + sectionWidth / 2;\r\n            let carWidth = 0.5 * sectionWidth;\r\n            let offsetX = 0.5 * Math.random();\r\n\r\n            let offsetY = radius * 1.3;\r\n\r\n            let offsetZ = Math.random() * options.length;\r\n\r\n            aOffset.push(sectionX - carWidth / 2 + offsetX);\r\n            aOffset.push(offsetY);\r\n            aOffset.push(-offsetZ);\r\n\r\n            aOffset.push(sectionX + carWidth / 2 + offsetX);\r\n            aOffset.push(offsetY);\r\n            aOffset.push(-offsetZ);\r\n\r\n            aMetrics.push(radius);\r\n            aMetrics.push(length);\r\n\r\n            aMetrics.push(radius);\r\n            aMetrics.push(length);\r\n\r\n            let color = pickRandom(colors);\r\n            aColor.push(color.r);\r\n            aColor.push(color.g);\r\n            aColor.push(color.b);\r\n\r\n            aColor.push(color.r);\r\n            aColor.push(color.g);\r\n            aColor.push(color.b);\r\n        }\r\n        // Add the offset to the instanced geometry.\r\n        instanced.setAttribute(\r\n            \"aOffset\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false)\r\n        );\r\n        instanced.setAttribute(\r\n            \"aMetrics\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\r\n        );\r\n        instanced.setAttribute(\r\n            \"aColor\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\r\n        );\r\n        const material = new THREE.ShaderMaterial({\r\n            fragmentShader: `\r\n                in vec3 vColor;\r\n                void main() {\r\n                    gl_FragColor = vec4(vColor,1.);\r\n                }\r\n                `,\r\n            vertexShader: `\r\n                in vec3 aOffset;\r\n                in vec2 aMetrics;\r\n                in vec3 aColor;\r\n                out vec3 vColor;\r\n                uniform float uTime;\r\n                uniform float uSpeed;\r\n                uniform float uTravelLength;\r\n                #include <getDistortion_vertex>\r\n                void main() {\r\n                    vec3 transformed = position.xyz;\r\n\r\n                    float radius = aMetrics.r;\r\n                    float len = aMetrics.g;\r\n                    transformed.xy *= radius; \r\n                    transformed.z *= len;\r\n\r\n                    float zOffset = uTime * uSpeed + aOffset.z;\r\n                    zOffset = len - mod(zOffset, uTravelLength);\r\n\r\n                    // transformed.z +=uTime * uSpeed;\r\n\r\n\r\n                    // Keep them separated to make the next step easier!\r\n                    transformed.z = transformed.z +zOffset ;\r\n                    transformed.xy += aOffset.xy;\r\n\r\n\r\n                    float progress = abs(transformed.z / uTravelLength);\r\n                    transformed.xyz += getDistortion(progress);\r\n\r\n                    vColor = aColor;\r\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\r\n                    gl_Position = projectionMatrix * mvPosition;\r\n                }`,\r\n            uniforms: Object.assign(\r\n                {\r\n                    uColor: new THREE.Uniform(new THREE.Color(this.color)),\r\n                    uTravelLength: new THREE.Uniform(options.length),\r\n                    uTime: new THREE.Uniform(0),\r\n                    uSpeed: new THREE.Uniform(this.speed)\r\n                },\r\n                options.distortion.uniforms\r\n            )\r\n        });\r\n        material.onBeforeCompile = shader => {\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n                \"#include <getDistortion_vertex>\",\r\n                options.distortion.getDistortion\r\n            );\r\n        };\r\n        let mesh = new THREE.Mesh(instanced, material);\r\n        mesh.frustumCulled = false;\r\n        this.mesh = mesh;\r\n        this.scene.add(mesh);\r\n    }\r\n    update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;\r\n    }\r\n}\r\nclass LightsSticks {\r\n    constructor(scene, options) {\r\n        this.scene = scene;\r\n        this.options = options;\r\n        this.init()\r\n    }\r\n    init() {\r\n        const options = this.options;\r\n        const geometry = new THREE.PlaneBufferGeometry(1, 1);\r\n        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\r\n        let totalSticks = options.totalSideLightSticks;\r\n        instanced.instanceCount = totalSticks;\r\n\r\n        let stickoffset = options.length / (totalSticks - 1);\r\n        const aOffset = [];\r\n        const aColor = [];\r\n        const aMetrics = [];\r\n\r\n        let colors = this.options.color.sticks\r\n\r\n        if (Array.isArray(colors)) {\r\n            colors = colors.map(c => new THREE.Color(c));\r\n        } else {\r\n            colors = new THREE.Color(colors);\r\n        }\r\n\r\n        for (let i = 0; i < totalSticks; i++) {\r\n            let width = random(options.lightStickWidth);\r\n            let height = random(options.lightStickHeight);\r\n            aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\r\n\r\n            let color = pickRandom(colors);\r\n            aColor.push(color.r);\r\n            aColor.push(color.g);\r\n            aColor.push(color.b);\r\n\r\n            aMetrics.push(width);\r\n            aMetrics.push(height);\r\n        }\r\n        instanced.setAttribute(\r\n            \"aOffset\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false)\r\n        );\r\n        instanced.setAttribute(\r\n            \"aColor\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\r\n        );\r\n        instanced.setAttribute(\r\n            \"aMetrics\",\r\n            new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\r\n        );\r\n        const material = new THREE.ShaderMaterial({\r\n            fragmentShader: `\r\n                varying vec3 vColor;\r\n                void main(){\r\n                    vec3 color = vec3(vColor);\r\n                    gl_FragColor = vec4(color,1.);\r\n                }\r\n                `,\r\n            vertexShader: `\r\n                attribute float aOffset;\r\n                attribute vec3 aColor;\r\n\r\n                attribute vec2 aMetrics;\r\n\r\n                uniform float uTravelLength;\r\n                uniform float uTime;\r\n\r\n                varying vec3 vColor;\r\n                mat4 rotationY( in float angle ) {\r\n                    return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\r\n                                            0,\t\t1.0,\t\t\t 0,\t0,\r\n                                    -sin(angle),\t0,\t\tcos(angle),\t0,\r\n                                            0, \t\t0,\t\t\t\t0,\t1);\r\n                }\r\n\r\n                #include <getDistortion_vertex>\r\n                void main(){\r\n                    vec3 transformed = position.xyz;\r\n                    float width = aMetrics.x;\r\n                    float height = aMetrics.y;\r\n\r\n                    transformed.xy *= vec2(width,height);\r\n                    float time = mod(uTime  * 60. *2. + aOffset , uTravelLength);\r\n\r\n                    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\r\n\r\n                    transformed.z +=  - uTravelLength + time;\r\n\r\n\r\n                    float progress = abs(transformed.z / uTravelLength);\r\n                    transformed.xyz += getDistortion(progress);\r\n\r\n                    transformed.y += height /2.;\r\n                    transformed.x += -width/2.;\r\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\r\n                    gl_Position = projectionMatrix * mvPosition;\r\n                    vColor = aColor;\r\n                }\r\n                `,\r\n            // This ones actually need double side\r\n            side: THREE.DoubleSide,\r\n            uniforms: Object.assign(\r\n                {\r\n                    uTravelLength: new THREE.Uniform(options.length),\r\n                    uTime: new THREE.Uniform(0)\r\n                },\r\n                options.distortion.uniforms\r\n            )\r\n        });\r\n\r\n        material.onBeforeCompile = shader => {\r\n            shader.vertexShader = shader.vertexShader.replace(\r\n                \"#include <getDistortion_vertex>\",\r\n                options.distortion.getDistortion\r\n            );\r\n        };\r\n\r\n        const mesh = new THREE.Mesh(instanced, material);\r\n        // The object is behind the camera before the vertex shader\r\n        mesh.frustumCulled = false;\r\n        // mesh.position.y = options.lightStickHeight / 2;\r\n        this.scene.add(mesh);\r\n        this.mesh = mesh;\r\n    }\r\n    update(time) {\r\n        this.mesh.material.uniforms.uTime.value = time;\r\n    }\r\n\r\n}\r\nfunction random(base) {\r\n    if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];\r\n    return Math.random() * base;\r\n}\r\nfunction pickRandom(arr) {\r\n    if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];\r\n    return arr;\r\n}\r\nfunction lerp(current, target, speed = 0.1, limit = 0.001) {\r\n    let change = (target - current) * speed;\r\n    if (Math.abs(change) < limit) {\r\n        change = target - current;\r\n    }\r\n    return change;\r\n}\r\nexport default {\r\n    mounted() {\r\n        this.init()\r\n    },\r\n    methods: {\r\n        init() {\r\n            const canvas = document.querySelector('#c')\r\n            const options = {\r\n                length: 400,\r\n                width: 20,\r\n                roadWidth: 9,\r\n                islandWidth: 2,\r\n                nPairs: 50,\r\n                roadSections: 3,\r\n                distortion: mountainDistortion,\r\n\r\n                totalSideLightSticks: 50,\r\n                lightStickWidth: [0.12, 0.5],\r\n                lightStickHeight: [1.3, 1.7],\r\n\r\n                color: {\r\n                    /***  Only these colors can be an array ***/\r\n                    leftCars: [0xff102a, 0xEB383E, 0xff102a],\r\n                    rightCars: [0xdadafa, 0xBEBAE3, 0x8F97E4],\r\n                    sticks: 0xdadafa,\r\n                }\r\n            };\r\n            const app = new App(canvas, options)\r\n            app.render()\r\n        },\r\n    },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.container {\r\n    position: absolute;\r\n    height: 100%;\r\n    width: 100%;\r\n}\r\n\r\n#c {\r\n    position: absolute;\r\n    height: 100%;\r\n    width: 100%;\r\n    margin: 0%;\r\n}\r\n</style>\r\n","import { render } from \"./high_speed_light_trails.vue?vue&type=template&id=39c6d57a&scoped=true\"\nimport script from \"./high_speed_light_trails.vue?vue&type=script&lang=js\"\nexport * from \"./high_speed_light_trails.vue?vue&type=script&lang=js\"\n\nimport \"./high_speed_light_trails.vue?vue&type=style&index=0&id=39c6d57a&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-39c6d57a\"]])\n\nexport default __exports__"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","mountainUniforms","uFreq","THREE","uAmp","nsin","val","Math","sin","mountainDistortion","uniforms","getDistortion","getJS","progress","time","movementProgressFix","value","distortion","cos","PI","x","y","z","lookAtAmp","lookAtOffset","multiply","add","App","constructor","canvas","options","this","clock","renderer","antialias","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","scene","camera","clientWidth","clientHeight","position","onMouseDown","bind","onMouseUp","addEventListener","init","speedUpTarget","speedUp","timeOffset","fovTarget","road","Road","leftLights","CarLights","color","leftCars","mesh","setX","roadWidth","islandWidth","rightLights","rightCars","leftSticks","LightsSticks","update","delta","coefficient","log2","lerpT","exp","lerp","elapsedTime","fovChange","fov","updateProjectionMatrix","lookAt","ev","resizeRendererToDisplaySize","domElement","width","height","needResize","render","aspect","getDelta","requestAnimationFrame","geometry","length","material","Object","assign","uColor","uTime","uTravelLength","vertexShader","fragmentShader","side","onBeforeCompile","shader","replace","rotation","colors","speed","curve","baseGeometry","instanced","copy","instanceCount","nPairs","aOffset","aMetrics","aColor","Array","isArray","map","c","sectionWidth","roadSections","i","radius","random","section","sectionX","carWidth","offsetX","offsetY","offsetZ","push","pickRandom","r","g","b","setAttribute","Float32Array","uSpeed","frustumCulled","totalSticks","totalSideLightSticks","stickoffset","sticks","lightStickWidth","lightStickHeight","base","arr","floor","current","target","limit","change","abs","mounted","methods","document","querySelector","app","__exports__"],"sourceRoot":""}