{"version":3,"file":"js/4664.f4e8a63c.js","mappings":"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","sources":["webpack://webgis/./node_modules/lerc/LercDecode.js","webpack://webgis/./node_modules/topojson-client/src/reverse.js","webpack://webgis/./node_modules/topojson-client/src/identity.js","webpack://webgis/./node_modules/topojson-client/src/transform.js","webpack://webgis/./node_modules/topojson-client/src/feature.js","webpack://webgis/./src/components/public/i3s_object.vue","webpack://webgis/./node_modules/@cesium/engine/Source/Core/ArcGISTiledElevationTerrainProvider.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SDecoder.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SFeature.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SField.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SGeometry.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SNode.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SLayer.js","webpack://webgis/./node_modules/@cesium/engine/Source/Scene/I3SDataProvider.js","webpack://webgis/./src/components/public/i3s_object.vue?8979"],"sourcesContent":["/* jshint forin: false, bitwise: false */\n/*\nCopyright 2015-2018 Esri\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2018 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function() {\n  //the original LercDecode for Version 1\n  var LercDecode = (function() {\n\n    // WARNING: This decoder version can only read old version 1 Lerc blobs. Use with caution.\n\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n\n    var CntZImage = {};\n\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image's width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n    CntZImage.decode = function(input, options) {\n      options = options || {};\n\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\n\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\n        options.encodedMaskData, noDataValue, options.returnMask);\n\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE, currentValue;\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\n\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n\n      var xx, yy;\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n\n          var block = data.pixels.blocks[blockIdx];\n\n          var blockData, blockPtr, constValue;\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n            blockPtr = 0;\n          }\n          else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          }\n          else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n                  resultPixels[outPtr++] = noDataValue;\n                }\n                maskByte <<= 1;\n              }\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n                outPtr += outStride;\n              }\n            }\n            else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n                outPtr += outStride;\n              }\n            }\n          }\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\n            throw \"Block and Mask do not match\";\n          }\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function(data) {\n      return {\n        \"fileIdentifierString\": data.fileIdentifierString,\n        \"fileVersion\": data.fileVersion,\n        \"imageType\": data.imageType,\n        \"height\": data.height,\n        \"width\": data.width,\n        \"maxZError\": data.maxZError,\n        \"eofOffset\": data.eofOffset,\n        \"mask\": data.mask ? {\n          \"numBlocksX\": data.mask.numBlocksX,\n          \"numBlocksY\": data.mask.numBlocksY,\n          \"numBytes\": data.mask.numBytes,\n          \"maxValue\": data.mask.maxValue\n        } : null,\n        \"pixels\": {\n          \"numBlocksX\": data.pixels.numBlocksX,\n          \"numBlocksY\": data.pixels.numBlocksY,\n          \"numBytes\": data.pixels.numBytes,\n          \"maxValue\": data.pixels.maxValue,\n          \"noDataValue\": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function(data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function(input, fp, skipMask) {\n      var data = {};\n\n      // File header\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\n      }\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24;\n\n      // Mask Header\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16;\n\n        // Mask Data\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        }\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      }\n\n      // Pixel Header\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY;\n      // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0); size++;\n          block.encoding = headerByte & 63;\n          if (block.encoding > 3) {\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\n          }\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n          if ((headerByte !== 0) && (headerByte !== 2)) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1); size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true); size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true); size += 4;\n            } else {\n              throw \"Invalid block offset type\";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size); size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size); size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true); size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true); size += 4;\n              } else {\n                throw \"Invalid valid pixel count type\";\n              }\n            }\n          }\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n            if (numPixels !== Math.floor(numPixels)) {\n              throw \"uncompressed block has invalid length\";\n            }\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0, o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale);\n      // get rid of trailing bytes that are already part of next block\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n        if (bitsLeft >= bitsPerPixel) {\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = (bitsPerPixel - bitsLeft);\n          n = ((buffer & bitMask) << missingBits) & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += (buffer >>> bitsLeft);\n        }\n        //pixel values may exceed max due to quantization\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n      return dest;\n    };\n\n    return CntZImage;\n  })();\n\n  //version 2. Supports 2.1, 2.2, 2.3\n  var Lerc2Decode = (function() {\n    \"use strict\";\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\n          }\n        }\n        else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\n        var buffer;\n        var dest = [];\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);//1st one\n        return dest;\n      },\n\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            dest[o] = lutArr[n];\n          }\n        }\n        else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n        return dest;\n      },\n\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);\n        return dest;\n      },\n\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          }\n          else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          dest[o] = n;\n        }\n        return dest;\n      },\n\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        //micro-optimizations\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          dest[o] = n;\n        }\n        return dest;\n      }\n    };\n\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function(input) {\n\n        var sum1 = 0xffff, sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n        while (words) {\n          var tlen = (words >= 359) ? 359 : words;\n          words -= tlen;\n          do {\n            sum1 += (input[i++] << 8);\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        }\n\n        // add the straggler byte if it exists\n        if (len & 1) {\n          sum2 += sum1 += (input[i] << 8);\n        }\n        // second reduction step to reduce sums to 16 bits\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n\n      readHeaderInfo: function(input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\n        }\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n          ptr += 4;\n        }\n\n        //keys start from here\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n        headerInfo.width = view.getUint32(4, true); //ncols\n        ptr += 8;\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        }\n        else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n\n        var checksum, keyLength;\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n          if (checksum !== headerInfo.checksum) {\n            throw \"Checksum failed.\";\n          }\n        }\n        return true;\n      },\n\n      checkMinMaxRanges: function(input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += (2 * rangeBytes);\n        var i, equal = true;\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        return rawData;\n      },\n\n      readMask: function(input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4;\n\n        // Mask Data\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw (\"invalid mask\");\n        }\n        var bitset, resultMask;\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0, val = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0, k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            }\n            else {\n              mb = bitset[k >> 3];\n            }\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n          data.pixels.resultMask = resultMask;\n\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n\n      readDataOneSweep: function(input, data, OutPixelTypeArray) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\n        //data.pixels.numBytes = numBytes;\n        var rawData;\n        var mask = data.pixels.resultMask;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        if (rawData.length === numPixels * numDims) {\n          data.pixels.resultPixels = rawData;\n        }\n        else  //mask\n        {\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n          var z = 0, k = 0, i = 0, nStart = 0;\n          if (numDims > 1) {\n            for (i=0; i < numDims; i++) {\n              nStart = i * numPixels;\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  data.pixels.resultPixels[nStart + k] = rawData[z++];\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = rawData[z++];\n              }\n            }\n          }\n        }\n        ptr += numBytes;\n        data.ptr = ptr;       //return data;\n        return true;\n      },\n\n      readHuffmanTree: function(input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n         * reading code table\n         *************************/\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n        if (version < 2) {\n          throw \"unsupported Huffman version\";\n        }\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n        if (i0 >= i1) {\n          return false;\n        }\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n        var bitPos = 0, word, srcPtr = 0;\n        word = stuffedData[0];\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            }\n            else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> (32 - bitPos);\n            }\n          }\n        }\n\n        //finished reading code table\n\n        /* ************************\n         * building lut\n         *************************/\n        var numBitsLUT = 0, numBitsLUTQick = 0;\n        var tree = new TreeNode();\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        }\n        else {\n          numBitsLUTQick = numBitsLUT;\n        }\n        if (numBitsLUT >= 30) {\n          console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\n        }\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            entry = [len, j];\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << (numBitsLUTQick - len);\n              numEntries = 1 << (numBitsLUTQick - len);\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            }\n            else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n                  node = node.right;\n                }\n                else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n                  node = node.left;\n                }\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n\n      readHuffman: function(input, data, OutPixelTypeArray) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height;\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n         * reading huffman structure info\n         *************************/\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree;\n        //stuffedData includes huffman headers\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim;\n        for (iDim = 0; iDim < headerInfo.numDims; iDim++) {\n          if (numDims > 1) {\n            //get the mem block of current dimension\n            resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n            prevVal = 0;\n          }\n          if (data.headerInfo.numValidPixel === width * height) { //all valid\n            for (k = 0, i = 0; i < height; i++) {\n              for (j = 0; j < width; j++, k++) {\n                val = 0;\n                valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                valTmpQuick = valTmp;// >>> deltaBits;\n                if (32 - bitPos < numBitsLUTQick) {\n                  valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                }\n                if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                {\n                  val = decodeLut[valTmpQuick][1];\n                  bitPos += decodeLut[valTmpQuick][0];\n                }\n                else {\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUT) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  node = tree;\n                  for (ii = 0; ii < numBitsLUT; ii++) {\n                    currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                    node = currentBit ? node.right : node.left;\n                    if (!(node.left || node.right)) {\n                      val = node.val;\n                      bitPos = bitPos + ii + 1;\n                      break;\n                    }\n                  }\n                }\n\n                if (bitPos >= 32) {\n                  bitPos -= 32;\n                  srcPtr++;\n                  word = stuffedData[srcPtr];\n                }\n\n                delta = val - offset;\n                if (deltaEncode) {\n                  if (j > 0) {\n                    delta += prevVal;    // use overflow\n                  }\n                  else if (i > 0) {\n                    delta += resultPixels[k - width];\n                  }\n                  else {\n                    delta += prevVal;\n                  }\n                  delta &= 0xFF; //overflow\n                  resultPixels[k] = delta;//overflow\n                  prevVal = delta;\n                }\n                else {\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n          else { //not all valid, use mask\n            for (k = 0, i = 0; i < height; i++) {\n              for (j = 0; j < width; j++, k++) {\n                if (mask[k]) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  if (deltaEncode) {\n                    if (j > 0 && mask[k - 1]) {\n                      delta += prevVal;    // use overflow\n                    }\n                    else if (i > 0 && mask[k - width]) {\n                      delta += resultPixels[k - width];\n                    }\n                    else {\n                      delta += prevVal;\n                    }\n\n                    delta &= 0xFF; //overflow\n                    resultPixels[k] = delta;//overflow\n                    prevVal = delta;\n                  }\n                  else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            }\n          }\n          data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        }\n        data.pixels.resultPixels = resultPixelsAllDim;\n      },\n\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion;\n          //var block = {};\n          var blockPtr = 0;\n          var view = new DataView(input, data.ptr, 5);//to do\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\n          var numBits = headerByte & 31;\n          var numElements = 0;\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr); blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\n          } else {\n            throw \"Invalid valid pixel count type\";\n          }\n          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\n          //offset = offset || 0;\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            lutBitsPerElement = numBits;\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            bitsPerPixel = 0;\n            while ((lutBytes - 1) >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            //lutArr.unshift(0);\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n            else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          }\n          else {\n            //console.debug(\"bitstuffer\");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n              else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n\n      },\n\n      readTiles: function(input, data, OutPixelTypeArray) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims, iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\n\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, width * height * iDim * dataTypeSize, width * height);\n              }\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              bits67 = (headerByte >> 6) & 0xFF;\n              testCode = (headerByte >> 2) & 15;    // use bits 2345 for integrity check\n              if (testCode !== (((blockX * microBlockSize) >> 3) & 15)) {\n                throw \"integrity issue\";\n                //return false;\n              }\n\n              blockEncoding = headerByte & 3;\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\n              }\n              else if (blockEncoding === 2) { //constant 0\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              }\n              else if (blockEncoding === 0) {  //uncompressed\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\n                //bit alignment\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n                      outPtr++;\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                else {//all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                data.ptr += z * dataTypeSize;\n              }\n              else { //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed(imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n                if (blockEncoding === 3) //constant offset value\n                {\n                  data.ptr += blockPtr;\n                  data.counter.constantoffset++;\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = offset;\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = offset;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n                else { //bitstuff encoding is 3\n                  data.ptr += blockPtr;\n                  //heavy lifting\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0;\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n\n      formatFileInfo: function(data) {\n        return {\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\n          \"fileVersion\": data.headerInfo.fileVersion,\n          \"imageType\": data.headerInfo.imageType,\n          \"height\": data.headerInfo.height,\n          \"width\": data.headerInfo.width,\n          \"numValidPixel\": data.headerInfo.numValidPixel,\n          \"microBlockSize\": data.headerInfo.microBlockSize,\n          \"blobSize\": data.headerInfo.blobSize,\n          \"maxZError\": data.headerInfo.maxZError,\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          \"eofOffset\": data.eofOffset,\n          \"mask\": data.mask ? {\n            \"numBytes\": data.mask.numBytes\n          } : null,\n          \"pixels\": {\n            \"numBlocksX\": data.pixels.numBlocksX,\n            \"numBlocksY\": data.pixels.numBlocksY,\n            //\"numBytes\": data.pixels.numBytes,\n            \"maxValue\": data.headerInfo.zMax,\n            \"minValue\": data.headerInfo.zMin,\n            \"noDataValue\": data.noDataValue\n          }\n        };\n      },\n\n      constructConstantSurface: function(data) {\n        var val = data.headerInfo.zMax;\n        var numDims =  data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var numPixelAllDims = numPixels * numDims;\n        var i=0, k = 0, nStart=0;\n        var mask = data.pixels.resultMask;\n        if (mask) {\n          if (numDims > 1) {\n            for (i=0; i < numDims; i++) {\n              nStart = i * numPixels;\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  data.pixels.resultPixels[nStart + k] = val;\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = val;\n              }\n            }\n          }\n        }\n        else {\n          if (data.pixels.resultPixels.fill) {\n            data.pixels.resultPixels.fill(val);\n          }\n          else {\n            for (k = 0; k < numPixelAllDims; k++) {\n              data.pixels.resultPixels[k] = val;\n            }\n          }\n        }\n        return;\n      },\n\n      getDataTypeArray: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = Int8Array;\n            break;\n          case 1: //byte\n            tp = Uint8Array;\n            break;\n          case 2: //short\n            tp = Int16Array;\n            break;\n          case 3: //ushort\n            tp = Uint16Array;\n            break;\n          case 4:\n            tp = Int32Array;\n            break;\n          case 5:\n            tp = Uint32Array;\n            break;\n          case 6:\n            tp = Float32Array;\n            break;\n          case 7:\n            tp = Float64Array;\n            break;\n          default:\n            tp = Float32Array;\n        }\n        return tp;\n      },\n\n      getPixelType: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = \"S8\";\n            break;\n          case 1: //byte\n            tp = \"U8\";\n            break;\n          case 2: //short\n            tp = \"S16\";\n            break;\n          case 3: //ushort\n            tp = \"U16\";\n            break;\n          case 4:\n            tp = \"S32\";\n            break;\n          case 5:\n            tp = \"U32\";\n            break;\n          case 6:\n            tp = \"F32\";\n            break;\n          case 7:\n            tp = \"F64\"; //not supported\n            break;\n          default:\n            tp = \"F32\";\n        }\n        return tp;\n      },\n\n      isValidPixelValue: function(t, val) {\n        if (val == null) {\n          return false;\n        }\n        var isValid;\n        switch (t) {\n          case 0: //char\n            isValid = val >= -128 && val <= 127;\n            break;\n          case 1: //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n          case 2: //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n          case 3: //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n          case 4: //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n          case 5: //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n          case 7:\n            isValid = val >= 5e-324 && val <= 1.7976931348623157e+308;\n            break;\n          default:\n            isValid = false;\n        }\n        return isValid;\n      },\n\n      getDataTypeSize: function(t) {\n        var s = 0;\n        switch (t) {\n          case 0: //ubyte\n          case 1: //byte\n            s = 1;\n            break;\n          case 2: //short\n          case 3: //ushort\n            s = 2;\n            break;\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n          case 7:\n            s = 8;\n            break;\n          default:\n            s = t;\n        }\n        return s;\n      },\n\n      getDataTypeUsed: function(dt, tc) {\n        var t = dt;\n        switch (dt) {\n          case 2: //short\n          case 4: //long\n            t = dt - tc;\n            break;\n          case 3: //ushort\n          case 5: //ulong\n            t = dt - 2 * tc;\n            break;\n          case 6: //float\n            if (0 === tc) {\n              t = dt;\n            }\n            else if (1 === tc) {\n              t = 2;\n            }\n            else {\n              t = 1;//byte\n            }\n            break;\n          case 7: //double\n            if (0 === tc) {\n              t = dt;\n            }\n            else {\n              t = dt - 2 * tc + 1;\n            }\n            break;\n          default:\n            t = dt;\n            break;\n        }\n        return t;\n      },\n\n      getOnePixel: function(block, blockPtr, offsetType, view) {\n        var temp = 0;\n        switch (offsetType) {\n          case 0: //char\n            temp = view.getInt8(blockPtr);\n            break;\n          case 1: //byte\n            temp = view.getUint8(blockPtr);\n            break;\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n          case 7:\n            //temp = view.getFloat64(blockPtr, true);\n            //blockPtr += 8;\n            //lerc2 encoding doesnt handle float 64, force to float32???\n            temp = view.getFloat64(blockPtr, true);\n            break;\n          default:\n            throw (\"the decoder does not understand this pixel type\");\n        }\n        return temp;\n      }\n    };\n\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n    var TreeNode = function(val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their's a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       */\n      decode: function(/*byte array*/ input, /*object*/ options) {\n        //currently there's a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue;\n\n        //initialize\n        var i = 0, data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {};\n\n        // File header\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\n          return;\n        }\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\n\n        // Mask Header\n        Lerc2Helpers.readMask(input, data);\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n          {\n            Lerc2Helpers.constructConstantSurface(data);\n          }\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data);\n          }\n          else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n            if (bReadDataOneSweep) {\n              //console.debug(\"OneSweep\");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray);\n            }\n            else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\n                  throw \"Invalid Huffman flag \" + flagHuffman;\n                }\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\n                  //console.log(\"Huffman\");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray);\n                }\n                else {\n                  //console.log(\"Tiles\");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray);\n                }\n              }\n              else { //lerc2.x non-8 bit data\n                //console.log(\"Tiles\");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        }\n        else {\n          diff = data.headerInfo.blobSize - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask\n          //noDataValue: noDataValue\n        };\n\n        //we should remove this if there's no existing client\n        //optional noDataValue processing, it's user's responsiblity\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n          result.noDataValue = noDataValue;\n        }\n        data.noDataValue = noDataValue;\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n        return result;\n      },\n\n      getBandCount: function(/*byte array*/ input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n        return count;\n      }\n    };\n\n    return Lerc2Decode;\n  })();\n\n  var isPlatformLittleEndian = (function() {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  })();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, …] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, …] Each element is a statistics object representing min and max values\n    **/\n    decode: function(encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw \"Big endian system is not supported.\";\n      }\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n      if (fileIdentifierString.trim() === \"CntZImage\") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      }\n      else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      }\n      else {\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\n      }\n\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,//for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,//lerc1 only\n          maskData: maskData,//lerc2 only\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\n          returnFileInfo: true,//for both lerc1 and lerc2\n          pixelType: options.pixelType || null,//lerc1 only\n          noDataValue: options.noDataValue || null//lerc1 only\n        });\n\n        inputOffset = result.fileInfo.eofOffset;\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData;//lerc1\n          maskData = result.maskData;//lerc2\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1;\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = result.maskData;\n        }\n        if (majorVersion >1 && result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n          bandMasks.push(result.maskData);\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n      var i, j, numPixels;\n      if (majorVersion > 1 && bandMasks.length > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (typeof define === \"function\" && define.amd) {/* jshint ignore:line */\n    //amd loaders such as dojo and requireJS\n    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\n    define([], function() { return Lerc; });/* jshint ignore:line */\n  }\n  else if (typeof module !== \"undefined\" && module.exports) {/* jshint ignore:line */\n    //commonJS module 1.0/1.1/1.1.1 systems, such as nodeJS\n    //http://wiki.commonjs.org/wiki/Modules\n    module.exports = Lerc;/* jshint ignore:line */\n  }\n  else {\n    //assign to this, most likely window\n    this.Lerc = Lerc;\n  }\n\n})();\n","export default function(array, n) {\n  var t, j = array.length, i = j - n;\n  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;\n}\n","export default function(x) {\n  return x;\n}\n","import identity from \"./identity.js\";\n\nexport default function(transform) {\n  if (transform == null) return identity;\n  var x0,\n      y0,\n      kx = transform.scale[0],\n      ky = transform.scale[1],\n      dx = transform.translate[0],\n      dy = transform.translate[1];\n  return function(input, i) {\n    if (!i) x0 = y0 = 0;\n    var j = 2, n = input.length, output = new Array(n);\n    output[0] = (x0 += input[0]) * kx + dx;\n    output[1] = (y0 += input[1]) * ky + dy;\n    while (j < n) output[j] = input[j], ++j;\n    return output;\n  };\n}\n","import reverse from \"./reverse.js\";\nimport transform from \"./transform.js\";\n\nexport default function(topology, o) {\n  if (typeof o === \"string\") o = topology.objects[o];\n  return o.type === \"GeometryCollection\"\n      ? {type: \"FeatureCollection\", features: o.geometries.map(function(o) { return feature(topology, o); })}\n      : feature(topology, o);\n}\n\nfunction feature(topology, o) {\n  var id = o.id,\n      bbox = o.bbox,\n      properties = o.properties == null ? {} : o.properties,\n      geometry = object(topology, o);\n  return id == null && bbox == null ? {type: \"Feature\", properties: properties, geometry: geometry}\n      : bbox == null ? {type: \"Feature\", id: id, properties: properties, geometry: geometry}\n      : {type: \"Feature\", id: id, bbox: bbox, properties: properties, geometry: geometry};\n}\n\nexport function object(topology, o) {\n  var transformPoint = transform(topology.transform),\n      arcs = topology.arcs;\n\n  function arc(i, points) {\n    if (points.length) points.pop();\n    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {\n      points.push(transformPoint(a[k], k));\n    }\n    if (i < 0) reverse(points, n);\n  }\n\n  function point(p) {\n    return transformPoint(p);\n  }\n\n  function line(arcs) {\n    var points = [];\n    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);\n    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.\n    return points;\n  }\n\n  function ring(arcs) {\n    var points = line(arcs);\n    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.\n    return points;\n  }\n\n  function polygon(arcs) {\n    return arcs.map(ring);\n  }\n\n  function geometry(o) {\n    var type = o.type, coordinates;\n    switch (type) {\n      case \"GeometryCollection\": return {type: type, geometries: o.geometries.map(geometry)};\n      case \"Point\": coordinates = point(o.coordinates); break;\n      case \"MultiPoint\": coordinates = o.coordinates.map(point); break;\n      case \"LineString\": coordinates = line(o.arcs); break;\n      case \"MultiLineString\": coordinates = o.arcs.map(line); break;\n      case \"Polygon\": coordinates = polygon(o.arcs); break;\n      case \"MultiPolygon\": coordinates = o.arcs.map(polygon); break;\n      default: return null;\n    }\n    return {type: type, coordinates: coordinates};\n  }\n\n  return geometry(o);\n}\n","<template>\n  <div id=\"cesiumContainer\"></div>\n</template>\n\n<script>\nimport 'cesium/Build/Cesium/Widgets/widgets.css'\nimport * as Cesium from 'cesium'\nimport { randomPoint } from '@turf/turf'\nexport default {\n  mounted() {\n    this.init()\n  },\n  methods: {\n    async init() {\n      const viewer = new Cesium.Viewer('cesiumContainer', {\n        terrainProvider: await Cesium.createWorldTerrainAsync(),\n        animation: false,\n        timeline: false,\n      })\n      if (Cesium.FeatureDetection.supportsImageRenderingPixelated()) {\n        //判断是否支持图像渲染像素化处理\n        viewer.resolutionScale = window.devicePixelRatio\n      }\n      viewer.scene.postProcessStages.fxaa.enabled = true\n      viewer.scene.debugShowFramesPerSecond = true // 显示帧率\n\n      const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\");\n      const i3sOptions = {\n        traceFetches: false, // for tracing I3S fetches\n        geoidTiledTerrainProvider: geoidService, // pass the geoid service\n      };\n      const i3sProvider = await Cesium.I3SDataProvider.fromUrl(\"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/SanFrancisco_3DObjects_1_7/SceneServer/layers/0\", i3sOptions)\n      viewer.scene.primitives.add(i3sProvider);\n\n      const center = Cesium.Rectangle.center(i3sProvider.extent);\n      center.height = 10000.0;\n      viewer.camera.setView({\n        destination: Cesium.Ellipsoid.WGS84.cartographicToCartesian(center),\n      });\n    },\n  },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n#cesiumContainer {\n  position: absolute;\n  height: 100%;\n  width: 100%;\n}\n</style>\n","import Cartesian2 from \"./Cartesian2.js\";\nimport Check from \"./Check.js\";\nimport Credit from \"./Credit.js\";\nimport defaultValue from \"./defaultValue.js\";\nimport defined from \"./defined.js\";\nimport Ellipsoid from \"./Ellipsoid.js\";\nimport Event from \"./Event.js\";\nimport GeographicTilingScheme from \"./GeographicTilingScheme.js\";\nimport HeightmapEncoding from \"./HeightmapEncoding.js\";\nimport HeightmapTerrainData from \"./HeightmapTerrainData.js\";\nimport Rectangle from \"./Rectangle.js\";\nimport Request from \"./Request.js\";\nimport RequestState from \"./RequestState.js\";\nimport RequestType from \"./RequestType.js\";\nimport Resource from \"./Resource.js\";\nimport RuntimeError from \"./RuntimeError.js\";\nimport TerrainProvider from \"./TerrainProvider.js\";\nimport TileAvailability from \"./TileAvailability.js\";\nimport TileProviderError from \"./TileProviderError.js\";\nimport WebMercatorTilingScheme from \"./WebMercatorTilingScheme.js\";\n\nconst ALL_CHILDREN = 15;\n\n/**\n * @typedef {Object} ArcGISTiledElevationTerrainProvider.ConstructorOptions\n *\n * Initialization options for the ArcGISTiledElevationTerrainProvider constructor\n *\n * @property {string} [token] The authorization token to use to connect to the service.\n * @property {Ellipsoid} [ellipsoid] The ellipsoid.  If the tilingScheme is specified,\n *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.\n *                    If neither parameter is specified, the WGS84 ellipsoid is used.\n */\n\n/**\n * Used to track creation details while fetching initial metadata\n *\n * @constructor\n * @private\n *\n * @param {ArcGISTiledElevationTerrainProvider.ConstructorOptions} [options] An object describing initialization options.\n */\nfunction TerrainProviderBuilder(options) {\n  this.ellipsoid = defaultValue(options.ellipsoid, Ellipsoid.WGS84);\n\n  this.credit = undefined;\n  this.tilingScheme = undefined;\n  this.height = undefined;\n  this.width = undefined;\n  this.encoding = undefined;\n  this.lodCount = undefined;\n  this.hasAvailability = false;\n  this.tilesAvailable = undefined;\n  this.tilesAvailabilityLoaded = undefined;\n  this.levelZeroMaximumGeometricError = undefined;\n  this.terrainDataStructure = undefined;\n}\n\n/**\n * Complete ArcGISTiledElevationTerrainProvider creation based on builder values.\n *\n * @private\n *\n * @param {ArcGISTiledElevationTerrainProvider} provider\n */\nTerrainProviderBuilder.prototype.build = function (provider) {\n  provider._credit = this.credit;\n  provider._tilingScheme = this.tilingScheme;\n  provider._height = this.height;\n  provider._width = this.width;\n  provider._encoding = this.encoding;\n  provider._lodCount = this.lodCount;\n  provider._hasAvailability = this.hasAvailability;\n  provider._tilesAvailable = this.tilesAvailable;\n  provider._tilesAvailabilityLoaded = this.tilesAvailabilityLoaded;\n  provider._levelZeroMaximumGeometricError = this.levelZeroMaximumGeometricError;\n  provider._terrainDataStructure = this.terrainDataStructure;\n};\n\nfunction parseMetadataSuccess(terrainProviderBuilder, metadata) {\n  const copyrightText = metadata.copyrightText;\n  if (defined(copyrightText)) {\n    terrainProviderBuilder.credit = new Credit(copyrightText);\n  }\n\n  const spatialReference = metadata.spatialReference;\n  const wkid = defaultValue(spatialReference.latestWkid, spatialReference.wkid);\n  const extent = metadata.extent;\n  const tilingSchemeOptions = {\n    ellipsoid: terrainProviderBuilder.ellipsoid,\n  };\n  if (wkid === 4326) {\n    tilingSchemeOptions.rectangle = Rectangle.fromDegrees(\n      extent.xmin,\n      extent.ymin,\n      extent.xmax,\n      extent.ymax\n    );\n    terrainProviderBuilder.tilingScheme = new GeographicTilingScheme(\n      tilingSchemeOptions\n    );\n  } else if (wkid === 3857) {\n    // Clamp extent to EPSG 3857 bounds\n    const epsg3857Bounds =\n      Math.PI * terrainProviderBuilder.ellipsoid.maximumRadius;\n    if (metadata.extent.xmax > epsg3857Bounds) {\n      metadata.extent.xmax = epsg3857Bounds;\n    }\n    if (metadata.extent.ymax > epsg3857Bounds) {\n      metadata.extent.ymax = epsg3857Bounds;\n    }\n    if (metadata.extent.xmin < -epsg3857Bounds) {\n      metadata.extent.xmin = -epsg3857Bounds;\n    }\n    if (metadata.extent.ymin < -epsg3857Bounds) {\n      metadata.extent.ymin = -epsg3857Bounds;\n    }\n\n    tilingSchemeOptions.rectangleSouthwestInMeters = new Cartesian2(\n      extent.xmin,\n      extent.ymin\n    );\n    tilingSchemeOptions.rectangleNortheastInMeters = new Cartesian2(\n      extent.xmax,\n      extent.ymax\n    );\n    terrainProviderBuilder.tilingScheme = new WebMercatorTilingScheme(\n      tilingSchemeOptions\n    );\n  } else {\n    throw new RuntimeError(\"Invalid spatial reference\");\n  }\n\n  const tileInfo = metadata.tileInfo;\n  if (!defined(tileInfo)) {\n    throw new RuntimeError(\"tileInfo is required\");\n  }\n\n  terrainProviderBuilder.width = tileInfo.rows + 1;\n  terrainProviderBuilder.height = tileInfo.cols + 1;\n  terrainProviderBuilder.encoding =\n    tileInfo.format === \"LERC\"\n      ? HeightmapEncoding.LERC\n      : HeightmapEncoding.NONE;\n  terrainProviderBuilder.lodCount = tileInfo.lods.length - 1;\n\n  const hasAvailability = (terrainProviderBuilder.hasAvailability =\n    metadata.capabilities.indexOf(\"Tilemap\") !== -1);\n  if (hasAvailability) {\n    terrainProviderBuilder.tilesAvailable = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      terrainProviderBuilder.lodCount\n    );\n    terrainProviderBuilder.tilesAvailable.addAvailableTileRange(\n      0,\n      0,\n      0,\n      terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0),\n      terrainProviderBuilder.tilingScheme.getNumberOfYTilesAtLevel(0)\n    );\n    terrainProviderBuilder.tilesAvailabilityLoaded = new TileAvailability(\n      terrainProviderBuilder.tilingScheme,\n      terrainProviderBuilder.lodCount\n    );\n  }\n\n  terrainProviderBuilder.levelZeroMaximumGeometricError = TerrainProvider.getEstimatedLevelZeroGeometricErrorForAHeightmap(\n    terrainProviderBuilder.tilingScheme.ellipsoid,\n    terrainProviderBuilder.width,\n    terrainProviderBuilder.tilingScheme.getNumberOfXTilesAtLevel(0)\n  );\n\n  if (metadata.bandCount > 1) {\n    console.log(\n      \"ArcGISTiledElevationTerrainProvider: Terrain data has more than 1 band. Using the first one.\"\n    );\n  }\n\n  if (defined(metadata.minValues) && defined(metadata.maxValues)) {\n    terrainProviderBuilder.terrainDataStructure = {\n      elementMultiplier: 1.0,\n      lowestEncodedHeight: metadata.minValues[0],\n      highestEncodedHeight: metadata.maxValues[0],\n    };\n  } else {\n    terrainProviderBuilder.terrainDataStructure = {\n      elementMultiplier: 1.0,\n    };\n  }\n}\n\nasync function requestMetadata(\n  terrainProviderBuilder,\n  metadataResource,\n  provider\n) {\n  try {\n    const metadata = await metadataResource.fetchJson();\n    parseMetadataSuccess(terrainProviderBuilder, metadata);\n  } catch (error) {\n    const message = `An error occurred while accessing ${metadataResource}.`;\n    TileProviderError.reportError(\n      undefined,\n      provider,\n      defined(provider) ? provider._errorEvent : undefined,\n      message\n    );\n\n    throw error;\n  }\n}\n\n/**\n * <div class=\"notice\">\n * To construct a CesiumTerrainProvider, call {@link ArcGISTiledElevationTerrainProvider.fromUrl}. Do not call the constructor directly.\n * </div>\n *\n * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @alias ArcGISTiledElevationTerrainProvider\n * @constructor\n *\n * @param {CesiumTerrainProvider.ConstructorOptions} [options] A url or an object describing initialization options\n *\n * @example\n * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @see TerrainProvider\n */\nfunction ArcGISTiledElevationTerrainProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  this._resource = undefined;\n  this._credit = undefined;\n  this._tilingScheme = undefined;\n  this._levelZeroMaximumGeometricError = undefined;\n  this._maxLevel = undefined;\n  this._terrainDataStructure = undefined;\n  this._width = undefined;\n  this._height = undefined;\n  this._encoding = undefined;\n  this._lodCount = undefined;\n\n  this._hasAvailability = false;\n  this._tilesAvailable = undefined;\n  this._tilesAvailabilityLoaded = undefined;\n  this._availableCache = {};\n\n  this._errorEvent = new Event();\n}\n\nObject.defineProperties(ArcGISTiledElevationTerrainProvider.prototype, {\n  /**\n   * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing\n   * to the event, you will be notified of the error and can potentially recover from it.  Event listeners\n   * are passed an instance of {@link TileProviderError}.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Event}\n   * @readonly\n   */\n  errorEvent: {\n    get: function () {\n      return this._errorEvent;\n    },\n  },\n\n  /**\n   * Gets the credit to display when this terrain provider is active.  Typically this is used to credit\n   * the source of the terrain.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {Credit}\n   * @readonly\n   */\n  credit: {\n    get: function () {\n      return this._credit;\n    },\n  },\n\n  /**\n   * Gets the tiling scheme used by this provider.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {GeographicTilingScheme}\n   * @readonly\n   */\n  tilingScheme: {\n    get: function () {\n      return this._tilingScheme;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the provider includes a water mask.  The water mask\n   * indicates which areas of the globe are water rather than land, so they can be rendered\n   * as a reflective surface with animated waves.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasWaterMask: {\n    get: function () {\n      return false;\n    },\n  },\n\n  /**\n   * Gets a value indicating whether or not the requested tiles include vertex normals.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  hasVertexNormals: {\n    get: function () {\n      return false;\n    },\n  },\n  /**\n   * Gets an object that can be used to determine availability of terrain from this provider, such as\n   * at points and in rectangles. This property may be undefined if availability\n   * information is not available.\n   * @memberof ArcGISTiledElevationTerrainProvider.prototype\n   * @type {TileAvailability}\n   * @readonly\n   */\n  availability: {\n    get: function () {\n      return this._tilesAvailable;\n    },\n  },\n});\n\n/**\n * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps\n * retrieved from Elevation Tiles of an an ArcGIS ImageService.\n *\n * @param {Resource|String|Promise<Resource>|Promise<String>} url The URL of the ArcGIS ImageServer service.\n * @param {ArcGISTiledElevationTerrainProvider.ConstructorOptions} [options] A url or an object describing initialization options.\n * @returns {Promise<ArcGISTiledElevationTerrainProvider>}\n *\n * @example\n * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\"https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer\", {\n *   token: \"KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg..\"\n * });\n * viewer.terrainProvider = terrainProvider;\n *\n * @exception {RuntimeError} metadata specifies invalid spatial reference\n * @exception {RuntimeError} metadata does not specify tileInfo\n */\nArcGISTiledElevationTerrainProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  url = await Promise.resolve(url);\n  let resource = Resource.createIfNeeded(url);\n  resource.appendForwardSlash();\n  if (defined(options.token)) {\n    resource = resource.getDerivedResource({\n      queryParameters: {\n        token: options.token,\n      },\n    });\n  }\n\n  const metadataResource = resource.getDerivedResource({\n    queryParameters: {\n      f: \"pjson\",\n    },\n  });\n\n  const terrainProviderBuilder = new TerrainProviderBuilder(options);\n  await requestMetadata(terrainProviderBuilder, metadataResource);\n\n  const provider = new ArcGISTiledElevationTerrainProvider(options);\n  terrainProviderBuilder.build(provider);\n  provider._resource = resource;\n\n  return provider;\n};\n\n/**\n * Requests the geometry for a given tile. The result includes terrain\n * data and indicates that all child tiles are available.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @param {Request} [request] The request object. Intended for internal use only.\n * @returns {Promise<TerrainData>|undefined} A promise for the requested geometry.  If this method\n *          returns undefined instead of a promise, it is an indication that too many requests are already\n *          pending and the request will be retried later.\n */\nArcGISTiledElevationTerrainProvider.prototype.requestTileGeometry = function (\n  x,\n  y,\n  level,\n  request\n) {\n  const tileResource = this._resource.getDerivedResource({\n    url: `tile/${level}/${y}/${x}`,\n    request: request,\n  });\n\n  const hasAvailability = this._hasAvailability;\n  let availabilityPromise = Promise.resolve(true);\n  let availabilityRequest;\n  if (\n    hasAvailability &&\n    !defined(isTileAvailable(this, level + 1, x * 2, y * 2))\n  ) {\n    // We need to load child availability\n    const availabilityResult = requestAvailability(\n      this,\n      level + 1,\n      x * 2,\n      y * 2\n    );\n\n    availabilityPromise = availabilityResult.promise;\n    availabilityRequest = availabilityResult.request;\n  }\n\n  const promise = tileResource.fetchArrayBuffer();\n  if (!defined(promise) || !defined(availabilityPromise)) {\n    return undefined;\n  }\n\n  const that = this;\n  const tilesAvailable = this._tilesAvailable;\n  return Promise.all([promise, availabilityPromise])\n    .then(function (result) {\n      return new HeightmapTerrainData({\n        buffer: result[0],\n        width: that._width,\n        height: that._height,\n        childTileMask: hasAvailability\n          ? tilesAvailable.computeChildMaskForTile(level, x, y)\n          : ALL_CHILDREN,\n        structure: that._terrainDataStructure,\n        encoding: that._encoding,\n      });\n    })\n    .catch(function (error) {\n      if (\n        defined(availabilityRequest) &&\n        availabilityRequest.state === RequestState.CANCELLED\n      ) {\n        request.cancel();\n\n        // Don't reject the promise till the request is actually cancelled\n        // Otherwise it will think the request failed, but it didn't.\n        return request.deferred.promise.finally(function () {\n          request.state = RequestState.CANCELLED;\n          return Promise.reject(error);\n        });\n      }\n      return Promise.reject(error);\n    });\n};\n\nfunction isTileAvailable(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return undefined;\n  }\n\n  const tilesAvailabilityLoaded = that._tilesAvailabilityLoaded;\n  const tilesAvailable = that._tilesAvailable;\n\n  if (level > that._lodCount) {\n    return false;\n  }\n\n  // Check if tiles are known to be available\n  if (tilesAvailable.isTileAvailable(level, x, y)) {\n    return true;\n  }\n\n  // or to not be available\n  if (tilesAvailabilityLoaded.isTileAvailable(level, x, y)) {\n    return false;\n  }\n\n  return undefined;\n}\n\n/**\n * Gets the maximum geometric error allowed in a tile at a given level.\n *\n * @param {number} level The tile level for which to get the maximum geometric error.\n * @returns {number} The maximum geometric error.\n */\nArcGISTiledElevationTerrainProvider.prototype.getLevelMaximumGeometricError = function (\n  level\n) {\n  return this._levelZeroMaximumGeometricError / (1 << level);\n};\n\n/**\n * Determines whether data for a tile is available to be loaded.\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {boolean|undefined} Undefined if not supported, otherwise true or false.\n */\nArcGISTiledElevationTerrainProvider.prototype.getTileDataAvailable = function (\n  x,\n  y,\n  level\n) {\n  if (!this._hasAvailability) {\n    return undefined;\n  }\n\n  const result = isTileAvailable(this, level, x, y);\n  if (defined(result)) {\n    return result;\n  }\n\n  requestAvailability(this, level, x, y);\n\n  return undefined;\n};\n\n/**\n * Makes sure we load availability data for a tile\n *\n * @param {number} x The X coordinate of the tile for which to request geometry.\n * @param {number} y The Y coordinate of the tile for which to request geometry.\n * @param {number} level The level of the tile for which to request geometry.\n * @returns {undefined} This provider does not support loading availability.\n */\nArcGISTiledElevationTerrainProvider.prototype.loadTileDataAvailability = function (\n  x,\n  y,\n  level\n) {\n  return undefined;\n};\n\nfunction findRange(origin, width, height, data) {\n  const endCol = width - 1;\n  const endRow = height - 1;\n\n  const value = data[origin.y * width + origin.x];\n  const endingIndices = [];\n  const range = {\n    startX: origin.x,\n    startY: origin.y,\n    endX: 0,\n    endY: 0,\n  };\n\n  const corner = new Cartesian2(origin.x + 1, origin.y + 1);\n  let doneX = false;\n  let doneY = false;\n  while (!(doneX && doneY)) {\n    // We want to use the original value when checking Y,\n    //  so get it before it possibly gets incremented\n    let endX = corner.x;\n\n    // If we no longer move in the Y direction we need to check the corner tile in X pass\n    const endY = doneY ? corner.y + 1 : corner.y;\n\n    // Check X range\n    if (!doneX) {\n      for (let y = origin.y; y < endY; ++y) {\n        if (data[y * width + corner.x] !== value) {\n          doneX = true;\n          break;\n        }\n      }\n\n      if (doneX) {\n        endingIndices.push(new Cartesian2(corner.x, origin.y));\n\n        // Use the last good column so we can continue with Y\n        --corner.x;\n        --endX;\n        range.endX = corner.x;\n      } else if (corner.x === endCol) {\n        range.endX = corner.x;\n        doneX = true;\n      } else {\n        ++corner.x;\n      }\n    }\n\n    // Check Y range - The corner tile is checked here\n    if (!doneY) {\n      const col = corner.y * width;\n      for (let x = origin.x; x <= endX; ++x) {\n        if (data[col + x] !== value) {\n          doneY = true;\n          break;\n        }\n      }\n\n      if (doneY) {\n        endingIndices.push(new Cartesian2(origin.x, corner.y));\n\n        // Use the last good row so we can continue with X\n        --corner.y;\n        range.endY = corner.y;\n      } else if (corner.y === endRow) {\n        range.endY = corner.y;\n        doneY = true;\n      } else {\n        ++corner.y;\n      }\n    }\n  }\n\n  return {\n    endingIndices: endingIndices,\n    range: range,\n    value: value,\n  };\n}\n\nfunction computeAvailability(x, y, width, height, data) {\n  const ranges = [];\n\n  const singleValue = data.every(function (val) {\n    return val === data[0];\n  });\n  if (singleValue) {\n    if (data[0] === 1) {\n      ranges.push({\n        startX: x,\n        startY: y,\n        endX: x + width - 1,\n        endY: y + height - 1,\n      });\n    }\n\n    return ranges;\n  }\n\n  let positions = [new Cartesian2(0, 0)];\n  while (positions.length > 0) {\n    const origin = positions.pop();\n    const result = findRange(origin, width, height, data);\n\n    if (result.value === 1) {\n      // Convert range into the array into global tile coordinates\n      const range = result.range;\n      range.startX += x;\n      range.endX += x;\n      range.startY += y;\n      range.endY += y;\n      ranges.push(range);\n    }\n\n    const endingIndices = result.endingIndices;\n    if (endingIndices.length > 0) {\n      positions = positions.concat(endingIndices);\n    }\n  }\n\n  return ranges;\n}\n\nfunction requestAvailability(that, level, x, y) {\n  if (!that._hasAvailability) {\n    return {};\n  }\n\n  // Fetch 128x128 availability list, so we make the minimum amount of requests\n  const xOffset = Math.floor(x / 128) * 128;\n  const yOffset = Math.floor(y / 128) * 128;\n\n  const dim = Math.min(1 << level, 128);\n  const url = `tilemap/${level}/${yOffset}/${xOffset}/${dim}/${dim}`;\n\n  const availableCache = that._availableCache;\n  if (defined(availableCache[url])) {\n    return availableCache[url];\n  }\n\n  const request = new Request({\n    throttle: false,\n    throttleByServer: true,\n    type: RequestType.TERRAIN,\n  });\n\n  const tilemapResource = that._resource.getDerivedResource({\n    url: url,\n    request: request,\n  });\n\n  let promise = tilemapResource.fetchJson();\n  if (!defined(promise)) {\n    return {};\n  }\n\n  promise = promise.then(function (result) {\n    const available = computeAvailability(\n      xOffset,\n      yOffset,\n      dim,\n      dim,\n      result.data\n    );\n\n    // Mark whole area as having availability loaded\n    that._tilesAvailabilityLoaded.addAvailableTileRange(\n      level,\n      xOffset,\n      yOffset,\n      xOffset + dim,\n      yOffset + dim\n    );\n\n    const tilesAvailable = that._tilesAvailable;\n    for (let i = 0; i < available.length; ++i) {\n      const range = available[i];\n      tilesAvailable.addAvailableTileRange(\n        level,\n        range.startX,\n        range.startY,\n        range.endX,\n        range.endY\n      );\n    }\n\n    // Conveniently return availability of original tile\n    return isTileAvailable(that, level, x, y);\n  });\n\n  availableCache[url] = {\n    promise: promise,\n    request: request,\n  };\n\n  promise = promise.finally(function (result) {\n    delete availableCache[url];\n\n    return result;\n  });\n\n  return {\n    promise: promise,\n    request: request,\n  };\n}\nexport default ArcGISTiledElevationTerrainProvider;\n","import Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport FeatureDetection from \"../Core/FeatureDetection.js\";\nimport CesiumMath from \"../Core/Math.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport TaskProcessor from \"../Core/TaskProcessor.js\";\n\n/**\n * Decode I3S using web workers.\n *\n * @private\n */\nfunction I3SDecoder() {}\n\n// Maximum concurrency to use when decoding draco models\nI3SDecoder._maxDecodingConcurrency = Math.max(\n  FeatureDetection.hardwareConcurrency - 1,\n  1\n);\n\nI3SDecoder._decodeTaskProcessor = new TaskProcessor(\n  \"decodeI3S\",\n  I3SDecoder._maxDecodingConcurrency\n);\n\nI3SDecoder._promise = undefined;\n\nasync function initializeDecoder() {\n  const result = await I3SDecoder._decodeTaskProcessor.initWebAssemblyModule({\n    wasmBinaryFile: \"ThirdParty/draco_decoder.wasm\",\n  });\n  if (result) {\n    return I3SDecoder._decodeTaskProcessor;\n  }\n\n  throw new RuntimeError(\"I3S decoder could not be initialized.\");\n}\n\n/**\n * Transcodes I3S to glTF in a web worker\n * @param {String} url custom attributes source URL\n * @param {Object} defaultGeometrySchema Schema to use during decoding\n * @param {I3SGeometry} geometryData The draco encoded geometry data\n * @param {Array} [featureData] The draco encoded feature data\n * @returns Promise<undefined|object> Returns a promise which resolves to the glTF result, or undefined if the task cannot be scheduled this frame.\n *\n * @exception {RuntimeError} I3S decoder could not be initialized.\n */\nI3SDecoder.decode = async function (\n  url,\n  defaultGeometrySchema,\n  geometryData,\n  featureData\n) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.typeOf.string(\"url\", url);\n  Check.defined(\"defaultGeometrySchema\", defaultGeometrySchema);\n  Check.defined(\"geometryData\", geometryData);\n  //>>includeEnd('debug');\n\n  if (!defined(I3SDecoder._promise)) {\n    I3SDecoder._promise = initializeDecoder();\n  }\n\n  return I3SDecoder._promise.then(function (taskProcessor) {\n    // Prepare the data to send to the worker\n    const parentData = geometryData._parent._data;\n    const parentRotationInverseMatrix =\n      geometryData._parent._inverseRotationMatrix;\n\n    let longitude = 0.0;\n    let latitude = 0.0;\n    let height = 0.0;\n\n    if (defined(parentData.obb)) {\n      longitude = parentData.obb.center[0];\n      latitude = parentData.obb.center[1];\n      height = parentData.obb.center[2];\n    } else if (defined(parentData.mbs)) {\n      longitude = parentData.mbs[0];\n      latitude = parentData.mbs[1];\n      height = parentData.mbs[2];\n    }\n\n    const axisFlipRotation = Matrix3.fromRotationX(-CesiumMath.PI_OVER_TWO);\n    const parentRotation = new Matrix3();\n\n    Matrix3.multiply(\n      axisFlipRotation,\n      parentRotationInverseMatrix,\n      parentRotation\n    );\n\n    const cartographicCenter = Cartographic.fromDegrees(\n      longitude,\n      latitude,\n      height\n    );\n\n    const cartesianCenter = Ellipsoid.WGS84.cartographicToCartesian(\n      cartographicCenter\n    );\n\n    const payload = {\n      binaryData: geometryData._data,\n      featureData:\n        defined(featureData) && defined(featureData[0])\n          ? featureData[0].data\n          : undefined,\n      schema: defaultGeometrySchema,\n      bufferInfo: geometryData._geometryBufferInfo,\n      ellipsoidRadiiSquare: Ellipsoid.WGS84.radiiSquared,\n      url: url,\n      geoidDataList: geometryData._dataProvider._geoidDataList,\n      cartographicCenter: cartographicCenter,\n      cartesianCenter: cartesianCenter,\n      parentRotation: parentRotation,\n    };\n\n    return taskProcessor.scheduleTask(payload);\n  });\n};\n\nexport default I3SDecoder;\n","import defined from \"../Core/defined.js\";\nimport I3SDataProvider from \"./I3SDataProvider.js\";\n\n/**\n * This class implements an I3S Feature.\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SNode}.\n * </p>\n * @alias I3SFeature\n * @internalConstructor\n */\nfunction I3SFeature(parent, uri) {\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  this._layer = parent._layer;\n\n  if (defined(this._parent._nodeIndex)) {\n    this._resource = this._parent._layer.resource.getDerivedResource({\n      url: `nodes/${this._parent._data.mesh.attribute.resource}/${uri}`,\n    });\n  } else {\n    this._resource = this._parent.resource.getDerivedResource({ url: uri });\n  }\n}\n\nObject.defineProperties(I3SFeature.prototype, {\n  /**\n   * Gets the resource for the feature\n   * @memberof I3SFeature.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SFeature.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n});\n\n/**\n * Loads the content.\n * @returns {Promise} A promise that is resolved when the data of the I3S feature is loaded\n * @private\n */\nI3SFeature.prototype.load = async function () {\n  this._data = await I3SDataProvider.loadJson(\n    this._resource,\n    this._dataProvider._traceFetches\n  );\n  return this._data;\n};\n\nexport default I3SFeature;\n","import defined from \"../Core/defined.js\";\n\n/**\n * This class implements an I3S Field which is custom data attached\n * to nodes\n * @alias I3SField\n * @internalConstructor\n * @privateParam {I3SNode} parent The parent of that geometry\n * @privateParam {object} storageInfo The structure containing the storage info of the field\n */\nfunction I3SField(parent, storageInfo) {\n  this._storageInfo = storageInfo;\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  const uri = `attributes/${storageInfo.key}/0`;\n\n  if (defined(this._parent._nodeIndex)) {\n    this._resource = this._parent._layer.resource.getDerivedResource({\n      url: `nodes/${this._parent._data.mesh.attribute.resource}/${uri}`,\n    });\n  } else {\n    this._resource = this._parent.resource.getDerivedResource({ url: uri });\n  }\n}\n\nObject.defineProperties(I3SField.prototype, {\n  /**\n   * Gets the resource for the fields\n   * @memberof I3SField.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n  /**\n   * Gets the header for this field.\n   * @memberof I3SField.prototype\n   * @type {object}\n   * @readonly\n   */\n  header: {\n    get: function () {\n      return this._header;\n    },\n  },\n  /**\n   * Gets the values for this field.\n   * @memberof I3SField.prototype\n   * @type {object}\n   * @readonly\n   */\n  values: {\n    get: function () {\n      return defined(this._values) && defined(this._values.attributeValues)\n        ? this._values.attributeValues\n        : [];\n    },\n  },\n  /**\n   * Gets the name for the field.\n   * @memberof I3SField.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._storageInfo.name;\n    },\n  },\n});\n\nfunction getNumericTypeSize(type) {\n  if (type === \"UInt8\" || type === \"Int8\") {\n    return 1;\n  } else if (type === \"UInt16\" || type === \"Int16\") {\n    return 2;\n  } else if (\n    type === \"UInt32\" ||\n    type === \"Int32\" ||\n    type === \"Oid32\" ||\n    type === \"Float32\"\n  ) {\n    return 4;\n  } else if (type === \"UInt64\" || type === \"Int64\" || type === \"Float64\") {\n    return 8;\n  }\n\n  // Not a numeric type\n  return 0;\n}\n\n/**\n * Loads the content.\n * @returns {Promise<void>} A promise that is resolved when the field data is loaded\n */\nI3SField.prototype.load = function () {\n  const that = this;\n  return this._dataProvider._loadBinary(this._resource).then(function (data) {\n    // Check if we have a 404\n    const dataView = new DataView(data);\n    let success = true;\n    if (dataView.getUint8(0) === \"{\".charCodeAt(0)) {\n      const textContent = new TextDecoder();\n      const str = textContent.decode(data);\n      if (str.includes(\"404\")) {\n        success = false;\n        console.error(`Failed to load: ${that.resource.url}`);\n      }\n    }\n\n    if (success) {\n      that._data = data;\n      let offset = that._parseHeader(dataView);\n\n      const valueSize = getNumericTypeSize(\n        that._storageInfo.attributeValues.valueType\n      );\n      if (valueSize > 0) {\n        // Values will be padded to align the addresses with the data size\n        offset = Math.ceil(offset / valueSize) * valueSize;\n      }\n\n      that._parseBody(dataView, offset);\n    }\n  });\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseValue = function (dataView, type, offset) {\n  let value;\n  if (type === \"UInt8\") {\n    value = dataView.getUint8(offset);\n    offset += 1;\n  } else if (type === \"Int8\") {\n    value = dataView.getInt8(offset);\n    offset += 1;\n  } else if (type === \"UInt16\") {\n    value = dataView.getUint16(offset, true);\n    offset += 2;\n  } else if (type === \"Int16\") {\n    value = dataView.getInt16(offset, true);\n    offset += 2;\n  } else if (type === \"UInt32\") {\n    value = dataView.getUint32(offset, true);\n    offset += 4;\n  } else if (type === \"Oid32\") {\n    value = dataView.getUint32(offset, true);\n    offset += 4;\n  } else if (type === \"Int32\") {\n    value = dataView.getInt32(offset, true);\n    offset += 4;\n  } else if (type === \"UInt64\") {\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    value = left + Math.pow(2, 32) * right;\n    offset += 8;\n  } else if (type === \"Int64\") {\n    const left = dataView.getUint32(offset, true);\n    const right = dataView.getUint32(offset + 4, true);\n    if (right < Math.pow(2, 31)) {\n      // Positive number\n      value = left + Math.pow(2, 32) * right;\n    } else {\n      // Negative\n      value = left + Math.pow(2, 32) * (right - Math.pow(2, 32));\n    }\n\n    offset += 8;\n  } else if (type === \"Float32\") {\n    value = dataView.getFloat32(offset, true);\n    offset += 4;\n  } else if (type === \"Float64\") {\n    value = dataView.getFloat64(offset, true);\n    offset += 8;\n  } else if (type === \"String\") {\n    value = String.fromCharCode(dataView.getUint8(offset));\n    offset += 1;\n  }\n\n  return {\n    value: value,\n    offset: offset,\n  };\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseHeader = function (dataView) {\n  let offset = 0;\n  this._header = {};\n  for (\n    let itemIndex = 0;\n    itemIndex < this._storageInfo.header.length;\n    itemIndex++\n  ) {\n    const item = this._storageInfo.header[itemIndex];\n    const parsedValue = this._parseValue(dataView, item.valueType, offset);\n    this._header[item.property] = parsedValue.value;\n    offset = parsedValue.offset;\n  }\n  return offset;\n};\n\n/**\n * @private\n */\nI3SField.prototype._parseBody = function (dataView, offset) {\n  this._values = {};\n  for (\n    let itemIndex = 0;\n    itemIndex < this._storageInfo.ordering.length;\n    itemIndex++\n  ) {\n    const item = this._storageInfo.ordering[itemIndex];\n    const desc = this._storageInfo[item];\n    if (defined(desc)) {\n      this._values[item] = [];\n      for (let index = 0; index < this._header.count; ++index) {\n        if (desc.valueType !== \"String\") {\n          const parsedValue = this._parseValue(\n            dataView,\n            desc.valueType,\n            offset\n          );\n          this._values[item].push(parsedValue.value);\n          offset = parsedValue.offset;\n        } else {\n          const stringLen = this._values.attributeByteCounts[index];\n          let stringContent = \"\";\n          for (let cIndex = 0; cIndex < stringLen; ++cIndex) {\n            const curParsedValue = this._parseValue(\n              dataView,\n              desc.valueType,\n              offset\n            );\n            if (curParsedValue.value.charCodeAt(0) !== 0) {\n              stringContent += curParsedValue.value;\n            }\n            offset = curParsedValue.offset;\n          }\n          // We skip the last character of the string since it's a null terminator\n          this._values[item].push(stringContent);\n        }\n      }\n    }\n  }\n};\n\nexport default I3SField;\n","import Cartesian3 from \"../Core/Cartesian3.js\";\nimport defined from \"../Core/defined.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\n\n/**\n * This class implements an I3S Geometry. Each I3SGeometry\n * generates an in memory glTF to be used as content for a Cesium3DTile\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SNode}.\n * </p>\n * @alias I3SGeometry\n * @internalConstructor\n * @privateParam {I3SNode} parent The parent of that geometry\n * @privateParam {string} uri The uri to load the data from\n */\nfunction I3SGeometry(parent, uri) {\n  const dataProvider = parent._dataProvider;\n  const layer = parent._layer;\n\n  let resource;\n\n  if (defined(parent._nodeIndex)) {\n    resource = layer.resource.getDerivedResource({\n      url: `nodes/${parent._data.mesh.geometry.resource}/${uri}`,\n    });\n  } else {\n    resource = parent.resource.getDerivedResource({ url: uri });\n  }\n\n  this._parent = parent;\n  this._dataProvider = dataProvider;\n  this._layer = layer;\n  this._resource = resource;\n\n  this._customAttributes = undefined;\n}\n\nObject.defineProperties(I3SGeometry.prototype, {\n  /**\n   * Gets the resource for the geometry\n   * @memberof I3SGeometry.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SGeometry.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n  /**\n   * Gets the custom attributes of the geometry.\n   * @memberof I3SGeometry.prototype\n   * @type {object}\n   * @readonly\n   */\n  customAttributes: {\n    get: function () {\n      return this._customAttributes;\n    },\n  },\n});\n\n/**\n * Loads the content.\n * @returns {Promise<object>} A promise that is resolved when the geometry data is loaded\n * @private\n */\nI3SGeometry.prototype.load = function () {\n  const that = this;\n  return this._dataProvider._loadBinary(this._resource).then(function (data) {\n    that._data = data;\n    return data;\n  });\n};\n\nconst scratchAb = new Cartesian3();\nconst scratchAp1 = new Cartesian3();\nconst scratchAp2 = new Cartesian3();\nconst scratchCp1 = new Cartesian3();\nconst scratchCp2 = new Cartesian3();\n\nfunction sameSide(p1, p2, a, b) {\n  const ab = Cartesian3.subtract(b, a, scratchAb);\n  const cp1 = Cartesian3.cross(\n    ab,\n    Cartesian3.subtract(p1, a, scratchAp1),\n    scratchCp1\n  );\n  const cp2 = Cartesian3.cross(\n    ab,\n    Cartesian3.subtract(p2, a, scratchAp2),\n    scratchCp2\n  );\n  return Cartesian3.dot(cp1, cp2) >= 0;\n}\n\nconst scratchV0 = new Cartesian3();\nconst scratchV1 = new Cartesian3();\nconst scratchV2 = new Cartesian3();\n\nconst scratchV0V1 = new Cartesian3();\nconst scratchV0V2 = new Cartesian3();\nconst scratchCrossProd = new Cartesian3();\nconst scratchNormal = new Cartesian3();\n\nconst scratchV0p = new Cartesian3();\nconst scratchV1p = new Cartesian3();\nconst scratchV2p = new Cartesian3();\n\n/**\n * Find a triangle touching the point [px, py, pz], then return the vertex closest to the search point\n * @param {number} px The x component of the point to query\n * @param {number} py The y component of the point to query\n * @param {number} pz The z component of the point to query\n * @returns {object} A structure containing the index of the closest point,\n * the squared distance from the queried point to the point that is found,\n * the distance from the queried point to the point that is found,\n * the queried position in local space,\n * the closest position in local space\n */\nI3SGeometry.prototype.getClosestPointIndexOnTriangle = function (px, py, pz) {\n  if (\n    defined(this._customAttributes) &&\n    defined(this._customAttributes.positions)\n  ) {\n    // Convert queried position to local\n    const position = new Cartesian3(px, py, pz);\n\n    position.x -= this._customAttributes.cartesianCenter.x;\n    position.y -= this._customAttributes.cartesianCenter.y;\n    position.z -= this._customAttributes.cartesianCenter.z;\n    Matrix3.multiplyByVector(\n      this._customAttributes.parentRotation,\n      position,\n      position\n    );\n\n    let bestTriDist = Number.MAX_VALUE;\n    let bestTri;\n    let bestDistSq;\n    let bestIndex;\n    let bestPt;\n\n    // Brute force lookup, @TODO: this can be improved with a spatial partitioning search system\n    const positions = this._customAttributes.positions;\n    const indices = this._customAttributes.indices;\n\n    // We may have indexed or non-indexed triangles here\n    let triCount;\n    if (defined(indices)) {\n      triCount = indices.length;\n    } else {\n      triCount = positions.length / 3;\n    }\n\n    for (let triIndex = 0; triIndex < triCount; triIndex++) {\n      let i0, i1, i2;\n      if (defined(indices)) {\n        i0 = indices[triIndex];\n        i1 = indices[triIndex + 1];\n        i2 = indices[triIndex + 2];\n      } else {\n        i0 = triIndex * 3;\n        i1 = triIndex * 3 + 1;\n        i2 = triIndex * 3 + 2;\n      }\n\n      const v0 = Cartesian3.fromElements(\n        positions[i0 * 3],\n        positions[i0 * 3 + 1],\n        positions[i0 * 3 + 2],\n        scratchV0\n      );\n      const v1 = Cartesian3.fromElements(\n        positions[i1 * 3],\n        positions[i1 * 3 + 1],\n        positions[i1 * 3 + 2],\n        scratchV1\n      );\n      const v2 = new Cartesian3(\n        positions[i2 * 3],\n        positions[i2 * 3 + 1],\n        positions[i2 * 3 + 2],\n        scratchV2\n      );\n\n      // Check how the point is positioned relative to the triangle.\n      // This will tell us whether the projection of the point in the triangle's plane lands in the triangle\n      if (\n        !sameSide(position, v0, v1, v2) ||\n        !sameSide(position, v1, v0, v2) ||\n        !sameSide(position, v2, v0, v1)\n      ) {\n        continue;\n      }\n      // Because of precision issues, we can't always reliably tell if the point lands directly on the face, so the most robust way is just to find the closest one\n      const v0v1 = Cartesian3.subtract(v1, v0, scratchV0V1);\n      const v0v2 = Cartesian3.subtract(v2, v0, scratchV0V2);\n      const crossProd = Cartesian3.cross(v0v1, v0v2, scratchCrossProd);\n\n      // Skip \"triangles\" with 3 colinear points\n      if (Cartesian3.magnitude(crossProd) === 0) {\n        continue;\n      }\n      const normal = Cartesian3.normalize(crossProd, scratchNormal);\n\n      const v0p = Cartesian3.subtract(position, v0, scratchV0p);\n      const normalDist = Math.abs(Cartesian3.dot(v0p, normal));\n      if (normalDist < bestTriDist) {\n        bestTriDist = normalDist;\n        bestTri = triIndex;\n\n        // Found a triangle, return the index of the closest point\n        const d0 = Cartesian3.magnitudeSquared(\n          Cartesian3.subtract(position, v0, v0p)\n        );\n        const d1 = Cartesian3.magnitudeSquared(\n          Cartesian3.subtract(position, v1, scratchV1p)\n        );\n        const d2 = Cartesian3.magnitudeSquared(\n          Cartesian3.subtract(position, v2, scratchV2p)\n        );\n        if (d0 < d1 && d0 < d2) {\n          bestIndex = i0;\n          bestPt = v0;\n          bestDistSq = d0;\n        } else if (d1 < d2) {\n          bestIndex = i1;\n          bestPt = v1;\n          bestDistSq = d1;\n        } else {\n          bestIndex = i2;\n          bestPt = v2;\n          bestDistSq = d2;\n        }\n      }\n    }\n\n    if (defined(bestTri)) {\n      return {\n        index: bestIndex,\n        distanceSquared: bestDistSq,\n        distance: Math.sqrt(bestDistSq),\n        queriedPosition: position,\n        closestPosition: Cartesian3.clone(bestPt),\n      };\n    }\n  }\n\n  // No hits found\n  return {\n    index: -1,\n    distanceSquared: Number.Infinity,\n    distance: Number.Infinity,\n  };\n};\n\n/**\n * @private\n */\nI3SGeometry.prototype._generateGltf = function (\n  nodesInScene,\n  nodes,\n  meshes,\n  buffers,\n  bufferViews,\n  accessors\n) {\n  // Get the material definition\n  let gltfMaterial = {\n    pbrMetallicRoughness: {\n      metallicFactor: 0.0,\n    },\n    doubleSided: true,\n    name: \"Material\",\n  };\n\n  let isTextured = false;\n  let materialDefinition;\n  let texturePath = \"\";\n  if (\n    defined(this._parent._data.mesh) &&\n    defined(this._layer._data.materialDefinitions)\n  ) {\n    const materialInfo = this._parent._data.mesh.material;\n    const materialIndex = materialInfo.definition;\n    if (\n      materialIndex >= 0 &&\n      materialIndex < this._layer._data.materialDefinitions.length\n    ) {\n      materialDefinition = this._layer._data.materialDefinitions[materialIndex];\n      gltfMaterial = materialDefinition;\n\n      if (\n        defined(gltfMaterial.pbrMetallicRoughness) &&\n        defined(gltfMaterial.pbrMetallicRoughness.baseColorTexture)\n      ) {\n        isTextured = true;\n        gltfMaterial.pbrMetallicRoughness.baseColorTexture.index = 0;\n\n        // Choose the JPG for the texture\n        let textureName = \"0\";\n\n        if (defined(this._layer._data.textureSetDefinitions)) {\n          for (\n            let defIndex = 0;\n            defIndex < this._layer._data.textureSetDefinitions.length;\n            defIndex++\n          ) {\n            const textureSetDefinition = this._layer._data\n              .textureSetDefinitions[defIndex];\n            for (\n              let formatIndex = 0;\n              formatIndex < textureSetDefinition.formats.length;\n              formatIndex++\n            ) {\n              const textureFormat = textureSetDefinition.formats[formatIndex];\n              if (textureFormat.format === \"jpg\") {\n                textureName = textureFormat.name;\n                break;\n              }\n            }\n          }\n        }\n\n        if (\n          defined(this._parent._data.mesh) &&\n          this._parent._data.mesh.material.resource >= 0\n        ) {\n          texturePath = this._layer.resource.getDerivedResource({\n            url: `nodes/${this._parent._data.mesh.material.resource}/textures/${textureName}`,\n          }).url;\n        }\n      }\n    }\n  } else if (defined(this._parent._data.textureData)) {\n    // No material definition, but if there's a texture reference, we can create a simple material using it (version 1.6 support)\n    isTextured = true;\n    texturePath = this._parent.resource.getDerivedResource({\n      url: `${this._parent._data.textureData[0].href}`,\n    }).url;\n    gltfMaterial.pbrMetallicRoughness.baseColorTexture = { index: 0 };\n  }\n\n  let gltfTextures = [];\n  let gltfImages = [];\n  let gltfSamplers = [];\n\n  if (isTextured) {\n    gltfTextures = [\n      {\n        sampler: 0,\n        source: 0,\n      },\n    ];\n\n    gltfImages = [\n      {\n        uri: texturePath,\n      },\n    ];\n\n    gltfSamplers = [\n      {\n        magFilter: 9729,\n        minFilter: 9986,\n        wrapS: 10497,\n        wrapT: 10497,\n      },\n    ];\n  }\n\n  const gltfData = {\n    scene: 0,\n    scenes: [\n      {\n        nodes: nodesInScene,\n      },\n    ],\n    nodes: nodes,\n    meshes: meshes,\n    buffers: buffers,\n    bufferViews: bufferViews,\n    accessors: accessors,\n    materials: [gltfMaterial],\n    textures: gltfTextures,\n    images: gltfImages,\n    samplers: gltfSamplers,\n    asset: {\n      version: \"2.0\",\n    },\n  };\n\n  return gltfData;\n};\n\nexport default I3SGeometry;\n","import Cartographic from \"../Core/Cartographic.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport Ellipsoid from \"../Core/Ellipsoid.js\";\nimport HeadingPitchRoll from \"../Core/HeadingPitchRoll.js\";\nimport Matrix3 from \"../Core/Matrix3.js\";\nimport Matrix4 from \"../Core/Matrix4.js\";\nimport Resource from \"../Core/Resource.js\";\nimport Quaternion from \"../Core/Quaternion.js\";\nimport Transforms from \"../Core/Transforms.js\";\nimport Cesium3DTile from \"./Cesium3DTile.js\";\nimport I3SDataProvider from \"./I3SDataProvider.js\";\nimport I3SDecoder from \"./I3SDecoder.js\";\nimport I3SFeature from \"./I3SFeature.js\";\nimport I3SField from \"./I3SField.js\";\nimport I3SGeometry from \"./I3SGeometry.js\";\n\n/**\n * This class implements an I3S Node. In CesiumJS each I3SNode creates a Cesium3DTile.\n * <p>\n * Do not construct this directly, instead access tiles through {@link I3SLayer}.\n * </p>\n * @alias I3SNode\n * @internalConstructor\n */\nfunction I3SNode(parent, ref, isRoot) {\n  let level;\n  let layer;\n  let nodeIndex;\n  let resource;\n\n  if (isRoot) {\n    level = 0;\n    layer = parent;\n  } else {\n    level = parent._level + 1;\n    layer = parent._layer;\n  }\n\n  if (typeof ref === \"number\") {\n    nodeIndex = ref;\n  } else {\n    resource = parent.resource.getDerivedResource({\n      url: `${ref}/`,\n    });\n  }\n\n  this._parent = parent;\n  this._dataProvider = parent._dataProvider;\n  this._isRoot = isRoot;\n  this._level = level;\n  this._layer = layer;\n  this._nodeIndex = nodeIndex;\n  this._resource = resource;\n  this._isLoading = false;\n\n  this._tile = undefined;\n  this._data = undefined;\n  this._geometryData = [];\n  this._featureData = [];\n  this._fields = {};\n  this._children = [];\n  this._childrenReadyPromise = undefined;\n  this._globalTransform = undefined;\n  this._inverseGlobalTransform = undefined;\n  this._inverseRotationMatrix = undefined;\n}\n\nObject.defineProperties(I3SNode.prototype, {\n  /**\n   * Gets the resource for the node.\n   * @memberof I3SNode.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n  /**\n   * Gets the parent layer.\n   * @memberof I3SNode.prototype\n   * @type {I3SLayer}\n   * @readonly\n   */\n  layer: {\n    get: function () {\n      return this._layer;\n    },\n  },\n  /**\n   * Gets the parent node.\n   * @memberof I3SNode.prototype\n   * @type {I3SNode|undefined}\n   * @readonly\n   */\n  parent: {\n    get: function () {\n      return this._parent;\n    },\n  },\n  /**\n   * Gets the children nodes.\n   * @memberof I3SNode.prototype\n   * @type {I3SNode[]}\n   * @readonly\n   */\n  children: {\n    get: function () {\n      return this._children;\n    },\n  },\n  /**\n   * Gets the collection of geometries.\n   * @memberof I3SNode.prototype\n   * @type {I3SGeometry[]}\n   * @readonly\n   */\n  geometryData: {\n    get: function () {\n      return this._geometryData;\n    },\n  },\n  /**\n   * Gets the collection of features.\n   * @memberof I3SNode.prototype\n   * @type {I3SFeature[]}\n   * @readonly\n   */\n  featureData: {\n    get: function () {\n      return this._featureData;\n    },\n  },\n  /**\n   * Gets the collection of fields.\n   * @memberof I3SNode.prototype\n   * @type {I3SField[]}\n   * @readonly\n   */\n  fields: {\n    get: function () {\n      return this._fields;\n    },\n  },\n  /**\n   * Gets the Cesium3DTile for this node.\n   * @memberof I3SNode.prototype\n   * @type {Cesium3DTile}\n   * @readonly\n   */\n  tile: {\n    get: function () {\n      return this._tile;\n    },\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SNode.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n});\n\n/**\n * @private\n */\nI3SNode.prototype.load = async function () {\n  const that = this;\n\n  function processData() {\n    if (!that._isRoot) {\n      // Create a new tile\n      const tileDefinition = that._create3DTileDefinition();\n\n      that._tile = new Cesium3DTile(\n        that._layer._tileset,\n        that._dataProvider.resource,\n        tileDefinition,\n        that._parent._tile\n      );\n\n      that._tile._i3sNode = that;\n    }\n  }\n\n  // If we don't have a nodepage index load from json\n  if (!defined(this._nodeIndex)) {\n    const data = await I3SDataProvider.loadJson(\n      this._resource,\n      this._dataProvider._traceFetches\n    );\n    that._data = data;\n    processData();\n    return;\n  }\n\n  const node = await this._layer._getNodeInNodePages(this._nodeIndex);\n  that._data = node;\n  let uri;\n  if (that._isRoot) {\n    uri = \"nodes/root/\";\n  } else if (defined(node.mesh)) {\n    const uriIndex = node.mesh.geometry.resource;\n    uri = `../${uriIndex}/`;\n  }\n  if (defined(uri)) {\n    that._resource = that._parent.resource.getDerivedResource({ url: uri });\n  }\n\n  processData();\n};\n\n/**\n * Loads the node fields.\n * @returns {Promise<void>} A promise that is resolved when the I3S Node fields are loaded\n */\nI3SNode.prototype.loadFields = function () {\n  // Check if we must load fields\n  const fields = this._layer._data.attributeStorageInfo;\n\n  const that = this;\n  function createAndLoadField(fields, index) {\n    const newField = new I3SField(that, fields[index]);\n    that._fields[newField._storageInfo.name] = newField;\n    return newField.load();\n  }\n\n  const promises = [];\n  if (defined(fields)) {\n    for (let i = 0; i < fields.length; i++) {\n      promises.push(createAndLoadField(fields, i));\n    }\n  }\n\n  return Promise.all(promises);\n};\n\n/**\n * Returns the fields for a given picked position\n * @param {Cartesian3} pickedPosition The picked position\n * @returns {object} Object containing field names and their values\n */\nI3SNode.prototype.getFieldsForPickedPosition = function (pickedPosition) {\n  const geometry = this.geometryData[0];\n  if (!defined(geometry.customAttributes.featureIndex)) {\n    return {};\n  }\n\n  const location = geometry.getClosestPointIndexOnTriangle(\n    pickedPosition.x,\n    pickedPosition.y,\n    pickedPosition.z\n  );\n\n  if (\n    location.index === -1 ||\n    location.index > geometry.customAttributes.featureIndex.length\n  ) {\n    return {};\n  }\n\n  const featureIndex = geometry.customAttributes.featureIndex[location.index];\n  return this.getFieldsForFeature(featureIndex);\n};\n\n/**\n * Returns the fields for a given feature\n * @param {number} featureIndex Index of the feature whose attributes we want to get\n * @returns {object} Object containing field names and their values\n */\nI3SNode.prototype.getFieldsForFeature = function (featureIndex) {\n  const featureFields = {};\n  for (const fieldName in this.fields) {\n    if (this.fields.hasOwnProperty(fieldName)) {\n      const field = this.fields[fieldName];\n      if (featureIndex >= 0 && featureIndex < field.values.length) {\n        featureFields[field.name] = field.values[featureIndex];\n      }\n    }\n  }\n  return featureFields;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadChildren = function () {\n  const that = this;\n  // If the promise for loading the children was already created, just return it\n  if (defined(this._childrenReadyPromise)) {\n    return this._childrenReadyPromise;\n  }\n\n  const childPromises = [];\n  if (defined(that._data.children)) {\n    for (\n      let childIndex = 0;\n      childIndex < that._data.children.length;\n      childIndex++\n    ) {\n      const child = that._data.children[childIndex];\n      const newChild = new I3SNode(\n        that,\n        defaultValue(child.href, child),\n        false\n      );\n      that._children.push(newChild);\n      childPromises.push(newChild.load());\n    }\n  }\n\n  this._childrenReadyPromise = Promise.all(childPromises).then(function () {\n    for (let i = 0; i < that._children.length; i++) {\n      that._tile.children.push(that._children[i]._tile);\n    }\n  });\n\n  return this._childrenReadyPromise;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadGeometryData = function () {\n  const geometryPromises = [];\n\n  // To debug decoding for a specific tile, add a condition\n  // that wraps this if/else to match the tile uri\n  if (defined(this._data.geometryData)) {\n    for (\n      let geomIndex = 0;\n      geomIndex < this._data.geometryData.length;\n      geomIndex++\n    ) {\n      const curGeometryData = new I3SGeometry(\n        this,\n        this._data.geometryData[geomIndex].href\n      );\n      this._geometryData.push(curGeometryData);\n      geometryPromises.push(curGeometryData.load());\n    }\n  } else if (defined(this._data.mesh)) {\n    const geometryDefinition = this._layer._findBestGeometryBuffers(\n      this._data.mesh.geometry.definition,\n      [\"position\", \"uv0\"]\n    );\n\n    const geometryURI = `./geometries/${geometryDefinition.bufferIndex}/`;\n    const newGeometryData = new I3SGeometry(this, geometryURI);\n    newGeometryData._geometryDefinitions = geometryDefinition.definition;\n    newGeometryData._geometryBufferInfo = geometryDefinition.geometryBufferInfo;\n    this._geometryData.push(newGeometryData);\n    geometryPromises.push(newGeometryData.load());\n  }\n\n  return Promise.all(geometryPromises);\n};\n\n/**\n * @private\n */\nI3SNode.prototype._loadFeatureData = function () {\n  const featurePromises = [];\n\n  // To debug decoding for a specific tile, add a condition\n  // that wraps this if/else to match the tile uri\n  if (defined(this._data.featureData)) {\n    for (\n      let featureIndex = 0;\n      featureIndex < this._data.featureData.length;\n      featureIndex++\n    ) {\n      const newFeatureData = new I3SFeature(\n        this,\n        this._data.featureData[featureIndex].href\n      );\n      this._featureData.push(newFeatureData);\n      featurePromises.push(newFeatureData.load());\n    }\n  }\n\n  return Promise.all(featurePromises);\n};\n\n/**\n * @private\n */\nI3SNode.prototype._clearGeometryData = function () {\n  this._geometryData = [];\n};\n\n/**\n * @private\n */\nI3SNode.prototype._create3DTileDefinition = function () {\n  const obb = this._data.obb;\n  const mbs = this._data.mbs;\n\n  if (!defined(obb) && !defined(mbs)) {\n    console.error(\"Failed to load I3S node. Bounding volume is required.\");\n    return undefined;\n  }\n\n  let geoPosition;\n\n  if (defined(obb)) {\n    geoPosition = Cartographic.fromDegrees(\n      obb.center[0],\n      obb.center[1],\n      obb.center[2]\n    );\n  } else {\n    geoPosition = Cartographic.fromDegrees(mbs[0], mbs[1], mbs[2]);\n  }\n\n  // Offset bounding box position if we have a geoid service defined\n  if (defined(this._dataProvider._geoidDataList) && defined(geoPosition)) {\n    for (let i = 0; i < this._dataProvider._geoidDataList.length; i++) {\n      const tile = this._dataProvider._geoidDataList[i];\n      const projectedPos = tile.projection.project(geoPosition);\n      if (\n        projectedPos.x > tile.nativeExtent.west &&\n        projectedPos.x < tile.nativeExtent.east &&\n        projectedPos.y > tile.nativeExtent.south &&\n        projectedPos.y < tile.nativeExtent.north\n      ) {\n        geoPosition.height += sampleGeoid(projectedPos.x, projectedPos.y, tile);\n        break;\n      }\n    }\n  }\n\n  let boundingVolume = {};\n  let position;\n  let span = 0;\n  if (defined(obb)) {\n    boundingVolume = {\n      box: [\n        0,\n        0,\n        0,\n        obb.halfSize[0],\n        0,\n        0,\n        0,\n        obb.halfSize[1],\n        0,\n        0,\n        0,\n        obb.halfSize[2],\n      ],\n    };\n    span = Math.max(\n      Math.max(this._data.obb.halfSize[0], this._data.obb.halfSize[1]),\n      this._data.obb.halfSize[2]\n    );\n    position = Ellipsoid.WGS84.cartographicToCartesian(geoPosition);\n  } else {\n    boundingVolume = {\n      sphere: [0, 0, 0, mbs[3]],\n    };\n    position = Ellipsoid.WGS84.cartographicToCartesian(geoPosition);\n    span = this._data.mbs[3];\n  }\n  span *= 2;\n  // Compute the geometric error\n  let metersPerPixel = Infinity;\n\n  // Get the meters/pixel density required to pop the next LOD\n  if (defined(this._data.lodThreshold)) {\n    if (\n      this._layer._data.nodePages.lodSelectionMetricType ===\n      \"maxScreenThresholdSQ\"\n    ) {\n      const maxScreenThreshold = Math.sqrt(\n        this._data.lodThreshold / (Math.PI * 0.25)\n      );\n      metersPerPixel = span / maxScreenThreshold;\n    } else if (\n      this._layer._data.nodePages.lodSelectionMetricType ===\n      \"maxScreenThreshold\"\n    ) {\n      const maxScreenThreshold = this._data.lodThreshold;\n      metersPerPixel = span / maxScreenThreshold;\n    } else {\n      // Other LOD selection types can only be used for point cloud data\n      console.error(\"Invalid lodSelectionMetricType in Layer\");\n    }\n  } else if (defined(this._data.lodSelection)) {\n    for (\n      let lodIndex = 0;\n      lodIndex < this._data.lodSelection.length;\n      lodIndex++\n    ) {\n      if (\n        this._data.lodSelection[lodIndex].metricType === \"maxScreenThreshold\"\n      ) {\n        metersPerPixel = span / this._data.lodSelection[lodIndex].maxError;\n      }\n    }\n  }\n\n  if (metersPerPixel === Infinity) {\n    metersPerPixel = 100000;\n  }\n\n  // Calculate the length of 16 pixels in order to trigger the screen space error\n  const geometricError = metersPerPixel * 16;\n\n  // Transformations\n  const hpr = new HeadingPitchRoll(0, 0, 0);\n  let orientation = Transforms.headingPitchRollQuaternion(position, hpr);\n\n  if (defined(this._data.obb)) {\n    orientation = new Quaternion(\n      this._data.obb.quaternion[0],\n      this._data.obb.quaternion[1],\n      this._data.obb.quaternion[2],\n      this._data.obb.quaternion[3]\n    );\n  }\n\n  const rotationMatrix = Matrix3.fromQuaternion(orientation);\n  const inverseRotationMatrix = Matrix3.inverse(rotationMatrix, new Matrix3());\n\n  const globalTransform = new Matrix4(\n    rotationMatrix[0],\n    rotationMatrix[1],\n    rotationMatrix[2],\n    0,\n    rotationMatrix[3],\n    rotationMatrix[4],\n    rotationMatrix[5],\n    0,\n    rotationMatrix[6],\n    rotationMatrix[7],\n    rotationMatrix[8],\n    0,\n    position.x,\n    position.y,\n    position.z,\n    1\n  );\n\n  const inverseGlobalTransform = Matrix4.inverse(\n    globalTransform,\n    new Matrix4()\n  );\n\n  const localTransform = Matrix4.clone(globalTransform);\n\n  if (defined(this._parent._globalTransform)) {\n    Matrix4.multiply(\n      globalTransform,\n      this._parent._inverseGlobalTransform,\n      localTransform\n    );\n  }\n\n  this._globalTransform = globalTransform;\n  this._inverseGlobalTransform = inverseGlobalTransform;\n  this._inverseRotationMatrix = inverseRotationMatrix;\n\n  // get children definition\n  const childrenDefinition = [];\n  for (let childIndex = 0; childIndex < this._children.length; childIndex++) {\n    childrenDefinition.push(\n      this._children[childIndex]._create3DTileDefinition()\n    );\n  }\n\n  // Create a tile set\n  const inPlaceTileDefinition = {\n    children: childrenDefinition,\n    refine: \"REPLACE\",\n    boundingVolume: boundingVolume,\n    transform: [\n      localTransform[0],\n      localTransform[4],\n      localTransform[8],\n      localTransform[12],\n      localTransform[1],\n      localTransform[5],\n      localTransform[9],\n      localTransform[13],\n      localTransform[2],\n      localTransform[6],\n      localTransform[10],\n      localTransform[14],\n      localTransform[3],\n      localTransform[7],\n      localTransform[11],\n      localTransform[15],\n    ],\n    content: {\n      uri: defined(this._resource) ? this._resource.url : undefined,\n    },\n    geometricError: geometricError,\n  };\n\n  return inPlaceTileDefinition;\n};\n\n/**\n * @private\n */\nI3SNode.prototype._createContentURL = async function () {\n  let rawGltf = {\n    scene: 0,\n    scenes: [\n      {\n        nodes: [0],\n      },\n    ],\n    nodes: [\n      {\n        name: \"singleNode\",\n      },\n    ],\n    meshes: [],\n    buffers: [],\n    bufferViews: [],\n    accessors: [],\n    materials: [],\n    textures: [],\n    images: [],\n    samplers: [],\n    asset: {\n      version: \"2.0\",\n    },\n  };\n\n  // Load the geometry data\n  const dataPromises = [this._loadGeometryData()];\n  if (this._dataProvider.legacyVersion16) {\n    dataPromises.push(this._loadFeatureData());\n  }\n\n  await Promise.all(dataPromises);\n  // Binary glTF\n  if (defined(this._geometryData) && this._geometryData.length > 0) {\n    const url = this._geometryData[0].resource.url;\n    const geometrySchema = this._layer._data.store.defaultGeometrySchema;\n    const geometryData = this._geometryData[0];\n    const result = await I3SDecoder.decode(\n      url,\n      geometrySchema,\n      geometryData,\n      this._featureData[0]\n    );\n    if (!defined(result)) {\n      // Postponed\n      return;\n    }\n\n    rawGltf = geometryData._generateGltf(\n      result.meshData.nodesInScene,\n      result.meshData.nodes,\n      result.meshData.meshes,\n      result.meshData.buffers,\n      result.meshData.bufferViews,\n      result.meshData.accessors\n    );\n\n    this._geometryData[0]._customAttributes = result.meshData._customAttributes;\n  }\n\n  const binaryGltfData = this._dataProvider._binarizeGltf(rawGltf);\n  const glbDataBlob = new Blob([binaryGltfData], {\n    type: \"application/binary\",\n  });\n  return URL.createObjectURL(glbDataBlob);\n};\n\n// Reimplement Cesium3DTile.prototype.requestContent so that\n// We get a chance to load our own gltf from I3S data\nCesium3DTile.prototype._hookedRequestContent =\n  Cesium3DTile.prototype.requestContent;\n\n/**\n * Requests the tile's content.\n * <p>\n * The request may not be made if the Cesium Request Scheduler can't prioritize it.\n * </p>\n *\n * @return {Promise<Cesium3DTileContent>|undefined} A promise that resolves when the request completes, or undefined if there is no request needed, or the request cannot be scheduled.\n * @private\n */\nCesium3DTile.prototype.requestContent = function () {\n  if (!this.tileset._isI3STileSet) {\n    return this._hookedRequestContent();\n  }\n\n  if (!this._isLoading) {\n    this._isLoading = true;\n    return this._i3sNode\n      ._createContentURL()\n      .then((url) => {\n        if (!defined(url)) {\n          this._isLoading = false;\n          return;\n        }\n\n        this._contentResource = new Resource({ url: url });\n        return this._hookedRequestContent();\n      })\n      .then((content) => {\n        this._isLoading = false;\n        return content;\n      });\n  }\n};\n\nfunction bilinearInterpolate(tx, ty, h00, h10, h01, h11) {\n  const a = h00 * (1 - tx) + h10 * tx;\n  const b = h01 * (1 - tx) + h11 * tx;\n  return a * (1 - ty) + b * ty;\n}\n\nfunction sampleMap(u, v, width, data) {\n  const address = u + v * width;\n  return data[address];\n}\n\nfunction sampleGeoid(sampleX, sampleY, geoidData) {\n  const extent = geoidData.nativeExtent;\n  let x =\n    ((sampleX - extent.west) / (extent.east - extent.west)) *\n    (geoidData.width - 1);\n  let y =\n    ((sampleY - extent.south) / (extent.north - extent.south)) *\n    (geoidData.height - 1);\n  const xi = Math.floor(x);\n  let yi = Math.floor(y);\n\n  x -= xi;\n  y -= yi;\n\n  const xNext = xi < geoidData.width ? xi + 1 : xi;\n  let yNext = yi < geoidData.height ? yi + 1 : yi;\n\n  yi = geoidData.height - 1 - yi;\n  yNext = geoidData.height - 1 - yNext;\n\n  const h00 = sampleMap(xi, yi, geoidData.width, geoidData.buffer);\n  const h10 = sampleMap(xNext, yi, geoidData.width, geoidData.buffer);\n  const h01 = sampleMap(xi, yNext, geoidData.width, geoidData.buffer);\n  const h11 = sampleMap(xNext, yNext, geoidData.width, geoidData.buffer);\n\n  let finalHeight = bilinearInterpolate(x, y, h00, h10, h01, h11);\n  finalHeight = finalHeight * geoidData.scale + geoidData.offset;\n  return finalHeight;\n}\n\nObject.defineProperties(Cesium3DTile.prototype, {\n  /**\n   * Gets the I3S Node for the tile.\n   * @memberof Cesium3DTile.prototype\n   * @type {string}\n   */\n  i3sNode: {\n    get: function () {\n      return this._i3sNode;\n    },\n  },\n});\n\nexport default I3SNode;\n","import defined from \"../Core/defined.js\";\nimport Rectangle from \"../Core/Rectangle.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport Cesium3DTileset from \"./Cesium3DTileset.js\";\nimport I3SNode from \"./I3SNode.js\";\n\n/**\n * This class implements an I3S layer. In CesiumJS each I3SLayer creates a Cesium3DTileset.\n * <p>\n * Do not construct this directly, instead access layers through {@link I3SDataProvider}.\n * </p>\n * @alias I3SLayer\n * @internalConstructor\n * @privateParam {I3SDataProvider} dataProvider The i3s data provider\n * @privateParam {object} layerData The layer data that is loaded from the scene layer\n * @privateParam {number} index The index of the layer to be reflected\n */\nfunction I3SLayer(dataProvider, layerData, index) {\n  this._dataProvider = dataProvider;\n\n  if (!defined(layerData.href) && defined(index)) {\n    // assign a default layer\n    layerData.href = `layers/${index}`;\n  }\n\n  const dataProviderUrl = this._dataProvider.resource.getUrlComponent();\n\n  let tilesetUrl = \"\";\n  if (dataProviderUrl.match(/layers\\/\\d/)) {\n    tilesetUrl = `${dataProviderUrl}`.replace(/\\/+$/, \"\");\n  } else {\n    // Add '/' to url if needed + `${layerData.href}` if tilesetUrl not already in ../layers/[id] format\n    tilesetUrl = `${dataProviderUrl}`\n      .replace(/\\/?$/, \"/\")\n      .concat(`${layerData.href}`);\n  }\n\n  this._version = layerData.store.version;\n  const splitVersion = this._version.split(\".\");\n  this._majorVersion = parseInt(splitVersion[0]);\n  this._minorVersion = splitVersion.length > 1 ? parseInt(splitVersion[1]) : 0;\n\n  this._resource = new Resource({ url: tilesetUrl });\n  this._resource.setQueryParameters(\n    this._dataProvider.resource.queryParameters\n  );\n  this._resource.appendForwardSlash();\n  this._data = layerData;\n  this._rootNode = undefined;\n  this._nodePages = {};\n  this._nodePageFetches = {};\n  this._extent = undefined;\n  this._tileset = undefined;\n  this._geometryDefinitions = undefined;\n\n  this._computeGeometryDefinitions(true);\n  this._computeExtent();\n}\n\nObject.defineProperties(I3SLayer.prototype, {\n  /**\n   * Gets the resource for the layer.\n   * @memberof I3SLayer.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n\n  /**\n   * Gets the root node of this layer.\n   * @memberof I3SLayer.prototype\n   * @type {I3SNode}\n   * @readonly\n   */\n  rootNode: {\n    get: function () {\n      return this._rootNode;\n    },\n  },\n  /**\n   * Gets the Cesium3DTileset for this layer.\n   * @memberof I3SLayer.prototype\n   * @type {Cesium3DTileset|undefined}\n   * @readonly\n   */\n  tileset: {\n    get: function () {\n      return this._tileset;\n    },\n  },\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SLayer.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n\n  /**\n   * The version string of the loaded I3S dataset\n   * @memberof I3SLayer.prototype\n   * @type {string}\n   * @readonly\n   */\n  version: {\n    get: function () {\n      return this._version;\n    },\n  },\n\n  /**\n   * The major version number of the loaded I3S dataset\n   * @memberof I3SLayer.prototype\n   * @type {number}\n   * @readonly\n   */\n  majorVersion: {\n    get: function () {\n      return this._majorVersion;\n    },\n  },\n\n  /**\n   * The minor version number of the loaded I3S dataset\n   * @memberof I3SLayer.prototype\n   * @type {number}\n   * @readonly\n   */\n  minorVersion: {\n    get: function () {\n      return this._minorVersion;\n    },\n  },\n\n  /**\n   * When <code>true</code>, when the loaded I3S version is 1.6 or older\n   * @memberof I3SLayer.prototype\n   * @type {boolean}\n   * @readonly\n   */\n  legacyVersion16: {\n    get: function () {\n      if (!defined(this.version)) {\n        return undefined;\n      }\n      if (\n        this.majorVersion < 1 ||\n        (this.majorVersion === 1 && this.minorVersion <= 6)\n      ) {\n        return true;\n      }\n      return false;\n    },\n  },\n});\n\n/**\n * Loads the content, including the root node definition and its children\n * @param {Cesium3DTileset.ConstructorOptions} [cesium3dTilesetOptions] options for Cesium3dTileset constructor\n * @returns {Promise} A promise that is resolved when the layer data is loaded\n * @private\n */\nI3SLayer.prototype.load = async function (cesium3dTilesetOptions) {\n  if (this._data.spatialReference.wkid !== 4326) {\n    throw new RuntimeError(\n      `Unsupported spatial reference: ${this._data.spatialReference.wkid}`\n    );\n  }\n\n  await this._dataProvider.loadGeoidData();\n  await this._loadRootNode(cesium3dTilesetOptions);\n  await this._create3DTileset(cesium3dTilesetOptions);\n\n  this._rootNode._tile = this._tileset._root;\n  this._tileset._root._i3sNode = this._rootNode;\n  if (this.legacyVersion16) {\n    return this._rootNode._loadChildren();\n  }\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._computeGeometryDefinitions = function (useCompression) {\n  // create a table of all geometry buffers based on\n  // the number of attributes and whether they are\n  // compressed or not, sort them by priority\n\n  this._geometryDefinitions = [];\n\n  if (defined(this._data.geometryDefinitions)) {\n    for (\n      let defIndex = 0;\n      defIndex < this._data.geometryDefinitions.length;\n      defIndex++\n    ) {\n      const geometryBuffersInfo = [];\n      const geometryBuffers = this._data.geometryDefinitions[defIndex]\n        .geometryBuffers;\n\n      for (let bufIndex = 0; bufIndex < geometryBuffers.length; bufIndex++) {\n        const geometryBuffer = geometryBuffers[bufIndex];\n        const collectedAttributes = [];\n        let compressed = false;\n\n        if (defined(geometryBuffer.compressedAttributes) && useCompression) {\n          // check if compressed\n          compressed = true;\n          const attributes = geometryBuffer.compressedAttributes.attributes;\n          for (let i = 0; i < attributes.length; i++) {\n            collectedAttributes.push(attributes[i]);\n          }\n        } else {\n          // uncompressed attributes\n          for (const attribute in geometryBuffer) {\n            if (attribute !== \"offset\") {\n              collectedAttributes.push(attribute);\n            }\n          }\n        }\n\n        geometryBuffersInfo.push({\n          compressed: compressed,\n          attributes: collectedAttributes,\n          index: geometryBuffers.indexOf(geometryBuffer),\n        });\n      }\n\n      // rank the buffer info\n      geometryBuffersInfo.sort(function (a, b) {\n        if (a.compressed && !b.compressed) {\n          return -1;\n        } else if (!a.compressed && b.compressed) {\n          return 1;\n        }\n        return a.attributes.length - b.attributes.length;\n      });\n      this._geometryDefinitions.push(geometryBuffersInfo);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._findBestGeometryBuffers = function (\n  definition,\n  attributes\n) {\n  // find the most appropriate geometry definition\n  // based on the required attributes, and by favouring\n  // compression to improve bandwidth requirements\n\n  const geometryDefinition = this._geometryDefinitions[definition];\n\n  if (defined(geometryDefinition)) {\n    for (let index = 0; index < geometryDefinition.length; ++index) {\n      const geometryBufferInfo = geometryDefinition[index];\n      let missed = false;\n      const geometryAttributes = geometryBufferInfo.attributes;\n      for (let attrIndex = 0; attrIndex < attributes.length; attrIndex++) {\n        if (!geometryAttributes.includes(attributes[attrIndex])) {\n          missed = true;\n          break;\n        }\n      }\n      if (!missed) {\n        return {\n          bufferIndex: geometryBufferInfo.index,\n          definition: geometryDefinition,\n          geometryBufferInfo: geometryBufferInfo,\n        };\n      }\n    }\n  }\n\n  return 0;\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._loadRootNode = function (cesium3dTilesetOptions) {\n  if (defined(this._data.nodePages)) {\n    let rootIndex = 0;\n    if (defined(this._data.nodePages.rootIndex)) {\n      rootIndex = this._data.nodePages.rootIndex;\n    }\n    this._rootNode = new I3SNode(this, rootIndex, true);\n  } else {\n    this._rootNode = new I3SNode(this, this._data.store.rootNode, true);\n  }\n\n  return this._rootNode.load(cesium3dTilesetOptions);\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._getNodeInNodePages = function (nodeIndex) {\n  const index = Math.floor(nodeIndex / this._data.nodePages.nodesPerPage);\n  const offsetInPage = nodeIndex % this._data.nodePages.nodesPerPage;\n  return this._loadNodePage(index).then(function (data) {\n    return data.nodes[offsetInPage];\n  });\n};\n\n/**\n * @private\n */\nI3SLayer._fetchJson = function (resource) {\n  return resource.fetchJson();\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._loadNodePage = function (page) {\n  const that = this;\n\n  // If node page was already requested return the same promise\n  if (!defined(this._nodePageFetches[page])) {\n    const nodePageResource = this.resource.getDerivedResource({\n      url: `nodepages/${page}/`,\n    });\n    const fetchPromise = I3SLayer._fetchJson(nodePageResource).then(function (\n      data\n    ) {\n      if (defined(data.error) && data.error.code !== 200) {\n        return Promise.reject(data.error);\n      }\n\n      that._nodePages[page] = data.nodes;\n      return data;\n    });\n\n    this._nodePageFetches[page] = fetchPromise;\n  }\n\n  return this._nodePageFetches[page];\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._computeExtent = function () {\n  if (defined(this._data.fullExtent)) {\n    this._extent = Rectangle.fromDegrees(\n      this._data.fullExtent.xmin,\n      this._data.fullExtent.ymin,\n      this._data.fullExtent.xmax,\n      this._data.fullExtent.ymax\n    );\n  } else if (defined(this._data.store.extent)) {\n    this._extent = Rectangle.fromDegrees(\n      this._data.store.extent[0],\n      this._data.store.extent[1],\n      this._data.store.extent[2],\n      this._data.store.extent[3]\n    );\n  }\n};\n\n/**\n * @private\n */\nI3SLayer.prototype._create3DTileset = async function (cesium3dTilesetOptions) {\n  const inPlaceTileset = {\n    asset: {\n      version: \"1.0\",\n    },\n    geometricError: Number.MAX_VALUE,\n    root: this._rootNode._create3DTileDefinition(),\n  };\n\n  const tilesetBlob = new Blob([JSON.stringify(inPlaceTileset)], {\n    type: \"application/json\",\n  });\n\n  const tilesetUrl = URL.createObjectURL(tilesetBlob);\n  this._tileset = await Cesium3DTileset.fromUrl(\n    tilesetUrl,\n    cesium3dTilesetOptions\n  );\n  this._tileset.show = this._dataProvider.show;\n  this._tileset._isI3STileSet = true;\n  this._tileset.tileUnload.addEventListener(function (tile) {\n    tile._i3sNode._clearGeometryData();\n    URL.revokeObjectURL(tile._contentResource._url);\n    tile._contentResource = tile._i3sNode.resource;\n  });\n\n  this._tileset.tileVisible.addEventListener(function (tile) {\n    if (defined(tile._i3sNode)) {\n      tile._i3sNode._loadChildren();\n    }\n  });\n};\n\nexport default I3SLayer;\n","/*\n * Esri Contribution: This code implements support for I3S (Indexed 3D Scene Layers), an OGC Community Standard.\n * Co-authored-by: Alexandre Jean-Claude ajeanclaude@spiria.com\n * Co-authored-by: Anthony Mirabeau anthony.mirabeau@presagis.com\n * Co-authored-by: Elizabeth Rudkin elizabeth.rudkin@presagis.com\n * Co-authored-by: Tamrat Belayneh tbelayneh@esri.com\n *\n * The I3S format has been developed by Esri and is shared under an Apache 2.0 license and is maintained @ https://github.com/Esri/i3s-spec.\n * This implementation supports loading, displaying, and querying an I3S layer (supported versions include Esri github I3S versions 1.6, 1.7/1.8 -\n * whose OGC equivalent are I3S Community Standard Version 1.1 & 1.2) in the CesiumJS viewer.\n * It enables the user to access an I3S layer via its URL and load it inside of the CesiumJS viewer.\n *\n * When a scene layer is initialized it accomplishes the following:\n *\n * It processes the 3D Scene Layer resource (https://github.com/Esri/i3s-spec/blob/master/docs/1.8/3DSceneLayer.cmn.md) of an I3S dataset\n * and loads the layers data. It does so by creating a Cesium 3D Tileset for the given i3s layer and loads the root node.\n * When the root node is imported, it creates a Cesium 3D Tile that is parented to the Cesium 3D Tileset\n * and loads all children of the root node:\n *  for each children\n *   Create a place holder 3D tile so that the LOD display can use the nodes' selection criteria (maximumScreenSpaceError) to select the appropriate node\n *   based on the current LOD display & evaluation. If the Cesium 3D tile is visible, it invokes requestContent on it.\n *   At that moment, we intercept the call to requestContent, and we load the geometry in I3S format\n *   That geometry is transcoded on the fly to glTF format and ingested by CesiumJS\n *   When the geometry is loaded, we then load all children of this node as placeholders so that the LOD\n *   can know about them too.\n *\n * About transcoding:\n *\n * We use web workers to transcode I3S geometries into glTF\n * The steps are:\n *\n * Decode geometry attributes (positions, normals, etc..) either from DRACO or Binary format.\n * If requested, when creating an I3SDataProvider the user has the option to specify a tiled elevation terrain provider\n * (geoidTiledTerrainProvider) such as the one shown in the sandcastle example based on ArcGISTiledElevationTerrainProvider, that allows\n * conversion of heights for all vertices & bounding boxes of an I3S layer from (typically) gravity related (Orthometric) heights to Ellipsoidal.\n * This step is essential when fusing data with varying height sources (as is the case when fusing the I3S dataset (gravity related) in the sandcastle examples with the cesium world terrain (ellipsoidal)).\n * We then transform vertex coordinates from LONG/LAT/HEIGHT to Cartesian in local space and\n * scale appropriately if specified in the attribute metadata\n * Crop UVs if UV regions are defined in the attribute metadata\n * Create a glTF document in memory that will be ingested as part of a glb payload\n *\n * About GEOID data:\n *\n * We provide the ability to use GEOID data to convert heights from gravity related (orthometric) height systems to ellipsoidal.\n * We employ a service architecture to get the conversion factor for a given long lat values, leveraging existing implementation based on ArcGISTiledElevationTerrainProvider\n * to avoid requiring bloated look up files. The source Data used in this transcoding service was compiled from https://earth-info.nga.mil/#tab_wgs84-data and is based on\n * EGM2008 Gravity Model. The sandcastle examples show how to set the terrain provider service if required.\n */\nimport Cartesian2 from \"../Core/Cartesian2.js\";\nimport Cartographic from \"../Core/Cartographic.js\";\nimport Check from \"../Core/Check.js\";\nimport defaultValue from \"../Core/defaultValue.js\";\nimport defined from \"../Core/defined.js\";\nimport destroyObject from \"../Core/destroyObject.js\";\nimport HeightmapEncoding from \"../Core/HeightmapEncoding.js\";\nimport Resource from \"../Core/Resource.js\";\nimport RuntimeError from \"../Core/RuntimeError.js\";\nimport WebMercatorProjection from \"../Core/WebMercatorProjection.js\";\nimport I3SLayer from \"./I3SLayer.js\";\nimport Lerc from \"lerc\";\nimport Rectangle from \"../Core/Rectangle.js\";\n\n/**\n * @typedef {Object} I3SDataProvider.ConstructorOptions\n *\n * Initialization options for the I3SDataProvider constructor\n *\n * @property {string} [name] The name of the I3S dataset.\n * @property {boolean} [show=true] Determines if the dataset will be shown.\n * @property {ArcGISTiledElevationTerrainProvider|Promise<ArcGISTiledElevationTerrainProvider>} [geoidTiledTerrainProvider] Tiled elevation provider describing an Earth Gravitational Model. If defined, geometry will be shifted based on the offsets given by this provider. Required to position I3S data sets with gravity-related height at the correct location.\n * @property {boolean} [traceFetches=false] Debug option. When true, log a message whenever an I3S tile is fetched.\n * @property {Cesium3DTileset.ConstructorOptions} [cesium3dTilesetOptions] Object containing options to pass to an internally created {@link Cesium3DTileset}. See {@link Cesium3DTileset} for list of valid properties. All options can be used with the exception of <code>url</code> and <code>show</code> which are overridden by values from I3SDataProvider.\n */\n\n/**\n * An I3SDataProvider is the main public class for I3S support. The url option\n * should return a scene object. Currently supported I3S versions are 1.6 and\n * 1.7/1.8 (OGC I3S 1.2). I3SFeature and I3SNode classes implement the\n * Object Model for I3S entities, with public interfaces.\n *\n * <div class=\"notice\">\n * This object is normally not instantiated directly, use {@link I3SDataProvider.fromUrl}.\n * </div>\n *\n * @alias I3SDataProvider\n * @constructor\n *\n * @param {I3SDataProvider.ConstructorOptions} options An object describing initialization options\n *\n * @see I3SDataProvider.fromUrl\n * @see ArcGISTiledElevationTerrainProvider\n *\n * @example\n * try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n * @example\n * try {\n *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\"\n *   );\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\", {\n *       geoidTiledTerrainProvider: geoidService\n *   });\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n */\nfunction I3SDataProvider(options) {\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  // All public configuration is defined as ES5 properties\n  // These are just the \"private\" variables and their defaults.\n  this._name = options.name;\n  this._show = defaultValue(options.show, true);\n  this._geoidTiledTerrainProvider = options.geoidTiledTerrainProvider;\n  this._traceFetches = defaultValue(options.traceFetches, false);\n\n  this._cesium3dTilesetOptions = defaultValue(\n    options.cesium3dTilesetOptions,\n    defaultValue.EMPTY_OBJECT\n  );\n\n  this._layers = [];\n  this._data = undefined;\n  this._extent = undefined;\n  this._geoidDataPromise = undefined;\n  this._geoidDataList = undefined;\n  this._decoderTaskProcessor = undefined;\n  this._taskProcessorReadyPromise = undefined;\n}\n\nObject.defineProperties(I3SDataProvider.prototype, {\n  /**\n   * Gets a human-readable name for this dataset.\n   * @memberof I3SDataProvider.prototype\n   * @type {string}\n   * @readonly\n   */\n  name: {\n    get: function () {\n      return this._name;\n    },\n  },\n\n  /**\n   * Determines if the dataset will be shown.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   */\n  show: {\n    get: function () {\n      return this._show;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n\n      this._show = value;\n      for (let i = 0; i < this._layers.length; i++) {\n        if (defined(this._layers[i]._tileset)) {\n          this._layers[i]._tileset.show = this._show;\n        }\n      }\n    },\n  },\n\n  /**\n   * Gets or sets debugging and tracing of I3S fetches.\n   * @memberof I3SDataProvider.prototype\n   * @type {boolean}\n   */\n  traceFetches: {\n    get: function () {\n      return this._traceFetches;\n    },\n    set: function (value) {\n      //>>includeStart('debug', pragmas.debug);\n      Check.defined(\"value\", value);\n      //>>includeEnd('debug');\n\n      this._traceFetches = value;\n    },\n  },\n\n  /**\n   * The terrain provider referencing the GEOID service to be used for orthometric to ellipsoidal conversion.\n   * @memberof I3SDataProvider.prototype\n   * @type {ArcGISTiledElevationTerrainProvider}\n   * @readonly\n   */\n  geoidTiledTerrainProvider: {\n    get: function () {\n      return this._geoidTiledTerrainProvider;\n    },\n  },\n\n  /**\n   * Gets the collection of layers.\n   * @memberof I3SDataProvider.prototype\n   * @type {I3SLayer[]}\n   * @readonly\n   */\n  layers: {\n    get: function () {\n      return this._layers;\n    },\n  },\n\n  /**\n   * Gets the I3S data for this object.\n   * @memberof I3SDataProvider.prototype\n   * @type {object}\n   * @readonly\n   */\n  data: {\n    get: function () {\n      return this._data;\n    },\n  },\n\n  /**\n   * Gets the extent covered by this I3S.\n   * @memberof I3SDataProvider.prototype\n   * @type {Rectangle}\n   * @readonly\n   */\n  extent: {\n    get: function () {\n      return this._extent;\n    },\n  },\n\n  /**\n   * The resource used to fetch the I3S dataset.\n   * @memberof I3SDataProvider.prototype\n   * @type {Resource}\n   * @readonly\n   */\n  resource: {\n    get: function () {\n      return this._resource;\n    },\n  },\n});\n\n/**\n * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic\n * release of WebGL resources, instead of relying on the garbage collector to destroy this object.\n * <p>\n * Once an object is destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,\n * assign the return value (<code>undefined</code>) to the object as done in the example.\n * </p>\n *\n * @exception {DeveloperError} This object was destroyed, i.e., destroy() was called.\n *\n * @see I3SDataProvider#isDestroyed\n */\nI3SDataProvider.prototype.destroy = function () {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.destroy();\n    }\n  }\n\n  return destroyObject(this);\n};\n\n/**\n * Returns true if this object was destroyed; otherwise, false.\n * <p>\n * If this object was destroyed, it should not be used; calling any function other than\n * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.\n * </p>\n *\n * @returns {boolean} <code>true</code> if this object was destroyed; otherwise, <code>false</code>.\n *\n * @see I3SDataProvider#destroy\n */\nI3SDataProvider.prototype.isDestroyed = function () {\n  return false;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.update = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.update(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.prePassesUpdate = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.prePassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.postPassesUpdate = function (frameState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.postPassesUpdate(frameState);\n    }\n  }\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype.updateForPass = function (frameState, passState) {\n  for (let i = 0; i < this._layers.length; i++) {\n    if (defined(this._layers[i]._tileset)) {\n      this._layers[i]._tileset.updateForPass(frameState, passState);\n    }\n  }\n};\n\n/**\n * Creates an I3SDataProvider. Currently supported I3S versions are 1.6 and\n * 1.7/1.8 (OGC I3S 1.2).\n *\n * @param {string|Resource} url The url of the I3S dataset, which should return an I3S scene object\n * @param {I3SDataProvider.ConstructorOptions} options An object describing initialization options\n * @returns {Promise<I3SDataProvider>}\n *\n * @example\n * try {\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\"\n *   );\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n *\n * @example\n * try {\n *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer\"\n *   );\n *   const i3sData = await I3SDataProvider.fromUrl(\n *     \"https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0\", {\n *       geoidTiledTerrainProvider: geoidService\n *   });\n *   viewer.scene.primitives.add(i3sData);\n * } catch (error) {\n *   console.log(`There was an error creating the I3S Data Provider: ${error}`);\n * }\n */\nI3SDataProvider.fromUrl = async function (url, options) {\n  //>>includeStart('debug', pragmas.debug);\n  Check.defined(\"url\", url);\n  //>>includeEnd('debug');\n\n  options = defaultValue(options, defaultValue.EMPTY_OBJECT);\n\n  const resource = Resource.createIfNeeded(url);\n  const data = await I3SDataProvider.loadJson(resource);\n\n  const provider = new I3SDataProvider(options);\n  provider._resource = resource;\n  provider._data = data;\n\n  // Success\n  if (defined(data.layers)) {\n    for (let layerIndex = 0; layerIndex < data.layers.length; layerIndex++) {\n      const newLayer = new I3SLayer(\n        provider,\n        data.layers[layerIndex],\n        layerIndex\n      );\n      provider._layers.push(newLayer);\n    }\n  } else {\n    const newLayer = new I3SLayer(provider, data, data.id);\n    provider._layers.push(newLayer);\n  }\n\n  provider._computeExtent();\n\n  // Start loading all of the tiles\n  const layerPromises = [];\n  for (let i = 0; i < provider._layers.length; i++) {\n    layerPromises.push(\n      provider._layers[i].load(options.cesium3dTilesetOptions)\n    );\n  }\n\n  await Promise.all(layerPromises);\n  return provider;\n};\n\n/**\n * @private\n */\nI3SDataProvider._fetchJson = function (resource) {\n  return resource.fetchJson();\n};\n\n/**\n * @private\n *\n * @param {Resource} resource The JSON resource to request\n * @param {boolean} [trace=false] Log the resource\n * @returns {Promise<object>} The fetched data\n */\nI3SDataProvider.loadJson = async function (resource, trace) {\n  if (trace) {\n    console.log(\"I3S FETCH:\", resource.url);\n  }\n\n  const data = await I3SDataProvider._fetchJson(resource);\n  if (defined(data.error)) {\n    console.error(\"Failed to fetch I3S \", resource.url);\n    if (defined(data.error.message)) {\n      console.error(data.error.message);\n    }\n    if (defined(data.error.details)) {\n      for (let i = 0; i < data.error.details.length; i++) {\n        console.log(data.error.details[i]);\n      }\n    }\n\n    throw new RuntimeError(data.error);\n  }\n\n  return data;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._loadBinary = function (resource) {\n  if (this._traceFetches) {\n    console.log(\"I3S FETCH:\", resource.url);\n  }\n  return resource.fetchArrayBuffer();\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._binarizeGltf = function (rawGltf) {\n  const encoder = new TextEncoder();\n  const rawGltfData = encoder.encode(JSON.stringify(rawGltf));\n  const binaryGltfData = new Uint8Array(rawGltfData.byteLength + 20);\n  const binaryGltf = {\n    magic: new Uint8Array(binaryGltfData.buffer, 0, 4),\n    version: new Uint32Array(binaryGltfData.buffer, 4, 1),\n    length: new Uint32Array(binaryGltfData.buffer, 8, 1),\n    chunkLength: new Uint32Array(binaryGltfData.buffer, 12, 1),\n    chunkType: new Uint32Array(binaryGltfData.buffer, 16, 1),\n    chunkData: new Uint8Array(\n      binaryGltfData.buffer,\n      20,\n      rawGltfData.byteLength\n    ),\n  };\n\n  binaryGltf.magic[0] = \"g\".charCodeAt();\n  binaryGltf.magic[1] = \"l\".charCodeAt();\n  binaryGltf.magic[2] = \"T\".charCodeAt();\n  binaryGltf.magic[3] = \"F\".charCodeAt();\n\n  binaryGltf.version[0] = 2;\n  binaryGltf.length[0] = binaryGltfData.byteLength;\n  binaryGltf.chunkLength[0] = rawGltfData.byteLength;\n  binaryGltf.chunkType[0] = 0x4e4f534a; // JSON\n  binaryGltf.chunkData.set(rawGltfData);\n\n  return binaryGltfData;\n};\n\nconst scratchCartesian2 = new Cartesian2();\n\nfunction getCoveredTiles(terrainProvider, extent) {\n  const tilingScheme = terrainProvider.tilingScheme;\n\n  // Sort points into a set of tiles\n  const tileRequests = []; // Result will be an Array as it's easier to work with\n  const tileRequestSet = {}; // A unique set\n\n  const maxLevel = terrainProvider._lodCount;\n\n  const topLeftCorner = Cartographic.fromRadians(extent.west, extent.north);\n  const bottomRightCorner = Cartographic.fromRadians(extent.east, extent.south);\n  const minCornerXY = tilingScheme.positionToTileXY(topLeftCorner, maxLevel);\n  const maxCornerXY = tilingScheme.positionToTileXY(\n    bottomRightCorner,\n    maxLevel\n  );\n\n  // Get all the tiles in between\n  for (let x = minCornerXY.x; x <= maxCornerXY.x; x++) {\n    for (let y = minCornerXY.y; y <= maxCornerXY.y; y++) {\n      const xy = Cartesian2.fromElements(x, y, scratchCartesian2);\n      const key = xy.toString();\n      if (!tileRequestSet.hasOwnProperty(key)) {\n        // When tile is requested for the first time\n        const value = {\n          x: xy.x,\n          y: xy.y,\n          level: maxLevel,\n          tilingScheme: tilingScheme,\n          terrainProvider: terrainProvider,\n          positions: [],\n        };\n        tileRequestSet[key] = value;\n        tileRequests.push(value);\n      }\n    }\n  }\n\n  // Send request for each required tile\n  const tilePromises = [];\n  for (let i = 0; i < tileRequests.length; ++i) {\n    const tileRequest = tileRequests[i];\n    const requestPromise = tileRequest.terrainProvider.requestTileGeometry(\n      tileRequest.x,\n      tileRequest.y,\n      tileRequest.level\n    );\n\n    tilePromises.push(requestPromise);\n  }\n\n  return Promise.all(tilePromises).then(function (heightMapBuffers) {\n    const heightMaps = [];\n    for (let i = 0; i < heightMapBuffers.length; i++) {\n      const options = {\n        tilingScheme: tilingScheme,\n        x: tileRequests[i].x,\n        y: tileRequests[i].y,\n        level: tileRequests[i].level,\n      };\n      const heightMap = heightMapBuffers[i];\n\n      let projectionType = \"Geographic\";\n      if (tilingScheme._projection instanceof WebMercatorProjection) {\n        projectionType = \"WebMercator\";\n      }\n\n      const heightMapData = {\n        projectionType: projectionType,\n        projection: tilingScheme._projection,\n        nativeExtent: tilingScheme.tileXYToNativeRectangle(\n          options.x,\n          options.y,\n          options.level\n        ),\n        height: heightMap._height,\n        width: heightMap._width,\n        scale: heightMap._structure.heightScale,\n        offset: heightMap._structure.heightOffset,\n      };\n\n      if (heightMap._encoding === HeightmapEncoding.LERC) {\n        const result = Lerc.decode(heightMap._buffer);\n        heightMapData.buffer = result.pixels[0];\n      } else {\n        heightMapData.buffer = heightMap._buffer;\n      }\n\n      heightMaps.push(heightMapData);\n    }\n\n    return heightMaps;\n  });\n}\n\nasync function loadGeoidData(provider) {\n  // Load tiles from arcgis\n  const geoidTerrainProvider = provider._geoidTiledTerrainProvider;\n\n  if (!defined(geoidTerrainProvider)) {\n    console.log(\n      \"No Geoid Terrain service provided - no geoid conversion will be performed.\"\n    );\n    return;\n  }\n\n  try {\n    const heightMaps = await getCoveredTiles(\n      geoidTerrainProvider,\n      provider._extent\n    );\n    provider._geoidDataList = heightMaps;\n  } catch (error) {\n    console.log(\n      \"Error retrieving Geoid Terrain tiles - no geoid conversion will be performed.\"\n    );\n  }\n}\n\n/**\n * @private\n */\nI3SDataProvider.prototype.loadGeoidData = async function () {\n  if (defined(this._geoidDataPromise)) {\n    return this._geoidDataPromise;\n  }\n\n  this._geoidDataPromise = loadGeoidData(this);\n  return this._geoidDataPromise;\n};\n\n/**\n * @private\n */\nI3SDataProvider.prototype._computeExtent = function () {\n  let rectangle;\n\n  // Compute the extent from all layers\n  for (let layerIndex = 0; layerIndex < this._layers.length; layerIndex++) {\n    if (defined(this._layers[layerIndex]._extent)) {\n      const layerExtent = this._layers[layerIndex]._extent;\n      if (!defined(rectangle)) {\n        rectangle = Rectangle.clone(layerExtent);\n      } else {\n        Rectangle.union(rectangle, layerExtent, rectangle);\n      }\n    }\n  }\n\n  this._extent = rectangle;\n};\n\nexport default I3SDataProvider;\n","import { render } from \"./i3s_object.vue?vue&type=template&id=3bb9a916&scoped=true\"\nimport script from \"./i3s_object.vue?vue&type=script&lang=js\"\nexport * from \"./i3s_object.vue?vue&type=script&lang=js\"\n\nimport \"./i3s_object.vue?vue&type=style&index=0&id=3bb9a916&lang=scss&scoped=true\"\n\nimport exportComponent from \"/Users/zhengjie/Documents/webgis/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-3bb9a916\"]])\n\nexport default __exports__"],"names":["LercDecode","CntZImage","input","options","skipMask","encodedMaskData","parsedData","parse","inputOffset","noDataValue","defaultNoDataValue","uncompressedData","uncompressPixelValues","pixelType","Float32Array","returnMask","result","width","height","pixelData","resultPixels","minValue","maxValue","pixels","resultMask","maskData","returnEncodedMask","mask","bitset","returnFileInfo","fileInfo","formatFileInfo","computeUsedBitDepths","bitDepths","data","TypedArrayClass","maskBitset","storeDecodedMask","currentValue","blockIdx","numX","numBlocksX","numY","numBlocksY","blockWidth","Math","floor","blockHeight","scale","maxZError","Number","MAX_VALUE","Uint8Array","xx","yy","blockDataBuffer","y","thisBlockHeight","x","thisBlockWidth","blockData","blockPtr","constValue","maskByte","outPtr","outStride","block","blocks","encoding","rawData","unstuff","stuffedData","bitsPerPixel","numValidPixels","offset","fileIdentifierString","fileVersion","imageType","eofOffset","numBytes","numBlocks","i","float32","Object","keys","fp","fileIdView","String","fromCharCode","apply","trim","view","DataView","getInt32","getUint32","getFloat64","getFloat32","ceil","cnt","getInt16","ip","op","getUint8","val","length","actualNumBlocksX","actualNumBlocksY","Array","blockI","blockY","blockX","size","bytesLeft","byteLength","min","headerByte","offsetType","getInt8","numValidPixelsType","getUint16","arrayBuf","store8","numPixels","ArrayBuffer","set","dataBytes","dataWords","Uint32Array","src","dest","o","n","buffer","bitMask","bitsLeft","nmax","numInvalidTailBytes","missingBits","Lerc2Decode","BitStuffer","lutArr","unstuffLUT","unshift","unstuff2","bitPos","unstuffLUT2","originalUnstuff","originalUnstuff2","Lerc2Helpers","HUFFMAN_LUT_BITS_MAX","computeChecksumFletcher32","sum1","sum2","len","words","tlen","readHeaderInfo","ptr","headerInfo","lastIndexOf","checksum","keyLength","numDims","numValidPixel","microBlockSize","blobSize","zMin","zMax","this","checkMinMaxRanges","OutPixelTypeArray","getDataTypeArray","rangeBytes","getDataTypeSize","minValues","readSubArray","maxValues","equal","readMask","mb","k","readDataOneSweep","z","nStart","readHuffmanTree","BITS_MAX","version","i0","i1","decodeBits","j","codeTable","first","second","word","srcPtr","numBitsLUT","numBitsLUTQick","tree","TreeNode","undefined","max","console","log","entry","code","numEntries","jj","currentBit","node","decodeLut","right","left","readHuffman","delta","valTmp","valTmpQuick","ii","huffmanInfo","prevVal","iDim","deltaEncode","encodeMode","resultPixelsAllDim","bits67","doLut","numBits","numElements","lutData","lutBytes","counter","lut","bitstuffer","readTiles","dataTypeSize","blockEncoding","row","col","testCode","bytesleft","lastBlockHeight","lastBlockWidth","uncompressed","getDataTypeUsed","getOnePixel","constantoffset","constant","getPixelType","constructConstantSurface","numPixelAllDims","fill","t","tp","Int8Array","Int16Array","Uint16Array","Int32Array","Float64Array","isValidPixelValue","isValid","s","dt","tc","temp","getUInt32","decode","diff","onesweep","bReadDataOneSweep","abs","flagHuffman","validPixelCount","dimCount","dimStats","getBandCount","count","isPlatformLittleEndian","a","b","c","Lerc","encodedData","lerc","majorVersion","substring","bandMask","iPlane","eof","bandMasks","decodedPixelBlock","statistics","push","define","array","transform","identity","x0","y0","kx","ky","dx","translate","dy","output","topology","objects","type","features","geometries","map","feature","id","bbox","properties","geometry","object","transformPoint","arcs","arc","points","pop","reverse","point","p","line","ring","polygon","coordinates","_createElementBlock","_hoisted_1","ALL_CHILDREN","TerrainProviderBuilder","ellipsoid","defaultValue","Ellipsoid","credit","tilingScheme","lodCount","hasAvailability","tilesAvailable","tilesAvailabilityLoaded","levelZeroMaximumGeometricError","terrainDataStructure","parseMetadataSuccess","terrainProviderBuilder","metadata","copyrightText","defined","Credit","spatialReference","wkid","latestWkid","extent","tilingSchemeOptions","rectangle","Rectangle","xmin","ymin","xmax","ymax","GeographicTilingScheme","RuntimeError","epsg3857Bounds","PI","maximumRadius","rectangleSouthwestInMeters","Cartesian2","rectangleNortheastInMeters","WebMercatorTilingScheme","tileInfo","rows","cols","format","HeightmapEncoding","lods","capabilities","indexOf","TileAvailability","addAvailableTileRange","getNumberOfXTilesAtLevel","getNumberOfYTilesAtLevel","TerrainProvider","bandCount","elementMultiplier","lowestEncodedHeight","highestEncodedHeight","async","requestMetadata","metadataResource","provider","fetchJson","error","message","TileProviderError","_errorEvent","ArcGISTiledElevationTerrainProvider","_resource","_credit","_tilingScheme","_levelZeroMaximumGeometricError","_maxLevel","_terrainDataStructure","_width","_height","_encoding","_lodCount","_hasAvailability","_tilesAvailable","_tilesAvailabilityLoaded","_availableCache","Event","isTileAvailable","that","level","findRange","origin","endCol","endRow","value","endingIndices","range","startX","startY","endX","endY","corner","doneX","doneY","computeAvailability","ranges","singleValue","every","positions","concat","requestAvailability","xOffset","yOffset","dim","url","availableCache","request","Request","throttle","throttleByServer","RequestType","tilemapResource","getDerivedResource","promise","then","available","finally","prototype","build","defineProperties","errorEvent","get","hasWaterMask","hasVertexNormals","availability","fromUrl","Check","Promise","resolve","resource","Resource","appendForwardSlash","token","queryParameters","f","requestTileGeometry","tileResource","availabilityRequest","availabilityPromise","availabilityResult","fetchArrayBuffer","all","HeightmapTerrainData","childTileMask","computeChildMaskForTile","structure","catch","state","RequestState","cancel","deferred","reject","getLevelMaximumGeometricError","getTileDataAvailable","loadTileDataAvailability","I3SDecoder","initializeDecoder","_decodeTaskProcessor","initWebAssemblyModule","wasmBinaryFile","_maxDecodingConcurrency","FeatureDetection","TaskProcessor","_promise","defaultGeometrySchema","geometryData","featureData","taskProcessor","parentData","_parent","_data","parentRotationInverseMatrix","_inverseRotationMatrix","longitude","latitude","obb","center","mbs","axisFlipRotation","Matrix3","CesiumMath","parentRotation","cartographicCenter","Cartographic","cartesianCenter","payload","binaryData","schema","bufferInfo","_geometryBufferInfo","ellipsoidRadiiSquare","geoidDataList","_dataProvider","_geoidDataList","scheduleTask","I3SFeature","parent","uri","_layer","_nodeIndex","mesh","attribute","load","I3SDataProvider","_traceFetches","I3SField","storageInfo","_storageInfo","key","getNumericTypeSize","header","_header","values","_values","attributeValues","name","_loadBinary","dataView","success","charCodeAt","textContent","TextDecoder","str","includes","_parseHeader","valueSize","valueType","_parseBody","_parseValue","pow","itemIndex","item","parsedValue","property","ordering","desc","index","stringLen","attributeByteCounts","stringContent","cIndex","curParsedValue","I3SGeometry","dataProvider","layer","_customAttributes","customAttributes","scratchAb","Cartesian3","scratchAp1","scratchAp2","scratchCp1","scratchCp2","sameSide","p1","p2","ab","cp1","cp2","scratchV0","scratchV1","scratchV2","scratchV0V1","scratchV0V2","scratchCrossProd","scratchNormal","scratchV0p","scratchV1p","scratchV2p","getClosestPointIndexOnTriangle","px","py","pz","position","bestTri","bestDistSq","bestIndex","bestPt","bestTriDist","indices","triCount","triIndex","i2","v0","v1","v2","v0v1","v0v2","crossProd","normal","v0p","normalDist","d0","d1","d2","distanceSquared","distance","sqrt","queriedPosition","closestPosition","Infinity","_generateGltf","nodesInScene","nodes","meshes","buffers","bufferViews","accessors","materialDefinition","gltfMaterial","pbrMetallicRoughness","metallicFactor","doubleSided","isTextured","texturePath","materialDefinitions","materialInfo","material","materialIndex","definition","baseColorTexture","textureName","textureSetDefinitions","defIndex","textureSetDefinition","formatIndex","formats","textureFormat","textureData","href","gltfTextures","gltfImages","gltfSamplers","sampler","source","magFilter","minFilter","wrapS","wrapT","gltfData","scene","scenes","materials","textures","images","samplers","asset","I3SNode","ref","isRoot","nodeIndex","_level","_isRoot","_isLoading","_tile","_geometryData","_featureData","_fields","_children","_childrenReadyPromise","_globalTransform","_inverseGlobalTransform","bilinearInterpolate","tx","ty","h00","h10","h01","h11","sampleMap","u","v","address","sampleGeoid","sampleX","sampleY","geoidData","nativeExtent","west","east","south","north","xi","yi","xNext","yNext","finalHeight","children","fields","tile","processData","tileDefinition","_create3DTileDefinition","Cesium3DTile","_tileset","_i3sNode","_getNodeInNodePages","uriIndex","loadFields","attributeStorageInfo","createAndLoadField","newField","promises","getFieldsForPickedPosition","pickedPosition","featureIndex","location","getFieldsForFeature","featureFields","fieldName","hasOwnProperty","field","_loadChildren","childPromises","childIndex","child","newChild","_loadGeometryData","geometryPromises","geomIndex","curGeometryData","geometryDefinition","_findBestGeometryBuffers","geometryURI","bufferIndex","newGeometryData","_geometryDefinitions","geometryBufferInfo","_loadFeatureData","featurePromises","newFeatureData","_clearGeometryData","geoPosition","projectedPos","projection","project","boundingVolume","span","box","halfSize","sphere","metersPerPixel","lodThreshold","nodePages","lodSelectionMetricType","maxScreenThreshold","lodSelection","lodIndex","metricType","maxError","geometricError","hpr","HeadingPitchRoll","orientation","Transforms","Quaternion","quaternion","rotationMatrix","inverseRotationMatrix","globalTransform","Matrix4","inverseGlobalTransform","localTransform","childrenDefinition","inPlaceTileDefinition","refine","content","_createContentURL","rawGltf","dataPromises","legacyVersion16","geometrySchema","store","meshData","binaryGltfData","_binarizeGltf","glbDataBlob","Blob","URL","createObjectURL","tileset","_isI3STileSet","_contentResource","_hookedRequestContent","i3sNode","I3SLayer","layerData","dataProviderUrl","getUrlComponent","tilesetUrl","match","replace","_version","splitVersion","split","_majorVersion","parseInt","_minorVersion","setQueryParameters","_rootNode","_nodePages","_nodePageFetches","_extent","_computeGeometryDefinitions","_computeExtent","rootNode","minorVersion","cesium3dTilesetOptions","loadGeoidData","_loadRootNode","_create3DTileset","_root","useCompression","geometryDefinitions","geometryBuffersInfo","geometryBuffers","bufIndex","geometryBuffer","collectedAttributes","compressed","compressedAttributes","attributes","sort","missed","geometryAttributes","attrIndex","rootIndex","nodesPerPage","offsetInPage","_loadNodePage","_fetchJson","page","nodePageResource","fetchPromise","fullExtent","inPlaceTileset","root","tilesetBlob","JSON","stringify","Cesium3DTileset","show","tileUnload","addEventListener","revokeObjectURL","_url","tileVisible","_name","_show","_geoidTiledTerrainProvider","geoidTiledTerrainProvider","traceFetches","_cesium3dTilesetOptions","_layers","_geoidDataPromise","_decoderTaskProcessor","_taskProcessorReadyPromise","layers","destroy","destroyObject","isDestroyed","update","frameState","prePassesUpdate","postPassesUpdate","updateForPass","passState","loadJson","layerIndex","newLayer","layerPromises","trace","details","encoder","TextEncoder","rawGltfData","encode","binaryGltf","magic","chunkLength","chunkType","chunkData","scratchCartesian2","getCoveredTiles","terrainProvider","tileRequests","tileRequestSet","maxLevel","topLeftCorner","bottomRightCorner","minCornerXY","positionToTileXY","maxCornerXY","xy","toString","tilePromises","tileRequest","requestPromise","heightMapBuffers","heightMaps","heightMap","projectionType","_projection","WebMercatorProjection","heightMapData","tileXYToNativeRectangle","_structure","heightScale","heightOffset","_buffer","geoidTerrainProvider","layerExtent","mounted","init","methods","viewer","Cesium","animation","timeline","resolutionScale","window","devicePixelRatio","postProcessStages","fxaa","enabled","debugShowFramesPerSecond","geoidService","i3sOptions","i3sProvider","primitives","add","camera","setView","destination","__exports__","render"],"sourceRoot":""}