{"version":3,"file":"js/9637.f225bb0b.js","mappings":"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","sources":["webpack://webgis/./src/components/three/reflector_example.vue","webpack://webgis/./src/components/three/reflector_example.vue?7855","webpack://webgis/./node_modules/three/examples/jsm/objects/Reflector.js"],"sourcesContent":["<template>\r\n  <div class=\"container\"><canvas id=\"c\"></canvas></div>\r\n</template>\r\n<script>\r\nimport * as THREE from 'three'\r\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\r\nimport { Reflector } from 'three/examples/jsm/objects/Reflector'\r\n\r\nlet camera, scene, renderer;\r\nlet cameraControls;\r\nlet smallSphere;\r\nlet groundMirror\r\nexport default {\r\n  mounted() {\r\n    this.init()\r\n    this.animate()\r\n  },\r\n  methods: {\r\n    init() {\r\n      const canvas = document.querySelector('#c')\r\n      // renderer\r\n      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });\r\n      renderer.setSize(canvas.innerWidth, canvas.innerHeight)\r\n      renderer.setPixelRatio(window.devicePixelRatio)\r\n      renderer.useLegacyLights = false;\r\n\r\n      // scene\r\n      scene = new THREE.Scene();\r\n\r\n      // camera\r\n      camera = new THREE.PerspectiveCamera(45, canvas.clientWidth / canvas.clientHeight, 1, 500);\r\n      camera.position.set(0, 75, 100);\r\n\r\n      cameraControls = new OrbitControls(camera, renderer.domElement);\r\n      cameraControls.update();\r\n      //\r\n      let geometry, material;\r\n\r\n      geometry = new THREE.CircleGeometry(40, 40);\r\n      groundMirror = new Reflector(geometry, {\r\n        clipBias: 0.003,\r\n        textureWidth: window.innerWidth * window.devicePixelRatio,\r\n        textureHeight: window.innerHeight * window.devicePixelRatio,\r\n      });\r\n      groundMirror.position.y = 0.5;\r\n      groundMirror.rotateX(- Math.PI / 2);\r\n      scene.add(groundMirror);\r\n\r\n      geometry = new THREE.IcosahedronGeometry(5, 0);\r\n      material = new THREE.MeshPhongMaterial({ color: 0xffffff, emissive: 0x7b7b7b, flatShading: true });\r\n      smallSphere = new THREE.Mesh(geometry, material);\r\n      scene.add(smallSphere);\r\n\r\n      // lights\r\n      const mainLight = new THREE.PointLight(0xe7e7e7, 2.5, 250, 0);\r\n      mainLight.position.y = 60;\r\n      scene.add(mainLight);\r\n\r\n      const gridHelper = new THREE.GridHelper(100, 100);\r\n      scene.add(gridHelper);\r\n    },\r\n    resizeRendererToDisplaySize(renderer) {\r\n      const canvas = renderer.domElement\r\n      const width = canvas.clientWidth\r\n      const height = canvas.clientHeight\r\n      const needResize = canvas.width !== width || canvas.height !== height\r\n      if (needResize) {\r\n        renderer.setSize(width, height, false)\r\n        groundMirror.getRenderTarget().setSize(\r\n          width * window.devicePixelRatio,\r\n          height * window.devicePixelRatio\r\n        );\r\n      }\r\n      return needResize\r\n    },\r\n    animate() {\r\n      requestAnimationFrame(this.animate);\r\n      if (this.resizeRendererToDisplaySize(renderer)) {\r\n        const canvas = renderer.domElement\r\n        camera.aspect = canvas.clientWidth / canvas.clientHeight\r\n        camera.updateProjectionMatrix()\r\n      }\r\n\r\n      const timer = Date.now() * 0.01;\r\n      smallSphere.position.set(\r\n        Math.cos(timer * 0.1) * 30,\r\n        Math.abs(Math.cos(timer * 0.2)) * 20 + 5,\r\n        Math.sin(timer * 0.1) * 30\r\n      );\r\n      smallSphere.rotation.y = (Math.PI / 2) - timer * 0.1;\r\n      smallSphere.rotation.z = timer * 0.8;\r\n\r\n      cameraControls.update();\r\n      renderer.render(scene, camera);\r\n    }\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.container {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n\r\n#c {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  margin: 0%;\r\n}\r\n</style>\r\n","import { render } from \"./reflector_example.vue?vue&type=template&id=65cafdd6&scoped=true\"\nimport script from \"./reflector_example.vue?vue&type=script&lang=js\"\nexport * from \"./reflector_example.vue?vue&type=script&lang=js\"\n\nimport \"./reflector_example.vue?vue&type=style&index=0&id=65cafdd6&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-65cafdd6\"]])\n\nexport default __exports__","import {\n\tColor,\n\tMatrix4,\n\tMesh,\n\tPerspectiveCamera,\n\tPlane,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector3,\n\tVector4,\n\tWebGLRenderTarget\n} from 'three';\n\nclass Reflector extends Mesh {\n\n\tconstructor( geometry, options = {} ) {\n\n\t\tsuper( geometry );\n\n\t\tthis.type = 'Reflector';\n\n\t\tconst scope = this;\n\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\n\t\tconst textureWidth = options.textureWidth || 512;\n\t\tconst textureHeight = options.textureHeight || 512;\n\t\tconst clipBias = options.clipBias || 0;\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\n\n\t\t//\n\n\t\tconst reflectorPlane = new Plane();\n\t\tconst normal = new Vector3();\n\t\tconst reflectorWorldPosition = new Vector3();\n\t\tconst cameraWorldPosition = new Vector3();\n\t\tconst rotationMatrix = new Matrix4();\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\n\t\tconst clipPlane = new Vector4();\n\n\t\tconst view = new Vector3();\n\t\tconst target = new Vector3();\n\t\tconst q = new Vector4();\n\n\t\tconst textureMatrix = new Matrix4();\n\t\tconst virtualCamera = new PerspectiveCamera();\n\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight );\n\n\t\tconst material = new ShaderMaterial( {\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\n\t\t\tfragmentShader: shader.fragmentShader,\n\t\t\tvertexShader: shader.vertexShader\n\t\t} );\n\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\n\t\tmaterial.uniforms[ 'color' ].value = color;\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\n\n\t\tthis.material = material;\n\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\n\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\n\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\n\n\t\t\tnormal.set( 0, 0, 1 );\n\t\t\tnormal.applyMatrix4( rotationMatrix );\n\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\n\n\t\t\t// Avoid rendering when reflector is facing away\n\n\t\t\tif ( view.dot( normal ) > 0 ) return;\n\n\t\t\tview.reflect( normal ).negate();\n\t\t\tview.add( reflectorWorldPosition );\n\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\n\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\n\t\t\tlookAtPosition.add( cameraWorldPosition );\n\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\n\t\t\ttarget.reflect( normal ).negate();\n\t\t\ttarget.add( reflectorWorldPosition );\n\n\t\t\tvirtualCamera.position.copy( view );\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\n\t\t\tvirtualCamera.up.reflect( normal );\n\t\t\tvirtualCamera.lookAt( target );\n\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\n\n\t\t\tvirtualCamera.updateMatrixWorld();\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\n\n\t\t\t// Update the texture matrix\n\t\t\ttextureMatrix.set(\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\n\t\t\t\t0.0, 0.0, 0.0, 1.0\n\t\t\t);\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\n\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\n\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\n\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\n\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\n\t\t\tq.z = - 1.0;\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\n\n\t\t\t// Calculate the scaled plane vector\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\n\n\t\t\t// Replacing the third row of the projection matrix\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\n\n\t\t\t// Render\n\n\t\t\trenderTarget.texture.encoding = renderer.outputEncoding;\n\n\t\t\tscope.visible = false;\n\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\n\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\n\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\n\n\t\t\trenderer.setRenderTarget( renderTarget );\n\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\n\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\n\t\t\trenderer.render( scene, virtualCamera );\n\n\t\t\trenderer.xr.enabled = currentXrEnabled;\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\n\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\n\n\t\t\t// Restore viewport\n\n\t\t\tconst viewport = camera.viewport;\n\n\t\t\tif ( viewport !== undefined ) {\n\n\t\t\t\trenderer.state.viewport( viewport );\n\n\t\t\t}\n\n\t\t\tscope.visible = true;\n\n\t\t};\n\n\t\tthis.getRenderTarget = function () {\n\n\t\t\treturn renderTarget;\n\n\t\t};\n\n\t\tthis.dispose = function () {\n\n\t\t\trenderTarget.dispose();\n\t\t\tscope.material.dispose();\n\n\t\t};\n\n\t}\n\n}\n\nReflector.prototype.isReflector = true;\n\nReflector.ReflectorShader = {\n\n\tuniforms: {\n\n\t\t'color': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'tDiffuse': {\n\t\t\tvalue: null\n\t\t},\n\n\t\t'textureMatrix': {\n\t\t\tvalue: null\n\t\t}\n\n\t},\n\n\tvertexShader: /* glsl */`\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}`\n};\n\nexport { Reflector };\n"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","camera","scene","renderer","cameraControls","smallSphere","groundMirror","mounted","this","init","animate","methods","canvas","document","querySelector","geometry","material","THREE","antialias","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","useLegacyLights","clientWidth","clientHeight","position","set","OrbitControls","domElement","update","Reflector","clipBias","textureWidth","textureHeight","y","rotateX","Math","PI","add","color","emissive","flatShading","mainLight","gridHelper","resizeRendererToDisplaySize","width","height","needResize","getRenderTarget","requestAnimationFrame","aspect","updateProjectionMatrix","timer","Date","now","cos","abs","sin","rotation","z","render","__exports__","Mesh","constructor","options","super","type","scope","undefined","Color","shader","ReflectorShader","reflectorPlane","Plane","normal","Vector3","reflectorWorldPosition","cameraWorldPosition","rotationMatrix","Matrix4","lookAtPosition","clipPlane","Vector4","view","target","q","textureMatrix","virtualCamera","PerspectiveCamera","renderTarget","WebGLRenderTarget","ShaderMaterial","uniforms","UniformsUtils","fragmentShader","vertexShader","value","texture","onBeforeRender","setFromMatrixPosition","matrixWorld","extractRotation","applyMatrix4","subVectors","dot","reflect","negate","copy","up","lookAt","far","updateMatrixWorld","projectionMatrix","multiply","matrixWorldInverse","setFromNormalAndCoplanarPoint","x","constant","sign","elements","w","multiplyScalar","encoding","outputEncoding","visible","currentRenderTarget","currentXrEnabled","xr","enabled","currentShadowAutoUpdate","shadowMap","autoUpdate","setRenderTarget","state","buffers","depth","setMask","autoClear","clear","viewport","dispose","prototype","isReflector"],"sourceRoot":""}