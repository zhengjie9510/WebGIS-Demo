{"version":3,"file":"js/6631.70dec704.js","mappings":"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","sources":["webpack://webgis/./src/components/three/high_speed_light_trails.vue","webpack://webgis/./src/components/three/high_speed_light_trails.vue?e9ca"],"sourcesContent":["<template>\n    <div class=\"container\"><canvas id=\"c\"></canvas></div>\n</template>\n<script>\nimport * as THREE from 'three'\nconst mountainUniforms = {\n    // x, y, z\n    uFreq: new THREE.Uniform(new THREE.Vector3(3, 6, 10)),\n    uAmp: new THREE.Uniform(new THREE.Vector3(30, 30, 20))\n};\nconst nsin = val => Math.sin(val) * 0.5 + 0.5;\nconst mountainDistortion = {\n    uniforms: mountainUniforms,\n    getDistortion: `\n                uniform vec3 uAmp;\n                uniform vec3 uFreq;\n\n                #define PI 3.14159265358979\n                float nsin(float val){\n                    return sin(val) * 0.5+0.5;\n                }\n                \n                vec3 getDistortion(float progress){\n                    float movementProgressFix = 0.02;\n                    return vec3( \n                        cos(progress * PI * uFreq.x + uTime) * uAmp.x - cos(movementProgressFix * PI * uFreq.x + uTime) * uAmp.x,\n                        nsin(progress * PI * uFreq.y + uTime) * uAmp.y - nsin(movementProgressFix * PI * uFreq.y + uTime) * uAmp.y,\n                        nsin(progress * PI * uFreq.z + uTime) * uAmp.z - nsin(movementProgressFix * PI * uFreq.z + uTime) * uAmp.z\n                    );\n                }\n            `,\n    getJS: (progress, time) => {\n        let movementProgressFix = 0.02;\n\n        let uFreq = mountainUniforms.uFreq.value;\n        let uAmp = mountainUniforms.uAmp.value;\n\n        let distortion = new THREE.Vector3(\n            Math.cos(progress * Math.PI * uFreq.x + time) * uAmp.x -\n            Math.cos(movementProgressFix * Math.PI * uFreq.x + time) * uAmp.x,\n            nsin(progress * Math.PI * uFreq.y + time) * uAmp.y -\n            nsin(movementProgressFix * Math.PI * uFreq.y + time) * uAmp.y,\n            nsin(progress * Math.PI * uFreq.z + time) * uAmp.z -\n            nsin(movementProgressFix * Math.PI * uFreq.z + time) * uAmp.z\n        );\n\n        let lookAtAmp = new THREE.Vector3(2, 2, 2);\n        let lookAtOffset = new THREE.Vector3(0, 0, -5);\n        return distortion.multiply(lookAtAmp).add(lookAtOffset);\n    }\n};\nclass App {\n    constructor(canvas, options) {\n        this.options = options\n        this.canvas = canvas\n        this.clock = new THREE.Clock();\n        this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });\n        this.renderer.setSize(this.canvas.innerWidth, this.canvas.innerHeight)\n        this.renderer.setPixelRatio(window.devicePixelRatio)\n\n        this.scene = new THREE.Scene()\n        this.camera = new THREE.PerspectiveCamera(45, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 10000)\n        this.camera.position.z = -5;\n        this.camera.position.y = 7;\n        this.camera.position.x = 0;\n\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.onMouseUp = this.onMouseUp.bind(this);\n        this.canvas.addEventListener(\"mousedown\", this.onMouseDown);\n        this.canvas.addEventListener(\"mouseup\", this.onMouseUp);\n        this.canvas.addEventListener(\"mouseout\", this.onMouseUp);\n\n        this.init()\n    }\n    init() {\n        const options = this.options;\n        this.speedUpTarget = 0;\n        this.speedUp = 0;\n        this.timeOffset = 0;\n        this.fovTarget = 90;\n\n        this.road = new Road(this.scene, options);\n        this.leftLights = new CarLights(this.scene, options, options.color.leftCars, 60);\n        this.leftLights.mesh.position.setX(\n            -options.roadWidth / 2 - options.islandWidth / 2\n        );\n        this.rightLights = new CarLights(this.scene, options, options.color.rightCars, -60);\n        this.rightLights.mesh.position.setX(\n            options.roadWidth / 2 + options.islandWidth / 2\n        );\n        this.leftSticks = new LightsSticks(this.scene, options);\n        this.leftSticks.mesh.position.setX(\n            -(options.roadWidth + options.islandWidth / 2)\n        );\n    }\n\n    update(delta) {\n        let coefficient = -60 * Math.log2(1 - 0.1);\n        let lerpT = Math.exp(-coefficient * delta);\n        this.speedUp += lerp(\n            this.speedUp,\n            this.speedUpTarget,\n            // 10% each frame\n            lerpT,\n            0.00001\n        );\n        // Also frame-dependent\n        this.timeOffset += this.speedUp * delta;\n\n        let time = this.clock.elapsedTime + this.timeOffset;\n        this.road.update(time)\n        this.leftLights.update(time);\n        this.rightLights.update(time);\n        this.leftSticks.update(time);\n\n        let fovChange = lerp(this.camera.fov, this.fovTarget, lerpT);\n        if (fovChange !== 0) {\n            this.camera.fov += fovChange * delta * 6;\n            this.camera.updateProjectionMatrix();\n        }\n        if (this.options.distortion.getJS) {\n            const distortion = this.options.distortion.getJS(0.025, time);\n\n            this.camera.lookAt(\n                new THREE.Vector3(\n                    this.camera.position.x + distortion.x,\n                    this.camera.position.y + distortion.y,\n                    this.camera.position.z + distortion.z\n                ))\n        }\n    }\n    onMouseDown(ev) {\n        this.speedUpTarget = 4;\n        this.fovTarget = 140;\n    }\n    onMouseUp(ev) {\n        this.speedUpTarget = 0;\n        this.fovTarget = 90;\n    }\n    resizeRendererToDisplaySize(renderer) {\n        const canvas = renderer.domElement\n        const width = canvas.clientWidth\n        const height = canvas.clientHeight\n        const needResize = canvas.width !== width || canvas.height !== height\n        if (needResize) {\n            renderer.setSize(width, height, false)\n        }\n        return needResize\n    }\n    render() {\n        if (this.resizeRendererToDisplaySize(this.renderer)) {\n            const canvas = this.renderer.domElement\n            this.camera.aspect = canvas.clientWidth / canvas.clientHeight\n            this.camera.updateProjectionMatrix()\n        }\n        const delta = this.clock.getDelta();\n        this.update(delta);\n        this.renderer.render(this.scene, this.camera);\n        requestAnimationFrame(this.render.bind(this));\n    }\n}\nclass Road {\n    constructor(scene, options) {\n        this.scene = scene;\n        this.options = options;\n        this.init()\n    }\n    init() {\n        const options = this.options;\n        const geometry = new THREE.PlaneBufferGeometry(options.width, options.length, 20, 200\n        );\n        const material = new THREE.ShaderMaterial({\n            uniforms: Object.assign(\n                {\n                    uColor: new THREE.Uniform(new THREE.Color(0x101012)),\n                    uTime: new THREE.Uniform(0),\n                    uTravelLength: new THREE.Uniform(options.length)\n                },\n                options.distortion.uniforms\n            ),\n            vertexShader: `\n                uniform float uTravelLength;\n                uniform float uTime;\n                #include <getDistortion_vertex>\n                void main(){\n                    vec3 transformed = position.xyz;\n                        \n                    float progress = (transformed.y + uTravelLength / 2.) / uTravelLength;\n                    vec3 distortion  = getDistortion(progress);\n                    transformed.x += distortion.x;\n                    transformed.z += distortion.y;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed.xyz, 1.);\n                }\n                `,\n            fragmentShader: `\n                uniform vec3 uColor;\n                void main(){\n                    gl_FragColor = vec4(uColor,1.);\n                }\n                `,\n            side: THREE.DoubleSide\n        })\n        material.onBeforeCompile = shader => {\n            shader.vertexShader = shader.vertexShader.replace(\n                \"#include <getDistortion_vertex>\",\n                options.distortion.getDistortion\n            );\n        };\n        const mesh = new THREE.Mesh(geometry, material);\n\n        mesh.rotation.x = -Math.PI / 2;\n        mesh.position.z = -options.length / 2;\n\n        this.scene.add(mesh);\n        this.mesh = mesh\n    }\n    update(time) {\n        this.mesh.material.uniforms.uTime.value = time;\n    }\n}\nclass CarLights {\n    constructor(scene, options, colors, speed) {\n        this.scene = scene;\n        this.options = options;\n        this.colors = colors;\n        this.speed = speed;\n        this.init()\n    }\n    init() {\n        const options = this.options;\n\n        const curve = new THREE.LineCurve3(\n            new THREE.Vector3(0, 0, 0),\n            new THREE.Vector3(0, 0, -1)\n        )\n        const baseGeometry = new THREE.TubeBufferGeometry(curve, 25, 1, 8, false);\n\n        const instanced = new THREE.InstancedBufferGeometry().copy(baseGeometry);\n        instanced.instanceCount = options.nPairs * 2;\n\n        let aOffset = [];\n        let aMetrics = [];\n        let aColor = [];\n\n        let colors = this.colors;\n        if (Array.isArray(colors)) {\n            colors = colors.map(c => new THREE.Color(c));\n        } else {\n            colors = new THREE.Color(colors);\n        }\n\n        let sectionWidth = options.roadWidth / options.roadSections;\n        for (let i = 0; i < options.nPairs; i++) {\n            let radius = Math.random() * 0.1 + 0.1;\n            let length =\n                Math.random() * options.length * 0.08 + options.length * 0.02;\n            // 1a. Get it's lane index\n            // Instead of random, keep lights per lane consistent\n            let section = i % 3;\n\n            // 1b. Get its lane's centered position\n            let sectionX = section * sectionWidth - options.roadWidth / 2 + sectionWidth / 2;\n            let carWidth = 0.5 * sectionWidth;\n            let offsetX = 0.5 * Math.random();\n\n            let offsetY = radius * 1.3;\n\n            let offsetZ = Math.random() * options.length;\n\n            aOffset.push(sectionX - carWidth / 2 + offsetX);\n            aOffset.push(offsetY);\n            aOffset.push(-offsetZ);\n\n            aOffset.push(sectionX + carWidth / 2 + offsetX);\n            aOffset.push(offsetY);\n            aOffset.push(-offsetZ);\n\n            aMetrics.push(radius);\n            aMetrics.push(length);\n\n            aMetrics.push(radius);\n            aMetrics.push(length);\n\n            let color = pickRandom(colors);\n            aColor.push(color.r);\n            aColor.push(color.g);\n            aColor.push(color.b);\n\n            aColor.push(color.r);\n            aColor.push(color.g);\n            aColor.push(color.b);\n        }\n        // Add the offset to the instanced geometry.\n        instanced.setAttribute(\n            \"aOffset\",\n            new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 3, false)\n        );\n        instanced.setAttribute(\n            \"aMetrics\",\n            new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\n        );\n        instanced.setAttribute(\n            \"aColor\",\n            new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\n        );\n        const material = new THREE.ShaderMaterial({\n            fragmentShader: `\n                in vec3 vColor;\n                void main() {\n                    gl_FragColor = vec4(vColor,1.);\n                }\n                `,\n            vertexShader: `\n                in vec3 aOffset;\n                in vec2 aMetrics;\n                in vec3 aColor;\n                out vec3 vColor;\n                uniform float uTime;\n                uniform float uSpeed;\n                uniform float uTravelLength;\n                #include <getDistortion_vertex>\n                void main() {\n                    vec3 transformed = position.xyz;\n\n                    float radius = aMetrics.r;\n                    float len = aMetrics.g;\n                    transformed.xy *= radius; \n                    transformed.z *= len;\n\n                    float zOffset = uTime * uSpeed + aOffset.z;\n                    zOffset = len - mod(zOffset, uTravelLength);\n\n                    // transformed.z +=uTime * uSpeed;\n\n\n                    // Keep them separated to make the next step easier!\n                    transformed.z = transformed.z +zOffset ;\n                    transformed.xy += aOffset.xy;\n\n\n                    float progress = abs(transformed.z / uTravelLength);\n                    transformed.xyz += getDistortion(progress);\n\n                    vColor = aColor;\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n                    gl_Position = projectionMatrix * mvPosition;\n                }`,\n            uniforms: Object.assign(\n                {\n                    uColor: new THREE.Uniform(new THREE.Color(this.color)),\n                    uTravelLength: new THREE.Uniform(options.length),\n                    uTime: new THREE.Uniform(0),\n                    uSpeed: new THREE.Uniform(this.speed)\n                },\n                options.distortion.uniforms\n            )\n        });\n        material.onBeforeCompile = shader => {\n            shader.vertexShader = shader.vertexShader.replace(\n                \"#include <getDistortion_vertex>\",\n                options.distortion.getDistortion\n            );\n        };\n        let mesh = new THREE.Mesh(instanced, material);\n        mesh.frustumCulled = false;\n        this.mesh = mesh;\n        this.scene.add(mesh);\n    }\n    update(time) {\n        this.mesh.material.uniforms.uTime.value = time;\n    }\n}\nclass LightsSticks {\n    constructor(scene, options) {\n        this.scene = scene;\n        this.options = options;\n        this.init()\n    }\n    init() {\n        const options = this.options;\n        const geometry = new THREE.PlaneBufferGeometry(1, 1);\n        let instanced = new THREE.InstancedBufferGeometry().copy(geometry);\n        let totalSticks = options.totalSideLightSticks;\n        instanced.instanceCount = totalSticks;\n\n        let stickoffset = options.length / (totalSticks - 1);\n        const aOffset = [];\n        const aColor = [];\n        const aMetrics = [];\n\n        let colors = this.options.color.sticks\n\n        if (Array.isArray(colors)) {\n            colors = colors.map(c => new THREE.Color(c));\n        } else {\n            colors = new THREE.Color(colors);\n        }\n\n        for (let i = 0; i < totalSticks; i++) {\n            let width = random(options.lightStickWidth);\n            let height = random(options.lightStickHeight);\n            aOffset.push((i - 1) * stickoffset * 2 + stickoffset * Math.random());\n\n            let color = pickRandom(colors);\n            aColor.push(color.r);\n            aColor.push(color.g);\n            aColor.push(color.b);\n\n            aMetrics.push(width);\n            aMetrics.push(height);\n        }\n        instanced.setAttribute(\n            \"aOffset\",\n            new THREE.InstancedBufferAttribute(new Float32Array(aOffset), 1, false)\n        );\n        instanced.setAttribute(\n            \"aColor\",\n            new THREE.InstancedBufferAttribute(new Float32Array(aColor), 3, false)\n        );\n        instanced.setAttribute(\n            \"aMetrics\",\n            new THREE.InstancedBufferAttribute(new Float32Array(aMetrics), 2, false)\n        );\n        const material = new THREE.ShaderMaterial({\n            fragmentShader: `\n                varying vec3 vColor;\n                void main(){\n                    vec3 color = vec3(vColor);\n                    gl_FragColor = vec4(color,1.);\n                }\n                `,\n            vertexShader: `\n                attribute float aOffset;\n                attribute vec3 aColor;\n\n                attribute vec2 aMetrics;\n\n                uniform float uTravelLength;\n                uniform float uTime;\n\n                varying vec3 vColor;\n                mat4 rotationY( in float angle ) {\n                    return mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n                                            0,\t\t1.0,\t\t\t 0,\t0,\n                                    -sin(angle),\t0,\t\tcos(angle),\t0,\n                                            0, \t\t0,\t\t\t\t0,\t1);\n                }\n\n                #include <getDistortion_vertex>\n                void main(){\n                    vec3 transformed = position.xyz;\n                    float width = aMetrics.x;\n                    float height = aMetrics.y;\n\n                    transformed.xy *= vec2(width,height);\n                    float time = mod(uTime  * 60. *2. + aOffset , uTravelLength);\n\n                    transformed = (rotationY(3.14/2.) * vec4(transformed,1.)).xyz;\n\n                    transformed.z +=  - uTravelLength + time;\n\n\n                    float progress = abs(transformed.z / uTravelLength);\n                    transformed.xyz += getDistortion(progress);\n\n                    transformed.y += height /2.;\n                    transformed.x += -width/2.;\n                    vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\n                    gl_Position = projectionMatrix * mvPosition;\n                    vColor = aColor;\n                }\n                `,\n            // This ones actually need double side\n            side: THREE.DoubleSide,\n            uniforms: Object.assign(\n                {\n                    uTravelLength: new THREE.Uniform(options.length),\n                    uTime: new THREE.Uniform(0)\n                },\n                options.distortion.uniforms\n            )\n        });\n\n        material.onBeforeCompile = shader => {\n            shader.vertexShader = shader.vertexShader.replace(\n                \"#include <getDistortion_vertex>\",\n                options.distortion.getDistortion\n            );\n        };\n\n        const mesh = new THREE.Mesh(instanced, material);\n        // The object is behind the camera before the vertex shader\n        mesh.frustumCulled = false;\n        // mesh.position.y = options.lightStickHeight / 2;\n        this.scene.add(mesh);\n        this.mesh = mesh;\n    }\n    update(time) {\n        this.mesh.material.uniforms.uTime.value = time;\n    }\n\n}\nfunction random(base) {\n    if (Array.isArray(base)) return Math.random() * (base[1] - base[0]) + base[0];\n    return Math.random() * base;\n}\nfunction pickRandom(arr) {\n    if (Array.isArray(arr)) return arr[Math.floor(Math.random() * arr.length)];\n    return arr;\n}\nfunction lerp(current, target, speed = 0.1, limit = 0.001) {\n    let change = (target - current) * speed;\n    if (Math.abs(change) < limit) {\n        change = target - current;\n    }\n    return change;\n}\nexport default {\n    mounted() {\n        this.init()\n    },\n    methods: {\n        init() {\n            const canvas = document.querySelector('#c')\n            const options = {\n                length: 400,\n                width: 20,\n                roadWidth: 9,\n                islandWidth: 2,\n                nPairs: 50,\n                roadSections: 3,\n                distortion: mountainDistortion,\n\n                totalSideLightSticks: 50,\n                lightStickWidth: [0.12, 0.5],\n                lightStickHeight: [1.3, 1.7],\n\n                color: {\n                    /***  Only these colors can be an array ***/\n                    leftCars: [0xff102a, 0xEB383E, 0xff102a],\n                    rightCars: [0xdadafa, 0xBEBAE3, 0x8F97E4],\n                    sticks: 0xdadafa,\n                }\n            };\n            const app = new App(canvas, options)\n            app.render()\n        },\n    },\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.container {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n}\n\n#c {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    margin: 0%;\n}\n</style>\n","import { render } from \"./high_speed_light_trails.vue?vue&type=template&id=39c6d57a&scoped=true\"\nimport script from \"./high_speed_light_trails.vue?vue&type=script&lang=js\"\nexport * from \"./high_speed_light_trails.vue?vue&type=script&lang=js\"\n\nimport \"./high_speed_light_trails.vue?vue&type=style&index=0&id=39c6d57a&lang=scss&scoped=true\"\n\nimport exportComponent from \"/Users/zhengjie/Documents/webgis/node_modules/vue-loader/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-39c6d57a\"]])\n\nexport default __exports__"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","mountainUniforms","uFreq","THREE","uAmp","nsin","val","Math","sin","mountainDistortion","uniforms","getDistortion","getJS","progress","time","movementProgressFix","value","distortion","cos","PI","x","y","z","lookAtAmp","lookAtOffset","multiply","add","App","constructor","canvas","options","this","clock","renderer","antialias","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","scene","camera","clientWidth","clientHeight","position","onMouseDown","bind","onMouseUp","addEventListener","init","speedUpTarget","speedUp","timeOffset","fovTarget","road","Road","leftLights","CarLights","color","leftCars","mesh","setX","roadWidth","islandWidth","rightLights","rightCars","leftSticks","LightsSticks","update","delta","coefficient","log2","lerpT","exp","lerp","elapsedTime","fovChange","fov","updateProjectionMatrix","lookAt","ev","resizeRendererToDisplaySize","domElement","width","height","needResize","render","aspect","getDelta","requestAnimationFrame","geometry","length","material","Object","assign","uColor","uTime","uTravelLength","vertexShader","fragmentShader","side","onBeforeCompile","shader","replace","rotation","colors","speed","curve","baseGeometry","instanced","copy","instanceCount","nPairs","aOffset","aMetrics","aColor","Array","isArray","map","c","sectionWidth","roadSections","i","radius","random","section","sectionX","carWidth","offsetX","offsetY","offsetZ","push","pickRandom","r","g","b","setAttribute","Float32Array","uSpeed","frustumCulled","totalSticks","totalSideLightSticks","stickoffset","sticks","lightStickWidth","lightStickHeight","base","arr","floor","current","target","limit","change","abs","mounted","methods","document","querySelector","app","__exports__"],"sourceRoot":""}