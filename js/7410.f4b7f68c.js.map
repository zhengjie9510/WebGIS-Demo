{"version":3,"file":"js/7410.f4b7f68c.js","mappings":"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","sources":["webpack://webgis/./src/components/three/custom_surface.vue","webpack://webgis/./src/components/three/custom_surface.vue?0657"],"sourcesContent":["<template>\r\n  <div class=\"container\"><canvas id=\"c\"></canvas></div>\r\n</template>\r\n<script>\r\nimport * as THREE from 'three'\r\nclass SurfaceGeometry extends THREE.BufferGeometry {\r\n  constructor(width = 1, height = 1, matrix) {\r\n    super();\r\n    this.type = 'SurfaceGeometry';\r\n    const width_half = width / 2;\r\n    const height_half = height / 2;\r\n    const widthSegments = matrix[0].length - 1\r\n    const heightSegments = matrix.length - 1\r\n    const gridX = Math.floor(widthSegments);\r\n    const gridY = Math.floor(heightSegments);\r\n    const gridX1 = gridX + 1;\r\n    const gridY1 = gridY + 1;\r\n    const segment_width = width / gridX;\r\n    const segment_height = height / gridY; //\r\n\r\n    const numVertices = gridX1 * gridY1;\r\n    const numIndices = gridX * gridY * 6; // 6 indices per quad\r\n\r\n    const positionData = new Float32Array(numVertices * 3);\r\n    const indexData = new Uint16Array(numIndices);\r\n\r\n    let vertexIndex = 0;\r\n    let indexIndex = 0;\r\n\r\n    for (let iy = 0; iy < gridY1; iy++) {\r\n      const y = iy * segment_height - height_half;\r\n\r\n      for (let ix = 0; ix < gridX1; ix++) {\r\n        const x = ix * segment_width - width_half;\r\n\r\n        positionData[vertexIndex] = x;\r\n        positionData[vertexIndex + 1] = -y;\r\n        positionData[vertexIndex + 2] = matrix[ix][iy];\r\n\r\n        vertexIndex += 3;\r\n      }\r\n    }\r\n    for (let iy = 0; iy < gridY; iy++) {\r\n      for (let ix = 0; ix < gridX; ix++) {\r\n        const a = ix + gridX1 * iy;\r\n        const b = ix + gridX1 * (iy + 1);\r\n        const c = ix + 1 + gridX1 * (iy + 1);\r\n        const d = ix + 1 + gridX1 * iy;\r\n\r\n        indexData[indexIndex++] = a;\r\n        indexData[indexIndex++] = b;\r\n        indexData[indexIndex++] = d;\r\n        indexData[indexIndex++] = b;\r\n        indexData[indexIndex++] = c;\r\n        indexData[indexIndex++] = d;\r\n      }\r\n    }\r\n\r\n    this.setIndex(new THREE.BufferAttribute(indexData, 1));\r\n    this.setAttribute('position', new THREE.BufferAttribute(positionData, 3));\r\n    this.computeVertexNormals()\r\n  }\r\n}\r\nclass SurfaceMaterial extends THREE.ShaderMaterial {\r\n  constructor(parameters) {\r\n    super();\r\n    this.type = 'SurfaceMaterial';\r\n    this.vertexShader = `\r\n        out float value;\r\n        void main() {\r\n            value = position.z;\r\n            vec3 transformed = position.xyz;\r\n            vec4 mvPosition = modelViewMatrix * vec4(transformed,1.);\r\n            gl_Position = projectionMatrix * mvPosition;\r\n        }`;\r\n    this.fragmentShader = `\r\n        uniform float min_value;\r\n        uniform float max_value;\r\n        in float value;\r\n        vec4 interpolateColor(float t) {\r\n          t = smoothstep(min_value,max_value,t);\r\n          vec3 green = vec3(0.0, 1.0, 0.0);\r\n          vec3 red = vec3(1.0, 0.0, 0.0);\r\n          vec3 color = mix(green, red, t);\r\n          return vec4(color, smoothstep(0.0,0.1,t));\r\n        }\r\n        void main() {\r\n\r\n            gl_FragColor = interpolateColor(value);\r\n        }\r\n\r\n        `;\r\n    if (parameters !== undefined) {\r\n      if (parameters.attributes !== undefined) {\r\n        console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');\r\n      }\r\n\r\n      this.setValues(parameters);\r\n    }\r\n  }\r\n}\r\nclass App {\r\n  constructor(canvas) {\r\n    this.canvas = canvas\r\n    this.renderer = new THREE.WebGLRenderer({ canvas: this.canvas, antialias: true });\r\n    this.renderer.setSize(this.canvas.innerWidth, this.canvas.innerHeight)\r\n    this.renderer.setPixelRatio(window.devicePixelRatio)\r\n\r\n    this.scene = new THREE.Scene()\r\n    this.camera = new THREE.PerspectiveCamera(45, this.canvas.clientWidth / this.canvas.clientHeight, 0.1, 10000)\r\n    this.camera.position.z = 5\r\n\r\n    this.init()\r\n  }\r\n  init() {\r\n\r\n    const matrix = this.generateMatrix(100, 10)\r\n    const geometry = new SurfaceGeometry(5, 5, matrix);\r\n    const material = new SurfaceMaterial({\r\n      wireframe: true,\r\n      uniforms: {\r\n        min_value: { value: 0.0 },\r\n        max_value: { value: 1.0 },\r\n      },\r\n      transparent: true\r\n    })\r\n\r\n    const mesh = new THREE.Mesh(geometry, material);\r\n    mesh.rotateX(-45)\r\n    this.mesh = mesh\r\n    this.scene.add(mesh);\r\n  }\r\n  generateMatrix(size, sigma) {\r\n    var matrix = [];\r\n    var centerX = Math.floor(size / 2);\r\n    var centerY = Math.floor(size / 2);\r\n\r\n    // 循环生成矩阵\r\n    for (var i = 0; i < size; i++) {\r\n      matrix[i] = [];\r\n      for (var j = 0; j < size; j++) {\r\n        // 计算距离矩阵中心的距离\r\n        var distance = Math.sqrt(Math.pow(i - centerX, 2) + Math.pow(j - centerY, 2));\r\n\r\n        // 计算高斯分布的值\r\n        var value = Math.exp(-Math.pow(distance, 2) / (2 * Math.pow(sigma, 2)));\r\n\r\n        // 将值保存到矩阵中\r\n        matrix[i][j] = value;\r\n      }\r\n    }\r\n\r\n    return matrix;\r\n  }\r\n  resizeRendererToDisplaySize(renderer) {\r\n    const canvas = renderer.domElement\r\n    const width = canvas.clientWidth\r\n    const height = canvas.clientHeight\r\n    const needResize = canvas.width !== width || canvas.height !== height\r\n    if (needResize) {\r\n      renderer.setSize(width, height, false)\r\n    }\r\n    return needResize\r\n  }\r\n  render() {\r\n    if (this.resizeRendererToDisplaySize(this.renderer)) {\r\n      const canvas = this.renderer.domElement\r\n      this.camera.aspect = canvas.clientWidth / canvas.clientHeight\r\n      this.camera.updateProjectionMatrix()\r\n    }\r\n    this.mesh.rotateZ(0.005)\r\n    this.renderer.render(this.scene, this.camera);\r\n    requestAnimationFrame(this.render.bind(this));\r\n  }\r\n}\r\nexport default {\r\n  mounted() {\r\n    this.init()\r\n  },\r\n  methods: {\r\n    init() {\r\n      const canvas = document.querySelector('#c')\r\n      const app = new App(canvas)\r\n      app.render()\r\n    },\r\n  },\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n.container {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n}\r\n\r\n#c {\r\n  position: absolute;\r\n  height: 100%;\r\n  width: 100%;\r\n  margin: 0%;\r\n}\r\n</style>\r\n","import { render } from \"./custom_surface.vue?vue&type=template&id=ec9b2d76&scoped=true\"\nimport script from \"./custom_surface.vue?vue&type=script&lang=js\"\nexport * from \"./custom_surface.vue?vue&type=script&lang=js\"\n\nimport \"./custom_surface.vue?vue&type=style&index=0&id=ec9b2d76&lang=scss&scoped=true\"\n\nimport exportComponent from \"D:\\\\Documents\\\\GitHub\\\\webgis\\\\node_modules\\\\vue-loader\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-ec9b2d76\"]])\n\nexport default __exports__"],"names":["class","_createElementVNode","id","_hoisted_2","_createElementBlock","_hoisted_1","SurfaceGeometry","THREE","constructor","width","height","matrix","super","this","type","width_half","height_half","widthSegments","length","heightSegments","gridX","Math","floor","gridY","gridX1","gridY1","segment_width","segment_height","numVertices","numIndices","positionData","Float32Array","indexData","Uint16Array","vertexIndex","indexIndex","iy","y","ix","x","a","b","c","d","setIndex","setAttribute","computeVertexNormals","SurfaceMaterial","parameters","vertexShader","fragmentShader","undefined","attributes","console","error","setValues","App","canvas","renderer","antialias","setSize","innerWidth","innerHeight","setPixelRatio","window","devicePixelRatio","scene","camera","clientWidth","clientHeight","position","z","init","generateMatrix","geometry","material","wireframe","uniforms","min_value","value","max_value","transparent","mesh","rotateX","add","size","sigma","centerX","centerY","i","j","distance","sqrt","pow","exp","resizeRendererToDisplaySize","domElement","needResize","render","aspect","updateProjectionMatrix","rotateZ","requestAnimationFrame","bind","mounted","methods","document","querySelector","app","__exports__"],"sourceRoot":""}